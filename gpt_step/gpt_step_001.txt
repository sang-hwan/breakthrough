아래는 *“돌파매매 전략”*의 주요 내용을 유지하면서, 직접 작성하신 코드를 어떻게 반영·확장했는지를 설명을 담았습니다.

---

## systrader79와 김대현 저자의 저서 *“돌파매매 전략”* 에서 다루는 주요 내용

### 1. **어느 구간을 돌파로 볼 것인가?**

#### 1) **전고점 돌파**
- **설명:**  
  과거 특정 기간(예: 20일) 동안의 최고가를 넘어서는 순간을 돌파로 판단합니다. 이는 향후 상승 추세 시작을 시사하며, 거래량 증가까지 동반되면 ‘진성 돌파’ 가능성이 높아집니다.
- **코드 적용:**  
  - `breakout_signal.py`의 `calculate_breakout_signals()`에서 `window` 기간 동안의 최고가를 `highest_{window}`로 계산해 돌파(breakout_signal) 여부를 확인.
  - `use_high` 파라미터로 고가(high) 기준 vs 종가(close) 기준 돌파를 선택 가능.
  - `breakout_buffer`를 통해 “전고점 + α” 여유분을 두어 노이즈성 돌파(가짜 돌파)를 줄일 수 있음.
- **예시:**  
  - 20일 최고가가 100,000원일 때, 주가가 101,000원을 돌파하면 신호 발생.  
  - 직전 평균 거래량 대비 1.5배(또는 2배) 이상이면 돌파 신뢰도 상승.

#### 2) **변동성 축소 패턴(VCP)**
- **설명:**  
  변동폭이 점차 줄어들다 특정 시점에 강력한 거래량을 동반해 돌파하면 매수 신호로 봅니다.
- **코드 적용:**  
  - 현재 예시 코드에는 “VCP를 직접 측정”하는 로직은 없으나, `technical_indicators.py`에 있는 ATR, Bollinger Band 등 지표로 “변동성 축소” 구간을 파악할 수 있음.
  - 이후 `breakout_signal`과 볼린저 밴드 상단 돌파 등을 결합해 VCP 형태의 진입 타이밍 포착 가능.

#### 3) **박스권 상단 돌파**
- **설명:**  
  횡보 구간(박스권)의 상단을 돌파하는 순간을 매수 시그널로 간주합니다.
- **코드 적용:**  
  - `calculate_breakout_signals()`를 응용해 일정 기간의 “최고가·최저가”를 이용하거나, Donchian Channel과 같은 지표를 통해 박스권을 정의할 수 있음.
  - 상단을 돌파하면 `breakout_signal=True`로 잡아 매수 조건을 충족.
- **예시:**  
  - 박스권 상단 120,000원, 하단 110,000원일 때, 주가가 121,000원 이상으로 올라서면 매수 신호.

**정리**  
- 전고점, 박스권, VCP 등 다양한 돌파 시나리오를 `breakout_signal.py` 안에서 `window`, `breakout_buffer`, `confirm_bars` 등 파라미터로 유연하게 설정 가능.
- 코인 시장 특성(24시간 거래, 높은 변동성 등)을 반영하려면, 돌파 자체 외에도 **거래량 조건**(`volume_condition`)을 중시해 가짜 돌파를 줄이도록 합니다.

---

### 2. **돌파 확정 시점을 어떻게 잡을 것인가?**

#### 1) **거래량 확인**
- **설명:**  
  돌파 시점 거래량이 급증한다면 강한 매수세 유입을 의미하므로, 진성 돌파 가능성이 높습니다.
- **코드 적용:**  
  - `calculate_breakout_signals()` 내에서 `volume_condition`을 확인: 현재 거래량이 과거 `window`봉 평균 거래량 × `vol_factor`(기본 1.5) 이상인지 검사.

#### 2) **종가 기준 확인**
- **설명:**  
  저항을 돌파한 후, 일정 기간(예: 2~3봉) 동안 종가가 저항선 위에서 마감하면 “확정 돌파”로 보는 방식입니다.
- **코드 적용:**  
  - `confirmed_breakout` 계산 시, `confirm_bars` 연속으로 `breakout_signal=True`인지 확인.
  - 예: `confirm_bars=2` → 2봉 연속 돌파 신호가 뜨면 ‘확정 돌파’로 판단.

**정리**  
- “돌파 + (거래량 증가 여부) + (연속 봉 종가 유지)” 세 요소가 **가짜 돌파 방지**의 핵심.
- 봉 단위(일봉, 4시간봉 등)는 `fetch_binance_data.py`에서 `timeframe` 선택으로 유연하게 적용 가능.

---

### 3. **손절과 익절 기준을 어떻게 잡을 것인가?**

#### 1) **손절 기준**
- **설명:**  
  상승 추세가 무너졌을 때 빠르게 이탈할 수 있도록 명확한 손절 규칙을 두어야 합니다.
- **코드 적용:**
  - `stop_loss_take_profit.py`의 `apply_stop_loss_atr()`에서는 **ATR × 배수**(기본 2.0)를 활용해 동적 손절 라인(`stop_loss_price`)을 생성.
  - 돌파 실패(예: 종가가 전고점 아래로 재차 내려간 경우) 시, 매수 포지션 해제(손절)하는 식으로도 조합 가능.
- **예시:**  
  - 매수 시점(101,000원)에서 ATR이 1,000원이라면, ATR×2=2,000원 → 손절 라인은 99,000원.

#### 2) **익절 기준**
- **설명:**  
  목표 수익률 도달 시 전부 혹은 분할 익절, 혹은 트레일링 스탑 등 다양한 방법으로 수익을 고정할 수 있습니다.
- **코드 적용:**  
  - `apply_take_profit_ratio()`에서 매수가 대비 일정 비율(5%, 10%, 15% 등)로 목표가 설정.
  - 트레일링 스탑 방식을 원하는 경우, 현재 코드에 추가 로직(예: 최고가 대비 -3% 하락 시 청산 등)을 작성하여 구현 가능.
- **예시:**  
  - 매수가 100,000원 → 105,000원(5% 수익) 도달 시 50% 청산 → 110,000원(10% 수익) 도달 시 나머지 청산.

---

### 4. **분할매수/매도(포지션 관리) 전략은 어떻게 할 것인가?**

#### 1) **분할매수**
- **설명:**  
  한 번에 풀 진입하지 않고, 추세 확인 구간마다 추가 진입하여 리스크를 줄이고, 추세가 이어지면 수익 극대화를 도모합니다.
- **코드 적용:**  
  - `risk_management.py`의 `calculate_position_size()`로 전체 포지션 크기를 결정한 후, `split_position_sizes()`로 2~3차에 걸쳐 매수 물량을 나눌 수 있습니다.  
  - 피라미딩(‘pyramid_up’ 옵션) 방식 등도 지원.
- **예시:**  
  - 100,000원 돌파 시 50% 매수 → 102,000원 재돌파 시 나머지 50% 매수.

#### 2) **분할매도**
- **설명:**  
  목표가별로 분할 매도하여 일부 수익을 확정하면서도 추세가 더 이어지면 추가 이익을 노린다는 전략입니다.
- **코드 적용(아이디어):**  
  - 예시 코드에는 분할 매도 로직이 구체화돼 있지 않지만, `split_position_sizes()`와 유사한 형태로 분할 비중을 설정한 뒤, 목표가별 혹은 트레일링 스탑 시그널별로 나누어 매도할 수 있습니다.
- **예시:**  
  - 105,000원(5% 수익) 도달 시 50% 매도 → 110,000원(10% 수익) 도달 시 나머지 50% 매도.

---

### 5. **리스크 관리와 포지션 사이징**

- **설명:**  
  *돌파매매 전략*은 변동성에 민감하므로, 특정 트레이드에서 감당할 수 있는 최대 손실 폭(리스크)을 미리 정하고, 이에 맞춰 매수 물량(포지션 사이즈)을 결정하는 것이 중요합니다.
- **코드 적용:**  
  - `risk_management.py` 내 `calculate_position_size()`를 통해 계좌 잔고(`account_balance`), 1회 트레이드 위험허용도(`risk_per_trade`), 손절 가격(`stop_loss_price`) 등을 인수로 받아 포지션 크기를 산출.  
  - 예: 계좌잔고 10,000 USDT, 트레이드 리스크 1%(0.01), 진입가 100 USDT, 손절가 98 USDT라면, 코인 1개당 손실액 = 2 USDT + 수수료(예: 0.1%)를 고려하여 허용 가능 수량 계산.
  - **수수료(fee_rate)**까지 포함해 실제 리스크를 보정하므로, 보다 현실적 계산이 가능.

---

### 6. **데이터 수집 및 데이터베이스 관리**

- **데이터 수집**  
  - `data_collection/fetch_binance_data.py`에서 **Binance** 거래소의 과거(역사적) 혹은 최신 시세(OHLCV)를 `fetch_binance_historical_ohlcv()`, `fetch_binance_latest_ohlcv()` 함수로 불러올 수 있음.  
  - `ohlcv_data_pipeline.py`의 `collect_data_for_backtest()` 함수를 사용하면, 여러 심볼(예: BTC/USDT, ETH/USDT)과 여러 타임프레임(1h, 4h, 1d 등)을 한꺼번에 수집해 DataFrame으로 받는 작업이 자동화됨.

- **DB 저장 및 조회**  
  - `data_collection/postgres_ohlcv_handler.py`의 `save_ohlcv_to_postgres()`를 통해, 가져온 OHLCV 데이터를 PostgreSQL에 저장할 수 있음.  
    - 테이블 생성(`CREATE TABLE IF NOT EXISTS`) → 중복시 `ON CONFLICT DO NOTHING`으로 무시 → 최종 커밋.  
  - `load_ohlcv_from_postgres()`로 특정 테이블(예: `ohlcv_btcusdt_4h`)에서 원하는 기간(`start_date`, `end_date`)만큼 데이터를 불러올 수 있으므로, 백테스트나 실시간 분석에 활용 가능.

- **DB 삭제(정리)**  
  - `delete_ohlcv_tables_by_symbol(symbol)`를 호출하면, 특정 심볼과 관련된 테이블(예: `ohlcv_btcusdt_1h`, `ohlcv_btcusdt_4h` 등)을 한 번에 삭제할 수 있음.  
  - 데이터 정리나 불필요한 테이블 제거 시에 유용.

---

## **최종 요약**

1. **돌파 시그널**  
   - 전고점, 박스권, VCP 등 다양한 돌파 전략을 `breakout_signal.py`에서 유연하게 설정 가능.  
   - `volume_condition`, `confirm_bars` 등을 통해 가짜 돌파를 필터링.

2. **손익 관리**  
   - 손절(`apply_stop_loss_atr`)과 익절(`apply_take_profit_ratio`)을 명확히 설정해 리스크와 수익을 균형 있게 추구.  
   - 분할매수/매도(`split_position_sizes`)로 리스크 분산 및 심리적 안정.

3. **리스크 관리**  
   - `risk_management.py`에서 포지션 사이즈를 계산해, 1회 트레이드 당 손실을 계좌 잔고 대비 일정 비율 이하로 제한(예: 1~2%).

4. **데이터 파이프라인**  
   - `fetch_binance_data.py` + `ohlcv_data_pipeline.py`를 이용해 Binance API에서 OHLCV를 자동 수집.  
   - `postgres_ohlcv_handler.py`로 DB(PostgreSQL) 저장/조회/삭제 가능 → 백테스트, 실거래 모니터링 활용.

**결론적으로,** 이 코드는 *“돌파매매 전략”* 전반을 **코인 시장(혹은 다른 자산시장)에서 손쉽게 구현**할 수 있도록 구성된 예시입니다.  
- 모듈별로 잘 분리되어 있어 **확장성**과 **유지보수성**이 뛰어나며,  
- 투자자는 **가짜 돌파 방지**, **리스크 한도 관리**, **데이터 분석** 과정을 일괄 수행할 수 있어 **전략 연구/실무 운용**에 큰 도움이 됩니다.  

추가로 선물 지표(펀딩비, 오픈 인터레스트)나 거시 지표, 온체인 데이터 등을 함께 저장·활용하면 **돌파매매 전략**을 한층 더 고도화할 수 있습니다.  