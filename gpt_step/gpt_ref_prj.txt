[프로젝트 코드]
# data_collection/fetch_binance_data.py
# 이 파일은 바이낸스(Binance) 거래소에서 시세 데이터를 수집하는 데 사용됩니다.

import ccxt  # 다양한 거래소 API를 쉽게 사용할 수 있게 해주는 라이브러리
import pandas as pd  # 데이터 분석을 위한 라이브러리
import time  # 시간 관련 작업을 처리하기 위한 모듈
from datetime import datetime  # 날짜 및 시간을 처리하기 위한 모듈


def fetch_binance_historical_ohlcv(
    symbol: str,
    timeframe: str = '4h',
    start_date: str = '2021-01-01 00:00:00',
    limit_per_request: int = 1000,
    pause_sec: float = 1.0
) -> pd.DataFrame:
    """
    바이낸스에서 과거 데이터를 대량으로 수집하는 함수입니다.

    주요 기능:
    - 특정 시작 날짜부터 현재까지 데이터를 가져옵니다.
    - 데이터를 한 번에 'limit_per_request'만큼 가져오며,
      반복 호출로 더 많은 데이터를 수집합니다.
    - API 호출 제한을 피하기 위해 요청 사이에 대기 시간을 추가합니다.

    매개변수:
    - symbol: str
        거래 쌍을 나타냅니다. 예: 'BTC/USDT'
    - timeframe: str
        데이터 간격을 설정합니다. 예: '1m'(1분), '4h'(4시간), '1d'(1일)
    - start_date: str
        데이터 수집을 시작할 시점입니다. 예: '2021-01-01 00:00:00'
    - limit_per_request: int
        한 번 호출 시 가져올 데이터 개수입니다. 기본값은 1000입니다.
    - pause_sec: float
        연속 호출 사이에 대기할 시간(초)입니다. 기본값은 1.0초입니다.

    반환값:
    - pd.DataFrame
        날짜와 시세 데이터(open, high, low, close, volume)가 포함된 데이터프레임
    """
    # 바이낸스 거래소 객체 생성
    exchange = ccxt.binance()

    # 시작 날짜를 타임스탬프(ms 단위)로 변환
    since_ms = exchange.parse8601(start_date)

    # 수집한 데이터를 저장할 빈 리스트 생성
    all_ohlcv = []

    # 데이터 수집 반복문
    while True:
        # 바이낸스 API를 사용해 OHLCV(시세 데이터) 수집
        ohlcv = exchange.fetch_ohlcv(
            symbol=symbol,
            timeframe=timeframe,
            since=since_ms,
            limit=limit_per_request
        )

        # 불러온 데이터가 없으면 종료
        if not ohlcv:
            break

        # 가져온 데이터를 리스트에 추가
        all_ohlcv += ohlcv

        # 가장 최근 데이터의 타임스탬프를 가져와 다음 요청의 시작점으로 설정
        last_ts = ohlcv[-1][0]
        since_ms = last_ts + 1

        # API 호출 제한을 피하기 위해 대기
        time.sleep(pause_sec)

        # 마지막으로 가져온 데이터 개수가 한 번 호출의 최대 개수보다 적으면 종료
        if len(ohlcv) < limit_per_request:
            break

    # 수집된 데이터를 데이터프레임으로 변환
    df = pd.DataFrame(all_ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # 타임스탬프를 datetime 형식으로 변환
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

    # 타임스탬프를 데이터프레임의 인덱스로 설정
    df.set_index('timestamp', inplace=True)

    # 시세 데이터 컬럼들을 실수(float)형으로 변환
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)

    # 중복된 인덱스와 결측치 제거
    df = df[~df.index.duplicated()]
    df.dropna(inplace=True)

    # 최종 데이터프레임 반환
    return df


def fetch_binance_latest_ohlcv(symbol: str, timeframe: str = '4h', limit: int = 500) -> pd.DataFrame:
    """
    바이낸스에서 가장 최근 시세 데이터를 가져오는 함수입니다.

    주요 기능:
    - 지정된 개수의 최신 데이터를 가져옵니다.
    - 실시간 분석이나 단기 데이터가 필요한 경우 유용합니다.

    매개변수:
    - symbol: str
        거래 쌍을 나타냅니다. 예: 'BTC/USDT'
    - timeframe: str
        데이터 간격을 설정합니다. 예: '1m'(1분), '4h'(4시간), '1d'(1일)
    - limit: int
        가져올 데이터의 최대 개수입니다. 기본값은 500입니다.

    반환값:
    - pd.DataFrame
        날짜와 시세 데이터(open, high, low, close, volume)가 포함된 데이터프레임
    """
    # 바이낸스 거래소 객체 생성
    exchange = ccxt.binance()

    # 최신 데이터를 요청
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)

    # 데이터를 데이터프레임으로 변환
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # 타임스탬프를 datetime 형식으로 변환
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

    # 타임스탬프를 데이터프레임의 인덱스로 설정
    df.set_index('timestamp', inplace=True)

    # 시세 데이터 컬럼들을 실수(float)형으로 변환
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)

    # 중복된 인덱스와 결측치 제거
    df = df[~df.index.duplicated()]
    df.dropna(inplace=True)

    # 최종 데이터프레임 반환
    return df
---
# config/db_config.py
# 이 파일은 데이터베이스에 연결하기 위한 설정 정보를 저장합니다.

DATABASE = {
    # 데이터베이스 사용자 계정 정보
    'user': 'postgres',         # 데이터베이스 사용자 이름
    'password': '1234',         # 데이터베이스 사용자 비밀번호

    # 데이터베이스 서버 정보
    'host': 'localhost',        # 서버 주소 (localhost는 현재 컴퓨터를 의미)
    'port': 5432,               # 서버 포트 번호 (PostgreSQL의 기본 포트)

    # 데이터베이스 이름
    'dbname': 'my_trading_db'   # 연결할 데이터베이스의 이름
}
---
# data_collection/postgres_ohlcv_handler.py

from sqlalchemy import create_engine  # 데이터베이스와 연결을 쉽게 도와주는 도구
import psycopg2  # PostgreSQL 데이터베이스와 직접 소통하기 위한 라이브러리
import pandas as pd  # 데이터를 분석하고 조작하는 데 필요한 강력한 도구
from typing import Optional  # 매개변수의 타입을 선택적으로 정의하기 위해 사용
from config.db_config import DATABASE  # 데이터베이스 연결 설정 정보를 가져오기 위한 설정 파일

# OHLCV 데이터를 PostgreSQL 데이터베이스에 저장하는 함수
def save_ohlcv_to_postgres(df: pd.DataFrame, table_name: str = 'ohlcv_data') -> None:
    """
    OHLCV 데이터를 PostgreSQL 데이터베이스에 저장합니다.

    Parameters
    ----------
    df : pd.DataFrame
        OHLCV 데이터를 담은 pandas DataFrame 객체.
        필요한 컬럼: timestamp(인덱스), open, high, low, close, volume.
    table_name : str
        데이터를 저장할 테이블 이름. 기본값은 'ohlcv_data'.
    """
    
    # 데이터베이스에 연결합니다.
    conn = psycopg2.connect(
        user=DATABASE['user'],          # 데이터베이스 사용자 이름
        password=DATABASE['password'],  # 데이터베이스 비밀번호
        host=DATABASE['host'],          # 데이터베이스 호스트 (IP 주소 또는 도메인)
        port=DATABASE['port'],          # 데이터베이스 포트 번호
        dbname=DATABASE['dbname']       # 데이터베이스 이름
    )
    cur = conn.cursor()  # 데이터베이스 작업을 수행하기 위한 커서를 만듭니다.

    # 데이터를 저장할 테이블을 생성합니다. 이미 존재하면 넘어갑니다.
    create_table_query = f"""
    CREATE TABLE IF NOT EXISTS {table_name} (
        timestamp TIMESTAMP NOT NULL,       -- 데이터가 수집된 시점
        open DOUBLE PRECISION,             -- 시가 (주식이 시작된 가격)
        high DOUBLE PRECISION,             -- 고가 (가장 높은 가격)
        low DOUBLE PRECISION,              -- 저가 (가장 낮은 가격)
        close DOUBLE PRECISION,            -- 종가 (마감 가격)
        volume DOUBLE PRECISION,           -- 거래량 (거래된 총 수량)
        PRIMARY KEY (timestamp)            -- 기본 키는 timestamp (중복 방지)
    );
    """
    cur.execute(create_table_query)  # 테이블 생성 SQL 실행
    conn.commit()  # 데이터베이스에 변경 사항 적용

    # DataFrame 데이터를 하나씩 읽어서 테이블에 삽입합니다.
    for index, row in df.iterrows():  # DataFrame의 각 행을 반복
        insert_query = f"""
        INSERT INTO {table_name} (timestamp, open, high, low, close, volume)
        VALUES (%s, %s, %s, %s, %s, %s)
        ON CONFLICT (timestamp) 
        DO NOTHING;  -- timestamp가 중복되면 데이터를 삽입하지 않음
        """
        cur.execute(insert_query, (
            index.to_pydatetime(),  # timestamp를 datetime 형식으로 변환
            float(row['open']),    # 시가 값
            float(row['high']),    # 고가 값
            float(row['low']),     # 저가 값
            float(row['close']),   # 종가 값
            float(row['volume'])   # 거래량 값
        ))
    conn.commit()  # 삽입 작업 후 데이터베이스 적용

    # 데이터베이스 연결을 종료합니다.
    cur.close()  # 커서를 닫음
    conn.close()  # 연결 종료

# PostgreSQL 데이터베이스에서 OHLCV 데이터를 읽어오는 함수
def load_ohlcv_from_postgres(
    table_name: str = 'ohlcv_data',
    limit: Optional[int] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None
) -> pd.DataFrame:
    """
    PostgreSQL 데이터베이스에서 OHLCV 데이터를 가져옵니다.

    Parameters
    ----------
    table_name : str
        데이터를 가져올 테이블 이름. 기본값은 'ohlcv_data'.
    limit : Optional[int]
        가져올 데이터의 최대 행 수. 기본값은 제한 없음.
    start_date : Optional[str]
        데이터를 가져올 시작 날짜. 예: '2021-01-01 00:00:00'.
    end_date : Optional[str]
        데이터를 가져올 종료 날짜. 예: '2021-12-31 23:59:59'.

    Returns
    -------
    pd.DataFrame
        가져온 데이터를 담은 pandas DataFrame 객체.
    """
    
    # SQLAlchemy를 사용해 데이터베이스와 연결합니다.
    engine = create_engine(f"postgresql://{DATABASE['user']}:{DATABASE['password']}@{DATABASE['host']}:{DATABASE['port']}/{DATABASE['dbname']}")

    # 기본 SQL 쿼리 작성
    query = f"SELECT * FROM {table_name}"

    # 시작일과 종료일에 따른 조건을 추가합니다.
    where_clauses = []
    if start_date:
        where_clauses.append(f"timestamp >= '{start_date}'")  # 시작 날짜 조건
    if end_date:
        where_clauses.append(f"timestamp <= '{end_date}'")  # 종료 날짜 조건

    if where_clauses:
        query += " WHERE " + " AND ".join(where_clauses)  # 조건 추가

    query += " ORDER BY timestamp"  # 데이터를 시간 순으로 정렬

    if limit:
        query += f" LIMIT {limit}"  # 행 수 제한

    # 쿼리를 실행하고 결과를 DataFrame으로 변환
    df = pd.read_sql(query, engine, parse_dates=['timestamp'])  # timestamp를 datetime 형식으로 변환
    df.set_index('timestamp', inplace=True)  # timestamp를 인덱스로 설정
    return df

# 특정 자산(symbol)과 관련된 테이블 삭제
def delete_ohlcv_tables_by_symbol(symbol: str) -> None:
    """
    특정 자산(symbol)과 관련된 모든 데이터를 삭제합니다.
    예: symbol="BTC/USDT" -> "ohlcv_btcusdt_..." 패턴의 테이블 모두 삭제.
    """
    # 심볼을 데이터베이스 테이블 이름에 맞게 가공
    symbol_for_table = symbol.replace("/", "").lower()

    conn = psycopg2.connect(
        user=DATABASE['user'],
        password=DATABASE['password'],
        host=DATABASE['host'],
        port=DATABASE['port'],
        dbname=DATABASE['dbname']
    )
    cur = conn.cursor()

    # 삭제 대상 테이블 목록 조회
    find_tables_query = f"""
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'public'
          AND table_name LIKE 'ohlcv_{symbol_for_table}_%';
    """
    cur.execute(find_tables_query)
    tables = cur.fetchall()  # 테이블 이름 목록 가져오기

    # 조회된 테이블들을 순차적으로 삭제
    for (table_name,) in tables:
        drop_query = f"DROP TABLE IF EXISTS {table_name} CASCADE;"  # CASCADE: 연관된 데이터도 삭제
        print(f"[*] Dropping table: {table_name}")  # 삭제되는 테이블을 출력
        cur.execute(drop_query)

    conn.commit()  # 삭제 작업 저장
    cur.close()  # 커서 닫기
    conn.close()  # 연결 종료
---
# data_collection/ohlcv_data_pipeline.py

# 시간 관리 및 데이터 타입을 위한 모듈
import time
from datetime import datetime
from typing import List, Optional

# 외부 파일에서 데이터 수집 및 저장 함수 가져오기
from data_collection.fetch_binance_data import (
    fetch_binance_historical_ohlcv,  # 바이낸스에서 역사적 OHLCV 데이터 수집 함수
    fetch_binance_latest_ohlcv       # 바이낸스에서 최신 OHLCV 데이터 수집 함수
)
from data_collection.postgres_ohlcv_handler import save_ohlcv_to_postgres  # 데이터 저장 함수

def collect_data_for_backtest(
    symbols: List[str],
    timeframes: List[str],
    use_historical: bool = True,
    start_date: Optional[str] = '2018-01-01 00:00:00',
    limit_per_request: int = 1000,
    latest_limit: int = 500,
    pause_sec: float = 1.0
) -> None:
    """
    Binance에서 OHLCV 데이터를 수집 후 PostgreSQL 데이터베이스에 저장하는 함수입니다.

    Parameters:
        symbols (List[str]): 데이터 수집을 원하는 암호화폐 심볼 리스트. 예: ["BTC/USDT", "ETH/USDT"]
        timeframes (List[str]): 데이터 수집을 원하는 타임프레임 리스트. 예: ["1h", "4h", "1d"]
        use_historical (bool): True면 start_date부터 모든 데이터를 수집, False면 최신 데이터만 수집.
        start_date (str, optional): 역사적 데이터 수집 시작 날짜 (UTC 기준). 기본값: '2018-01-01 00:00:00'
        limit_per_request (int): 한 번의 요청에서 가져올 데이터 수. 기본값: 1000
        latest_limit (int): 최신 데이터 수집 시 가져올 데이터 수. 기본값: 500
        pause_sec (float): 각 요청 사이의 대기 시간(초). 기본값: 1.0

    Returns:
        None
    """
    # (1) 각 암호화폐 심볼에 대해 작업 시작
    for symbol in symbols:
        # (2) 각 타임프레임에 대해 작업 시작
        for tf in timeframes:
            print(f"\n[*] Fetching {symbol} - {tf} data...")

            # 데이터 수집 단계
            if use_historical:
                # (a) 역사적 데이터 수집
                if not start_date:
                    raise ValueError("start_date는 역사적 데이터 수집에 필수입니다.")
                df = fetch_binance_historical_ohlcv(
                    symbol=symbol,
                    timeframe=tf,
                    start_date=start_date,
                    limit_per_request=limit_per_request,
                    pause_sec=pause_sec
                )
            else:
                # (b) 최신 데이터 수집
                df = fetch_binance_latest_ohlcv(
                    symbol=symbol,
                    timeframe=tf,
                    limit=latest_limit
                )

            # 테이블 이름 생성
            table_name = f"ohlcv_{symbol.replace('/', '').lower()}_{tf}"
            print(f"    -> Total Rows Fetched: {len(df)}")

            # 수집한 데이터를 PostgreSQL 데이터베이스에 저장
            save_ohlcv_to_postgres(df, table_name=table_name)
            print(f"    -> Saved to table: {table_name}")

            # 다음 요청 전 잠시 대기 (API 부하 방지)
            time.sleep(pause_sec)
---
# strategies/breakout_signal.py

import pandas as pd # Pandas 라이브러리: 데이터 분석 및 처리 도구

def calculate_breakout_signals(
    df: pd.DataFrame,
    window: int = 20,
    vol_factor: float = 1.5,
    confirm_bars: int = 2,
    use_high: bool = False,
    breakout_buffer: float = 0.0
) -> pd.DataFrame:
    """
    데이터에서 전고점 돌파, 거래량 조건, 확정 돌파 신호를 계산하는 함수입니다.

    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 데이터를 포함한 DataFrame (열: 시가, 고가, 저가, 종가, 거래량 등)
    - window (int): 전고점과 평균 거래량 계산 기준이 되는 과거 데이터 기간 (기본값: 20)
    - vol_factor (float): 거래량이 과거 평균 대비 얼마나 높은지를 결정하는 배수 (기본값: 1.5)
    - confirm_bars (int): 돌파 신호가 몇 개의 연속 봉에서 발생해야 확정 돌파로 간주할지 (기본값: 2)
    - use_high (bool): True이면 고가 기준, False이면 종가 기준으로 돌파 여부 판단 (기본값: False)
    - breakout_buffer (float): 돌파 기준에 추가 여유값 (비율) (기본값: 0.0)
    ------------------------------------------------------------------------
    반환 (Return):
    - 추가 컬럼들이 포함된 DataFrame:
      - highest_xx: window 기간 동안의 전고점
      - breakout_signal: 돌파 신호(True/False)
      - volume_condition: 거래량 조건 만족 여부(True/False)
      - confirmed_breakout: 확정 돌파 신호(True/False)
    """

    # 1. 전고점(highest_xx) 계산
    # - window 기간 동안 고가(high)의 최댓값(전고점)을 구합니다.
    # - shift(1)를 통해 현재 봉 데이터를 제외하고 계산.
    df[f'highest_{window}'] = (
        df['high'].shift(1)  # 현재 봉 제외
        .rolling(window)    # 지정한 window 기간 동안 계산
        .max()              # 해당 기간 내 최대값(전고점)
    )

    # 2. 돌파 신호(breakout_signal) 계산
    # - 주가가 (전고점 + breakout_buffer)보다 높은 경우 돌파로 간주.
    # - use_high가 True일 경우 고가(high), False일 경우 종가(close)를 기준으로 계산.
    if use_high:
        df['breakout_signal'] = df['high'] > (
            df[f'highest_{window}'] * (1 + breakout_buffer)
        )
    else:
        df['breakout_signal'] = df['close'] > (
            df[f'highest_{window}'] * (1 + breakout_buffer)
        )

    # 3. 거래량 조건(volume_condition) 계산
    # - window 기간 동안 평균 거래량(vol_ma_xx)을 계산.
    # - 현재 거래량이 평균 거래량 * vol_factor보다 큰 경우 조건 만족(True).
    df[f'vol_ma_{window}'] = (
        df['volume'].shift(1)  # 현재 봉 제외
        .rolling(window)      # 지정된 window 기간 동안 평균값 계산
        .mean()               # 평균 거래량
    )
    df['volume_condition'] = df['volume'] > (vol_factor * df[f'vol_ma_{window}'])

    # 4. 확정 돌파(confirmed_breakout) 계산
    # - 돌파 신호가 confirm_bars 기간 동안 연속 발생하면 확정 돌파(True).
    # - rolling(confirm_bars)을 사용해 연속 신호 수를 합산.
    df['confirmed_breakout'] = (
        df['breakout_signal'].rolling(confirm_bars).sum() == confirm_bars
    )

    # NaN(초기 값 없음) 처리: False로 채움
    df['confirmed_breakout'] = df['confirmed_breakout'].fillna(False)

    return df
---
# strategies/technical_indicators.py

import pandas as pd

# `ta` 라이브러리를 사용하여 기술적 지표를 계산합니다.
from ta.trend import SMAIndicator, MACD # 추세 지표(SMA, MACD 등)
from ta.momentum import RSIIndicator # 모멘텀 지표(RSI 등)
from ta.volatility import BollingerBands # 변동성 지표(볼린저 밴드 등)

# 단순 이동평균(SMA) 계산 함수
def apply_sma(
    df: pd.DataFrame,  # 시세 데이터 (DataFrame 형식)
    price_col: str = 'close',  # 사용할 가격 데이터 컬럼 (기본값: '종가')
    window: int = 20,  # 이동평균 기간 (기본값: 20일)
    fillna: bool = False,  # 결측치(NaN) 처리 여부
    colname: str = 'sma'  # 계산 결과를 저장할 컬럼 이름
) -> pd.DataFrame:
    """
    단순 이동평균(SMA)을 계산하고 DataFrame에 결과를 추가합니다.
    """
    # ta 라이브러리의 SMAIndicator 클래스 생성
    indicator = SMAIndicator(
        close=df[price_col],
        window=window,
        fillna=fillna
    )
    # 계산된 SMA 값을 새로운 컬럼으로 추가
    df[colname] = indicator.sma_indicator()
    return df

# MACD (이동평균 수렴/확산) 계산 함수
def apply_macd(
    df: pd.DataFrame,
    price_col: str = 'close',  # 사용할 가격 데이터 컬럼
    window_slow: int = 26,  # 느린 이동평균 기간
    window_fast: int = 12,  # 빠른 이동평균 기간
    window_sign: int = 9,  # 시그널선 이동평균 기간
    fillna: bool = False,  # 결측치 처리 여부
    prefix: str = 'macd_'  # 결과 컬럼 접두사
) -> pd.DataFrame:
    """
    MACD 지표를 계산하고 MACD, 시그널선, 히스토그램을 추가합니다.
    """
    # MACD 지표 생성
    macd_indicator = MACD(
        close=df[price_col],
        window_slow=window_slow,
        window_fast=window_fast,
        window_sign=window_sign,
        fillna=fillna
    )
    # 계산 결과를 DataFrame에 추가
    df[f'{prefix}macd'] = macd_indicator.macd()
    df[f'{prefix}signal'] = macd_indicator.macd_signal()
    df[f'{prefix}diff'] = macd_indicator.macd_diff()
    return df

# RSI (Relative Strength Index) 계산 함수
def apply_rsi(
    df: pd.DataFrame,
    price_col: str = 'close',  # 사용할 가격 데이터 컬럼
    window: int = 14,  # RSI 계산 기간
    fillna: bool = False,  # 결측치 처리 여부
    colname: str = 'rsi'  # 결과를 저장할 컬럼 이름
) -> pd.DataFrame:
    """
    RSI 지표를 계산하고 DataFrame에 추가합니다.
    """
    # RSIIndicator 클래스 생성
    rsi_indicator = RSIIndicator(
        close=df[price_col],
        window=window,
        fillna=fillna
    )
    # 계산된 RSI 값을 DataFrame에 추가
    df[colname] = rsi_indicator.rsi()
    return df

# 볼린저 밴드 계산 함수
def apply_bollinger(
    df: pd.DataFrame,
    price_col: str = 'close',  # 사용할 가격 데이터 컬럼
    window: int = 20,  # 이동평균 및 표준편차 계산 기간
    window_dev: float = 2.0,  # 표준편차 곱
    fillna: bool = False,  # 결측치 처리 여부
    prefix: str = 'bb_'  # 결과 컬럼 접두사
) -> pd.DataFrame:
    """
    볼린저 밴드를 계산하고 관련 데이터를 DataFrame에 추가합니다.
    """
    # BollingerBands 클래스 생성
    bb = BollingerBands(
        close=df[price_col],
        window=window,
        window_dev=window_dev,
        fillna=fillna
    )
    # 각 계산 결과를 DataFrame에 추가
    df[f'{prefix}mavg'] = bb.bollinger_mavg()  # 중간선
    df[f'{prefix}hband'] = bb.bollinger_hband()  # 상단선
    df[f'{prefix}lband'] = bb.bollinger_lband()  # 하단선
    df[f'{prefix}pband'] = bb.bollinger_pband()  # 퍼센트 밴드
    df[f'{prefix}wband'] = bb.bollinger_wband()  # 폭 밴드
    df[f'{prefix}hband_ind'] = bb.bollinger_hband_indicator()  # 상단선 접촉 여부
    df[f'{prefix}lband_ind'] = bb.bollinger_lband_indicator()  # 하단선 접촉 여부
    return df
---
# strategies/stop_loss_take_profit.py

# 데이터 분석 및 수치 연산 라이브러리
import pandas as pd
import numpy as np
import ta  # 'ta'는 ATR, RSI 등 다양한 기술적 지표를 제공하는 라이브러리

def apply_stop_loss_atr(
    df: pd.DataFrame,
    atr_window: int = 14,
    atr_multiplier: float = 2.0,
    sl_colname: str = 'stop_loss_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    ATR(평균진폭)을 기반으로 손절가(stop_loss_price)를 계산하여 DataFrame에 추가합니다.
    
    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 매수 신호(long_entry)와 가격 정보(시가, 고가, 저가, 종가 등)가 포함된 데이터.
    - atr_window (int): ATR 계산에 사용할 과거 캔들 수. 기본값: 14
    - atr_multiplier (float): 손절가 계산 시 ATR에 곱할 배수. 기본값: 2.0
    - sl_colname (str): 계산된 손절가를 저장할 컬럼명. 기본값: 'stop_loss_price'
    - entry_price_col (str): 진입가(매수가)를 저장할 컬럼명. 기본값: 'entry_price'

    반환값 (Return):
    - DataFrame: 'atr', 'entry_price', 'stop_loss_price' 컬럼이 추가된 데이터프레임.
    """

    # 1) ATR(평균진폭) 계산
    # - AverageTrueRange: 고가(high), 저가(low), 종가(close)를 사용해 변동성을 계산.
    # - window: 계산 기준이 되는 캔들 수
    atr_indicator = ta.volatility.AverageTrueRange(
        high=df['high'],
        low=df['low'],
        close=df['close'],
        window=atr_window,
        fillna=True  # 결측값 발생 방지
    )
    df['atr'] = atr_indicator.average_true_range()

    # 2) 매수 시점의 종가(entry_price) 기록
    # - 매수 신호(long_entry=True) 발생 시 종가(close)를 진입가로 설정.
    df[entry_price_col] = np.where(df['long_entry'], df['close'], np.nan)

    # 3) 진입가 유지 (forward fill)
    # - 진입 이후 익절/손절까지 동일한 진입가 유지.
    df[entry_price_col] = df[entry_price_col].ffill()

    # 4) 손절가(stop_loss_price) 계산
    # - 손절가 = 진입가 - (ATR × ATR 배수)
    df[sl_colname] = df[entry_price_col] - (df['atr'] * atr_multiplier)

    return df


def apply_take_profit_ratio(
    df: pd.DataFrame,
    profit_ratio: float = 0.05,
    tp_colname: str = 'take_profit_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    고정된 목표 수익률을 사용하여 익절가(take_profit_price)를 계산합니다.
    
    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 매수 신호와 진입가가 포함된 데이터프레임.
    - profit_ratio (float): 목표 수익률 (기본값: 0.05, 즉 5% 수익에 익절).
    - tp_colname (str): 계산된 익절가를 저장할 컬럼명.
    - entry_price_col (str): 진입가가 기록된 컬럼명.

    반환값 (Return):
    - DataFrame: 익절가(take_profit_price)가 추가된 데이터프레임.
    """

    # 익절가 계산: 진입가 × (1 + 목표 수익률)
    df[tp_colname] = df[entry_price_col] * (1 + profit_ratio)
    return df
---
# strategies/risk_management.py

import math # 수학 함수 사용을 위한 math 모듈

def calculate_position_size(
    account_balance: float,
    risk_per_trade: float,
    entry_price: float,
    stop_loss_price: float,
    fee_rate: float = 0.001
) -> float:
    """
    한 번의 매매에서 최대 손실을 제한하도록 포지션 크기를 계산하는 함수입니다.

    매개변수:
    ----------
    - account_balance (float): 계좌 잔고 (예: 10,000 USDT)
    - risk_per_trade (float): 허용 가능한 손실 비율 (예: 0.01 = 1%)
    - entry_price (float): 매수 가격
    - stop_loss_price (float): 손절 가격
    - fee_rate (float): 매수 수수료 비율 (기본값: 0.001 = 0.1%)

    반환값:
    ----------
    - float: 계산된 매수 가능 코인(또는 계약) 수량

    계산 절차:
    1. 코인 1개당 손실 금액 계산:
       `price_diff = abs(entry_price - stop_loss_price)`
    2. 최대 감당 가능 손실 금액 계산:
       `max_risk_amount = account_balance * risk_per_trade`
    3. 수수료 계산:
       `fee_amount = entry_price * fee_rate`
    4. 코인 1개당 총 손실:
       `per_unit_loss = price_diff + fee_amount`
    5. 허용 손실 금액 내에서 매수 가능한 최대 코인 수 계산:
       `position_size = max_risk_amount / per_unit_loss`
    """

    # 코인 1개당 손실 계산 (진입가와 손절가의 차이)
    price_diff = abs(entry_price - stop_loss_price)

    # 감당 가능한 최대 손실 금액
    max_risk_amount = account_balance * risk_per_trade

    # 매수 시 발생할 수수료
    fee_amount = entry_price * fee_rate

    # 코인 1개당 총 손실 계산
    per_unit_loss = price_diff + fee_amount

    # 최대 매수 가능 코인 수 계산
    if per_unit_loss > 0:
        position_size = max_risk_amount / per_unit_loss
    else:
        position_size = 0.0

    return position_size


def split_position_sizes(
    total_position_size: float,
    split_count: int = 3,
    scale_mode: str = 'equal'
) -> list:
    """
    전체 매수 물량을 여러 단계로 나누는 분할 매매 함수입니다.

    매개변수:
    ----------
    - total_position_size (float): 매수할 총 코인 수량
    - split_count (int): 매수 단계를 몇 번으로 나눌지 (기본값: 3)
    - scale_mode (str): 분할 비율 설정
        * 'equal': 균등 분할
        * 'pyramid_up': 뒤로 갈수록 매수 물량 증가
        * 'pyramid_down': 앞으로 갈수록 매수 물량 감소

    반환값:
    ----------
    - list: 각 단계별 매수 물량

    예시:
    ------
    >>> split_position_sizes(9, split_count=3, scale_mode='equal')
    [3.0, 3.0, 3.0]

    >>> split_position_sizes(9, split_count=3, scale_mode='pyramid_up')
    [1.5, 3.0, 4.5]
    """

    # 최소 1회 이상 매수를 나눌 수 있어야 함
    if split_count < 1:
        raise ValueError("split_count는 최소 1 이상이어야 합니다.")

    # 지원하지 않는 모드는 예외 처리
    if scale_mode not in ['equal', 'pyramid_up', 'pyramid_down']:
        raise ValueError("scale_mode는 'equal', 'pyramid_up', 'pyramid_down' 중 하나여야 합니다.")

    if scale_mode == 'equal':
        # 균등 분할
        split_size = total_position_size / split_count
        return [split_size] * split_count

    elif scale_mode == 'pyramid_up':
        # 피라미드 업: 뒤로 갈수록 더 많은 매수 비중
        ratio_sum = split_count * (split_count + 1) / 2  # 합계 계산 (1+2+3...)
        return [(i / ratio_sum) * total_position_size for i in range(1, split_count + 1)]

    elif scale_mode == 'pyramid_down':
        # 피라미드 다운: 앞으로 갈수록 더 많은 매수 비중
        ratio_sum = split_count * (split_count + 1) / 2
        return [(i / ratio_sum) * total_position_size for i in range(split_count, 0, -1)]
---
# backtesting/verify_signals.py

import matplotlib.pyplot as plt # 시각화를 위한 matplotlib
import pandas as pd

# 데이터베이스 및 시그널 계산 함수
from data_collection.postgres_ohlcv_handler import load_ohlcv_from_postgres
from strategies.breakout_signal import calculate_breakout_signals

def verify_breakout_signals(
    symbol: str,
    timeframe: str,
    table_name: str,
    window: int = 20,
    vol_factor: float = 1.5,
    confirm_bars: int = 2,
    use_high: bool = False,
    breakout_buffer: float = 0.0,
    plot_chart: bool = False
):
    """
    돌파 시그널 검증 및 시각화 함수.

    주요 기능:
    ----------
    1. PostgreSQL에서 (symbol, timeframe)에 해당하는 데이터를 로드.
    2. 돌파 시그널(전고점, 거래량, 확정 돌파)을 계산.
    3. 시그널이 의도대로 생성되었는지 수치적으로 검증.
    4. (선택적) 차트를 통해 시그널을 시각적으로 확인.

    매개변수:
    ----------
    - symbol (str): 자산 심볼 (예: "BTC/USDT")
    - timeframe (str): 데이터의 시간 간격 (예: "4h")
    - table_name (str): 데이터베이스 테이블명
    - window (int): 전고점 계산 기간
    - vol_factor (float): 거래량 필터 배수
    - confirm_bars (int): 확정 돌파를 위한 봉 개수
    - use_high (bool): True면 고가 기준 돌파, False면 종가 기준 돌파
    - breakout_buffer (float): 돌파 기준에 추가할 버퍼 비율
    - plot_chart (bool): True면 차트로 결과 시각화

    반환값:
    ----------
    None
    """

    print(f"\n[Verification] symbol={symbol}, timeframe={timeframe}, table={table_name}")

    # 1. 데이터 로드
    df = load_ohlcv_from_postgres(table_name=table_name)
    if df.empty:
        print(f"  -> No data loaded from table: {table_name}")
        return

    # 2. 돌파 시그널 계산
    df = calculate_breakout_signals(
        df=df,
        window=window,
        vol_factor=vol_factor,
        confirm_bars=confirm_bars,
        use_high=use_high,
        breakout_buffer=breakout_buffer
    )

    # -------------------------------
    # 3. 수치적 검증
    # -------------------------------

    # (A) breakout_signal 검증
    condition_breakout_true = (df['breakout_signal'] == True)
    error_rows = df[condition_breakout_true & 
                    (df['close'] <= df[f'highest_{window}'] * (1 + breakout_buffer))]
    if not error_rows.empty:
        print("[Warning] breakout_signal=True 이지만 실제로 돌파되지 않은 봉이 발견됨!")
        print(error_rows[['close', f'highest_{window}', 'breakout_signal']].head(10))
    else:
        print(" -> breakout_signal과 실제 가격 돌파가 일치합니다. (수치상 오차 없음)")

    # (B) volume_condition 검증
    cond_vol_true = (df['volume_condition'] == True)
    error_vol = df[cond_vol_true & (df['volume'] <= df[f'vol_ma_{window}'] * vol_factor)]
    if not error_vol.empty:
        print("[Warning] volume_condition=True 이지만 실제 거래량 조건이 만족되지 않은 봉 발견!")
        print(error_vol[['volume', f'vol_ma_{window}', 'volume_condition']].head(10))
    else:
        print(" -> volume_condition과 실제 거래량 조건이 일치합니다. (수치상 오차 없음)")

    # -------------------------------
    # 4. 차트 시각화 (선택 사항)
    # -------------------------------
    if plot_chart:
        # 최근 300개 봉만 시각화 (데이터가 많을 경우 복잡해짐)
        df_plot = df.tail(300)

        plt.figure(figsize=(12, 6))
        plt.plot(df_plot.index, df_plot['close'], label='Close', color='blue')

        # 전고점(highest_xx) 표시
        plt.plot(df_plot.index, df_plot[f'highest_{window}'], label=f"Highest({window})", linestyle='--', color='orange')

        # breakout_signal이 True인 지점에 빨간 마커
        breakout_points = df_plot[df_plot['breakout_signal'] == True]
        plt.scatter(breakout_points.index, breakout_points['close'], color='red', marker='^', label='Breakout Signal')

        # confirmed_breakout이 True인 지점에 녹색 마커
        confirmed_points = df_plot[df_plot['confirmed_breakout'] == True]
        plt.scatter(confirmed_points.index, confirmed_points['close'], color='green', marker='o', label='Confirmed Breakout')

        plt.title(f"{symbol} {timeframe} - Breakout Signal Verification")
        plt.xlabel("Time")
        plt.ylabel("Price")
        plt.legend()
        plt.show()
---
# backtesting/performance_metrics.py

# 데이터 분석과 수치 연산을 위한 라이브러리
import pandas as pd
import numpy as np

def calculate_monthly_performance(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    월별 손익(PnL), 매매 횟수, 승률을 계산하는 함수.

    주요 기능:
    ----------
    - 월(YYYY-MM) 단위로 매매 데이터를 그룹화.
    - 각 월별 총 손익, 매매 횟수, 승률을 계산.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).

    반환값:
    ----------
    - DataFrame: 월별 성과를 요약한 데이터프레임.
    """
    # 연월(YYYY-MM) 기준으로 그룹화
    trades_df['year_month'] = trades_df['exit_time'].dt.to_period('M')

    # 그룹별 성과 계산
    grouped = trades_df.groupby('year_month')
    results = []

    for ym, grp in grouped:
        total_pnl = grp['pnl'].sum()  # 총 손익
        num_trades = len(grp)        # 매매 횟수
        win_trades = (grp['pnl'] > 0).sum()  # 이긴 매매 수
        win_rate = win_trades / num_trades * 100.0 if num_trades > 0 else 0.0  # 승률 계산

        results.append({
            'year_month': str(ym),
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })

    return pd.DataFrame(results)


def calculate_yearly_performance(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    연도별 손익(PnL), 매매 횟수, 승률을 계산하는 함수.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).

    반환값:
    ----------
    - DataFrame: 연도별 성과를 요약한 데이터프레임.
    """
    # 연도별 그룹화
    trades_df['year'] = trades_df['exit_time'].dt.year
    grouped = trades_df.groupby('year')

    results = []
    for y, grp in grouped:
        total_pnl = grp['pnl'].sum()
        num_trades = len(grp)
        win_trades = (grp['pnl'] > 0).sum()
        win_rate = win_trades / num_trades * 100.0 if num_trades > 0 else 0.0

        results.append({
            'year': y,
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })

    return pd.DataFrame(results)


def calculate_mdd(trades_df: pd.DataFrame, initial_balance: float) -> float:
    """
    최대낙폭(MDD)을 계산하는 함수.

    주요 기능:
    ----------
    - 매매 기록을 순서대로 처리하여 최대낙폭(MDD)을 계산.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).
    - initial_balance (float): 초기 계좌 잔고.

    반환값:
    ----------
    - float: 최대낙폭(MDD) 값(음수, % 단위).
    """
    # 시간 순 정렬
    trades_df = trades_df.sort_values(by='exit_time')

    # 잔고 추적
    equity_list = []
    current_balance = initial_balance

    for _, row in trades_df.iterrows():
        current_balance += row['pnl']
        equity_list.append(current_balance)

    # MDD 계산
    equity_arr = np.array(equity_list)
    peak_arr = np.maximum.accumulate(equity_arr)  # 최고점 추적
    drawdown_arr = (equity_arr - peak_arr) / peak_arr  # 낙폭 계산
    mdd = drawdown_arr.min() * 100.0  # %로 변환
    return mdd


def print_performance_report(trades_df: pd.DataFrame, initial_balance: float) -> None:
    """
    전체 성과를 요약 출력하는 함수.

    주요 기능:
    ----------
    - 월별, 연도별 성과와 MDD(최대낙폭), ROI, 승률 등을 출력.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
    - initial_balance (float): 초기 계좌 잔고.

    반환값:
    ----------
    - None
    """
    if trades_df.empty:
        print("No trades to report.")
        return

    # 성과 계산
    monthly_df = calculate_monthly_performance(trades_df)
    yearly_df = calculate_yearly_performance(trades_df)
    total_pnl = trades_df['pnl'].sum()
    final_balance = initial_balance + total_pnl
    mdd = calculate_mdd(trades_df, initial_balance=initial_balance)

    # 출력
    print("=== (A) 월별 성과 ===")
    print(monthly_df)

    print("\n=== (B) 연도별 성과 ===")
    print(yearly_df)

    print("\n=== (C) 전체 성과 ===")
    print(f"  - 초기 잔고       : {initial_balance:.2f}")
    print(f"  - 최종 잔고       : {final_balance:.2f}")
    print(f"  - 총 손익         : {total_pnl:.2f}")
    print(f"  - ROI(%)          : {(final_balance - initial_balance) / initial_balance * 100:.2f}%")
    print(f"  - 최대낙폭(MDD)   : {mdd:.2f}%")

    # 매매 통계
    num_trades = len(trades_df)
    wins = (trades_df['pnl'] > 0).sum()
    win_rate = wins / num_trades * 100.0 if num_trades > 0 else 0.0
    print(f"  - 총 매매 횟수    : {num_trades}")
    print(f"  - 승률(%)         : {win_rate:.2f}%")
---
# backtesting/backtest_simple.py

import pandas as pd  # 데이터 프레임 처리
import numpy as np  # 수학 연산

from data_collection.postgres_ohlcv_handler import load_ohlcv_from_postgres  # 데이터 로드
from strategies.breakout_signal import calculate_breakout_signals  # 돌파 신호 계산
from strategies.technical_indicators import (  # 기술적 지표 계산
    apply_sma,  # 단순 이동 평균
    apply_macd,  # MACD (이동 평균 수렴·발산 지표)
    apply_rsi,  # RSI (상대 강도 지수)
    apply_bollinger  # 볼린저 밴드
)
from strategies.stop_loss_take_profit import (  # 손절 및 익절 계산
    apply_stop_loss_atr,  # ATR 기반 손절 설정
    apply_take_profit_ratio  # 고정 비율 익절 설정
)
from strategies.risk_management import (  # 리스크 관리
    calculate_position_size,  # 포지션 크기 계산
    split_position_sizes  # 포지션 분할 계산
)
from backtesting.performance_metrics import print_performance_report  # 성과 보고서 출력


def run_simple_backtest(
    symbol="BTC/USDT",  # 거래 종목 (기본값: 비트코인/테더)
    short_timeframe="4h",  # 단기 봉 간격 (4시간)
    long_timeframe="1d",  # 장기 봉 간격 (1일)
    window=20,  # 돌파 신호 기간
    volume_factor=1.5,  # 거래량 기준 배수
    confirm_bars=2,  # 돌파 신호 확인을 위한 봉 수
    breakout_buffer=0.0,  # 돌파 여유 범위
    atr_window=14,  # ATR 계산 기간
    atr_multiplier=2.0,  # ATR 기반 손절 배수
    profit_ratio=0.05,  # 고정 비율 익절 기준
    account_size=10_000.0,  # 초기 계좌 잔액 (기본값: 10,000 USDT)
    risk_per_trade=0.01,  # 거래당 리스크 비율
    fee_rate=0.001,  # 거래 수수료 비율
    split_count=3,  # 분할 매매 개수
    split_scale_mode='equal',  # 분할 매매 크기 분배 방식 (균등 분배)
    start_date: str = None,  # 데이터 로드 시작 날짜
    end_date: str = None  # 데이터 로드 종료 날짜
):
    """
    단순 백테스트 실행 함수 (분할매매 포함)
    1. 데이터를 로드하고 전략을 적용합니다.
    2. 돌파 신호, 기술적 지표, 손절/익절 조건을 계산합니다.
    3. 분할 매매를 포함한 백테스트를 실행합니다.
    Returns:
        pd.DataFrame: 매매 기록 데이터프레임
    """

    # -------------------------------
    # 1) 데이터 로드
    # -------------------------------
    short_table = f"ohlcv_{symbol.replace('/', '').lower()}_{short_timeframe}"  # 단기 데이터 테이블 이름
    long_table = f"ohlcv_{symbol.replace('/', '').lower()}_{long_timeframe}"  # 장기 데이터 테이블 이름

    # 단기 및 장기 데이터를 PostgreSQL에서 로드
    df_short = load_ohlcv_from_postgres(
        table_name=short_table,
        start_date=start_date,
        end_date=end_date
    )

    df_long = load_ohlcv_from_postgres(
        table_name=long_table,
        start_date=start_date,
        end_date=end_date
    )

    # 데이터가 비어 있는 경우 에러 메시지 출력 및 종료
    if df_short.empty:
        print(f"[ERROR] 단기 데이터가 없습니다: {short_table}")
        return None
    if df_long.empty:
        print(f"[ERROR] 장기 데이터가 없습니다: {long_table}")
        return None

    # 데이터 정렬
    df_short.sort_index(inplace=True)
    df_long.sort_index(inplace=True)

    print(f"[INFO] 단기 데이터 로드 완료: {df_short.shape[0]} 행")
    print(f"[INFO] 장기 데이터 로드 완료: {df_long.shape[0]} 행\n")

    # -------------------------------
    # 2) 돌파 신호 계산
    # -------------------------------
    # 단기 봉 데이터에서 돌파 신호 계산
    df_short = calculate_breakout_signals(
        df=df_short,
        window=window,
        vol_factor=volume_factor,
        confirm_bars=confirm_bars,
        use_high=False,
        breakout_buffer=breakout_buffer
    )

    print("[단기 봉] 신호 통계:")
    print(f"  -> 돌파 신호: {df_short['breakout_signal'].sum()} 개")
    print(f"  -> 확인된 돌파: {df_short['confirmed_breakout'].sum()} 개\n")

    # -------------------------------
    # 3) 보조 지표 계산
    # -------------------------------
    # 장기 봉 데이터에서 SMA, MACD, RSI, 볼린저 밴드 계산
    df_long = apply_sma(df_long, price_col='close', window=200, colname='sma200')
    df_long = apply_macd(df_long, price_col='close', window_slow=26, window_fast=12, window_sign=9, prefix='macd_')
    df_long = apply_rsi(df_long, price_col='close', window=14, colname='rsi14')
    df_long = apply_bollinger(df_long, price_col='close', window=20, window_dev=2.0, prefix='bb_')

    # 롱 포지션 조건 설정
    cond_sma = (df_long['close'] >= df_long['sma200'])  # 200일 SMA 이상
    cond_macd = (df_long['macd_diff'] > 0)  # MACD 양수
    cond_rsi = (df_long['rsi14'] < 70)  # RSI 과매수 미만
    cond_bb = (df_long['close'] < df_long['bb_hband'])  # 볼린저 밴드 상단 미만

    df_long['long_ok'] = cond_sma & cond_macd & cond_rsi & cond_bb  # 모든 조건 충족 시 롱 가능
    print(f"  -> 장기 long_ok True: {df_long['long_ok'].sum()} / {len(df_long)}")

    # -------------------------------
    # 4) 손절 및 익절 계산
    # -------------------------------
    df_short['long_entry'] = df_short['confirmed_breakout'] & df_short['volume_condition']

    # 손절 가격 계산 (ATR 기반)
    df_short = apply_stop_loss_atr(
        df=df_short,
        atr_window=atr_window,
        atr_multiplier=atr_multiplier,
        sl_colname='stop_loss_price',
        entry_price_col='entry_price'
    )
    
    # 익절 가격 계산 (고정 비율 기반)
    df_short = apply_take_profit_ratio(
        df=df_short,
        profit_ratio=profit_ratio,
        tp_colname='take_profit_price',
        entry_price_col='entry_price'
    )

    # -------------------------------
    # 5) 백테스트 수행 (분할매매 적용)
    # -------------------------------
    trades = []  # 매매 기록
    in_position = False  # 포지션 보유 여부

    for i in range(len(df_short)):  # 단기 봉 데이터 순회
        row_s = df_short.iloc[i]
        current_time = row_s.name  # 현재 시간

        # (A) 포지션 진입 조건 확인
        if not in_position and row_s['long_entry']:
            # 장기 봉 조건 검토
            df_long_sub = df_long.loc[:current_time]
            if df_long_sub.empty:
                continue

            row_l = df_long_sub.iloc[-1]
            if row_l['long_ok']:
                # 포지션 크기 및 분할 매매 크기 계산
                entry_price = row_s['entry_price']
                stop_loss   = row_s['stop_loss_price']
                total_size  = calculate_position_size(
                    account_balance=account_size,
                    risk_per_trade=risk_per_trade,
                    entry_price=entry_price,
                    stop_loss_price=stop_loss,
                    fee_rate=fee_rate
                )

                if total_size > 0:
                    partial_sizes = split_position_sizes(
                        total_position_size=total_size,
                        split_count=split_count,
                        scale_mode=split_scale_mode
                    )

                    # 분할 매매 기록 추가
                    for ps in partial_sizes:
                        trades.append({
                            'entry_time': current_time,
                            'entry_price': entry_price,
                            'size': ps,
                            'stop_loss': stop_loss,
                            'take_profit': row_s['take_profit_price'],
                            'exit_time': None,
                            'exit_price': None,
                            'pnl': None,
                            'exit_reason': None
                        })
                    in_position = True

        # (B) 포지션 청산 조건 확인 (손절/익절)
        if in_position:
            open_trades = [t for t in trades if t['exit_time'] is None]
            if not open_trades:
                in_position = False
                continue

            last_trade = open_trades[-1]
            current_close = row_s['close']

            # 손절 청산
            if current_close <= last_trade['stop_loss']:
                for t in open_trades:
                    t['exit_time'] = current_time
                    t['exit_price'] = current_close
                    t['pnl'] = (current_close - t['entry_price']) * t['size']
                    t['exit_reason'] = 'stop_loss'
                in_position = False

            # 익절 청산
            elif current_close >= last_trade['take_profit']:
                for t in open_trades:
                    t['exit_time'] = current_time
                    t['exit_price'] = current_close
                    t['pnl'] = (current_close - t['entry_price']) * t['size']
                    t['exit_reason'] = 'take_profit'
                in_position = False

    # -------------------------------
    # 6) 결과 출력
    # -------------------------------
    trades_df = pd.DataFrame(trades)
    if trades_df.empty:
        print("\n[INFO] 매매가 발생하지 않았습니다.")
        return None

    # 최종 성과 계산 및 출력
    total_pnl = trades_df['pnl'].sum()
    final_balance = account_size + total_pnl
    roi_percent = (final_balance - account_size) / account_size * 100.0

    print("\n=== 백테스트 결과 ===")
    print(f"총 거래 수(분할 포함): {len(trades_df)}")
    print(f"총 손익: {total_pnl:.2f} USDT")
    print(f"최종 계좌 잔액: {final_balance:.2f} USDT")
    print(f"수익률: {roi_percent:.2f}%")

    # 필요 시 상세 보고서
    # print_performance_report(trades_df, initial_balance=account_size)

    return trades_df
---
# backtesting/param_tuning.py

import itertools  # 여러 파라미터 조합을 생성하기 위해 사용됩니다.
import pandas as pd  # 데이터 저장 및 처리에 유용한 라이브러리입니다.

from backtesting.backtest_simple import run_simple_backtest  # 단순 백테스트 실행 함수
from backtesting.performance_metrics import calculate_mdd  # 최대 낙폭(MDD)을 계산하는 함수

def param_sweep_test(
    symbol: str = "BTC/USDT",  # 거래 종목 (기본값: 비트코인/테더)
    short_timeframe: str = "4h",  # 단기 봉의 주기 (기본값: 4시간)
    long_timeframe: str = "1d",  # 장기 봉의 주기 (기본값: 1일)
    account_size: float = 10_000.0,  # 초기 계좌 잔액 (기본값: 10,000 USDT)
    start_date: str = None,  # 백테스트 시작 날짜 (예: '2021-01-01')
    end_date: str = None  # 백테스트 종료 날짜 (예: '2021-12-31')
) -> pd.DataFrame:
    """
    다양한 파라미터 조합으로 주어진 기간 동안 백테스트를 실행하고 결과를 반환합니다.

    Parameters:
    ----------
    symbol : str
        거래할 종목 이름 (기본값: "BTC/USDT").
    short_timeframe : str
        단기 봉 주기 (기본값: "4h").
    long_timeframe : str
        장기 봉 주기 (기본값: "1d").
    account_size : float
        초기 계좌 잔액 (기본값: 10,000.0 USDT).
    start_date : str
        백테스트 시작 날짜 (예: "2021-01-01").
    end_date : str
        백테스트 종료 날짜 (예: "2021-12-31").

    Returns:
    -------
    pd.DataFrame
        각 파라미터 조합에 대한 성과 지표를 담은 DataFrame.
    """

    # (A) 백테스트에서 사용할 파라미터의 범위를 설정합니다.
    window_list = [10, 20, 30]  # 돌파 신호를 위한 기간
    atr_multiplier_list = [1.5, 2.0]  # 손절 기준이 되는 ATR(평균 진폭)의 배수
    profit_ratio_list = [0.03, 0.05]  # 고정된 익절 비율

    # 결과를 저장할 리스트를 초기화합니다.
    results = []

    # (B) itertools.product를 사용해 모든 파라미터 조합을 생성하고 순회합니다.
    for window, atr_mult, pr in itertools.product(window_list, atr_multiplier_list, profit_ratio_list):
        print(f"\n[Param Test] window={window}, atr_multiplier={atr_mult}, profit_ratio={pr}")

        # 각 파라미터 조합으로 백테스트를 실행합니다.
        trades_df = run_simple_backtest(
            symbol=symbol,  # 거래 종목
            short_timeframe=short_timeframe,  # 단기 봉 주기
            long_timeframe=long_timeframe,  # 장기 봉 주기
            window=window,  # 돌파 신호를 위한 기간
            atr_multiplier=atr_mult,  # 손절 기준 ATR 배수
            profit_ratio=pr,  # 고정 익절 비율
            account_size=account_size,  # 초기 계좌 잔액
            start_date=start_date,  # 시작 날짜
            end_date=end_date  # 종료 날짜
        )

        # 거래 데이터가 없거나 비어 있으면 다음 조합으로 넘어갑니다.
        if trades_df is None or trades_df.empty:
            continue

        # (C) 각 조합의 성과 지표를 계산합니다.
        initial_balance = account_size  # 초기 잔액
        total_pnl = trades_df['pnl'].sum()  # 총 수익 (profit and loss)
        final_balance = initial_balance + total_pnl  # 최종 계좌 잔액
        roi_percent = (final_balance - initial_balance) / initial_balance * 100.0  # 총 수익률(ROI)
        mdd_percent = calculate_mdd(trades_df, initial_balance=initial_balance)  # 최대 낙폭(MDD)

        num_trades = len(trades_df)  # 총 거래 횟수
        wins = (trades_df['pnl'] > 0).sum()  # 수익이 난 거래의 개수
        win_rate = (wins / num_trades * 100.0) if num_trades > 0 else 0.0  # 승률(%)

        # (D) 계산된 결과를 리스트에 추가합니다.
        results.append({
            'window': window,  # 돌파 신호를 위한 기간
            'atr_multiplier': atr_mult,  # ATR 배수
            'profit_ratio': pr,  # 고정 익절 비율
            'num_trades': num_trades,  # 총 거래 횟수
            'win_rate(%)': round(win_rate, 2),  # 승률 (%)
            'final_balance': round(final_balance, 2),  # 최종 잔액
            'ROI(%)': round(roi_percent, 2),  # 총 수익률 (%)
            'MDD(%)': round(mdd_percent, 2),  # 최대 낙폭 (%)
        })

    # (E) 모든 결과를 DataFrame으로 변환하여 반환합니다.
    results_df = pd.DataFrame(results)
    return results_df
---
# backtesting/overfit_validation.py

import pandas as pd  # 데이터 처리와 날짜 계산에 사용
import numpy as np  # 수학 연산에 사용
from datetime import timedelta  # 날짜 간격 계산에 사용

# 백테스팅 관련 함수 가져오기
from backtesting.param_tuning import param_sweep_test  # 최적의 파라미터를 찾기 위한 함수
from backtesting.backtest_simple import run_simple_backtest  # 간단한 백테스트 실행 함수

def train_test_validation(
    symbol: str = "BTC/USDT",  # 거래 대상 (예: 비트코인/테더)
    short_timeframe: str = "4h",  # 단기 봉 간격 (기본값: 4시간)
    long_timeframe: str = "1d",  # 장기 봉 간격 (기본값: 1일)
    train_start: str = "2021-01-01 00:00:00",  # 훈련 시작 날짜
    train_end: str = "2021-06-30 23:59:59",  # 훈련 종료 날짜
    test_start: str = "2021-07-01 00:00:00",  # 테스트 시작 날짜
    test_end: str = "2021-12-31 23:59:59",  # 테스트 종료 날짜
    account_size: float = 10_000.0  # 초기 계좌 잔액 (기본값: 10,000 USDT)
) -> dict:
    """
    주어진 훈련 기간에서 최적의 거래 전략 파라미터를 찾아내고,
    이를 테스트 기간에 적용하여 검증합니다.
    
    Returns:
        dict: 훈련 및 테스트 결과
            - best_params: 최적의 파라미터 (예: 이동 평균, 손익비 등)
            - train_performance: 훈련 구간의 성과 데이터
            - test_trades: 테스트 구간의 거래 데이터
    """

    print("\n=== [Train/Test Validation] ===")
    print(f"Train Period: {train_start} ~ {train_end}")  # 훈련 구간 출력
    print(f"Test Period : {test_start} ~ {test_end}")    # 테스트 구간 출력

    # (A) 훈련 단계: 다양한 파라미터 조합으로 테스트를 수행
    train_results_df = param_sweep_test(
        symbol=symbol,
        short_timeframe=short_timeframe,
        long_timeframe=long_timeframe,
        account_size=account_size,
        start_date=train_start,
        end_date=train_end
    )

    # 훈련 결과가 비어 있으면 중단
    if train_results_df.empty:
        print("No train results found.")  # 훈련 결과 없음
        return {}

    # (B) 훈련 결과 정렬: ROI(%)가 가장 높은 파라미터 선택
    best_row = train_results_df.sort_values(by='ROI(%)', ascending=False).iloc[0]
    best_params = {
        'window': best_row['window'],  # 신호 생성 기간
        'atr_multiplier': best_row['atr_multiplier'],  # 변동성 계산 배수
        'profit_ratio': best_row['profit_ratio']  # 목표 수익 비율
    }
    print("\n[Train Result] Best Params:", best_params)  # 최적 파라미터 출력

    # (C) 테스트 단계: 최적 파라미터로 거래 전략 검증
    test_trades = run_simple_backtest(
        symbol=symbol,
        short_timeframe=short_timeframe,
        long_timeframe=long_timeframe,
        window=int(best_params['window']),
        atr_multiplier=float(best_params['atr_multiplier']),
        profit_ratio=float(best_params['profit_ratio']),
        account_size=account_size,
        start_date=test_start,
        end_date=test_end
    )

    # 테스트 결과 출력
    print("=== [Test Result] ===")
    if test_trades is None or test_trades.empty:
        print("No trades in test period.")  # 거래 없음
    else:
        print(f"Test Trades: {len(test_trades)}")  # 거래 수 출력

    # 훈련 및 테스트 결과 반환
    return {
        'best_params': best_params,  # 최적 파라미터
        'train_performance': train_results_df,  # 훈련 구간 결과
        'test_trades': test_trades  # 테스트 구간 결과
    }


def walk_forward_analysis(
    symbol: str = "BTC/USDT",  # 거래 대상
    short_timeframe: str = "4h",  # 단기 봉 간격
    long_timeframe: str = "1d",  # 장기 봉 간격
    overall_start: str = "2021-01-01 00:00:00",  # 전체 분석 시작 날짜
    overall_end: str = "2022-12-31 23:59:59",  # 전체 분석 종료 날짜
    n_splits: int = 3,  # 구간 나누기 개수
    account_size: float = 10_000.0,  # 초기 계좌 잔액
    train_ratio: float = 0.5  # 각 구간의 훈련/테스트 비율
) -> list:
    """
    전체 분석 기간을 여러 구간으로 나누어 순차적으로 훈련 및 테스트를 진행합니다.
    각 구간마다:
      1. 훈련 구간에서 최적 파라미터 선정
      2. 테스트 구간에서 성능 검증
      3. 결과 저장
    
    Returns:
        list: 구간별 결과 리스트
    """
    print("\n=== [Walk-Forward Analysis] ===")
    print(f"Period: {overall_start} ~ {overall_end}")  # 전체 분석 기간 출력
    print(f"Splits: {n_splits}, Train Ratio: {train_ratio}")  # 구간 및 훈련 비율 출력

    # 전체 기간의 날짜 계산
    start_dt = pd.to_datetime(overall_start)
    end_dt = pd.to_datetime(overall_end)
    total_days = (end_dt - start_dt).days

    # 각 구간의 기간 계산
    split_days = total_days // n_splits
    results_list = []  # 결과 저장용 리스트

    for i in range(n_splits):
        # 각 구간의 시작 및 종료 날짜 계산
        split_start_dt = start_dt + pd.to_timedelta(split_days * i, unit='D')
        split_end_dt = start_dt + pd.to_timedelta(split_days * (i + 1), unit='D')
        if i == n_splits - 1:  # 마지막 구간의 종료 날짜 처리
            split_end_dt = end_dt

        # 훈련/테스트 기간 설정
        days_in_this_split = (split_end_dt - split_start_dt).days
        train_days = int(days_in_this_split * train_ratio)

        train_start = split_start_dt
        train_end = train_start + pd.to_timedelta(train_days, unit='D')

        test_start = train_end + pd.to_timedelta(1, unit='D')
        test_end = split_end_dt

        # 날짜를 문자열로 변환
        t_start_str = train_start.strftime("%Y-%m-%d %H:%M:%S")
        t_end_str = train_end.strftime("%Y-%m-%d %H:%M:%S")
        v_start_str = test_start.strftime("%Y-%m-%d %H:%M:%S")
        v_end_str = test_end.strftime("%Y-%m-%d %H:%M:%S")

        print(f"\n--- Split {i + 1}/{n_splits} ---")
        print(f"Train: {t_start_str} ~ {t_end_str}")  # 훈련 기간 출력
        print(f"Test : {v_start_str} ~ {v_end_str}")  # 테스트 기간 출력

        # 훈련 및 테스트 실행
        tt_result = train_test_validation(
            symbol=symbol,
            short_timeframe=short_timeframe,
            long_timeframe=long_timeframe,
            train_start=t_start_str,
            train_end=t_end_str,
            test_start=v_start_str,
            test_end=v_end_str,
            account_size=account_size
        )

        # 결과 저장
        if not tt_result:
            print("Empty result in this split.")  # 결과 없음 처리
            continue

        results_list.append({
            'split_index': i + 1,
            'train_start': t_start_str,
            'train_end': t_end_str,
            'test_start': v_start_str,
            'test_end': v_end_str,
            'best_params': tt_result.get('best_params'),
            'train_performance': tt_result.get('train_performance'),
            'test_trades': tt_result.get('test_trades')
        })

    return results_list  # 구간별 결과 반환
---