[프로젝트 코드]
# config/db_config.py
# 이 파일은 데이터베이스에 연결하기 위한 설정 정보를 간단히 정리해둔 곳입니다.
# 아래의 'DATABASE' 딕셔너리는 PostgreSQL 접속에 필요한 정보를 담고 있습니다.

DATABASE = {
    'user': 'postgres',        # DB에 접속할 계정 이름
    'password': '1234',        # 해당 계정의 비밀번호
    'host': 'localhost',       # DB 서버 주소(현재 PC라면 localhost)
    'port': 5432,              # PostgreSQL 기본 포트번호
    'dbname': 'my_trading_db'  # 실제 사용할 데이터베이스 이름
}

---

# data_collection/db_ohlcv_manager.py

from sqlalchemy import create_engine
import psycopg2
import pandas as pd
from typing import Optional
from config.db_config import DATABASE

def insert_ohlcv_records(
    df: pd.DataFrame,
    table_name: str = 'ohlcv_data',
    conflict_action: str = "DO NOTHING",  # 중복키 충돌 시 액션
    db_config: Optional[dict] = None
) -> None:
    """
    OHLCV DataFrame을 PostgreSQL에 저장합니다.
    conflict_action: 중복키 충돌 시 수행할 액션 (기본 'DO NOTHING')
    db_config: DB 접속 정보를 담은 dict (없으면 DATABASE 사용)
    """
    if db_config is None:
        db_config = DATABASE

    conn = psycopg2.connect(
        user=db_config['user'],
        password=db_config['password'],
        host=db_config['host'],
        port=db_config['port'],
        dbname=db_config['dbname']
    )
    cur = conn.cursor()

    create_table_query = f"""
    CREATE TABLE IF NOT EXISTS {table_name} (
        timestamp TIMESTAMP NOT NULL,
        open DOUBLE PRECISION,
        high DOUBLE PRECISION,
        low DOUBLE PRECISION,
        close DOUBLE PRECISION,
        volume DOUBLE PRECISION,
        PRIMARY KEY (timestamp)
    );
    """
    cur.execute(create_table_query)
    conn.commit()

    for index, row in df.iterrows():
        insert_query = f"""
        INSERT INTO {table_name} (timestamp, open, high, low, close, volume)
        VALUES (%s, %s, %s, %s, %s, %s)
        ON CONFLICT (timestamp) 
        {conflict_action};
        """
        cur.execute(insert_query, (
            index.to_pydatetime(),
            float(row['open']),
            float(row['high']),
            float(row['low']),
            float(row['close']),
            float(row['volume'])
        ))
    conn.commit()

    cur.close()
    conn.close()

def fetch_ohlcv_records(
    table_name: str = 'ohlcv_data',
    limit: Optional[int] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    db_config: Optional[dict] = None
) -> pd.DataFrame:
    """
    PostgreSQL에서 OHLCV 데이터를 읽어옵니다.
    """
    if db_config is None:
        db_config = DATABASE

    engine = create_engine(
        f"postgresql://{db_config['user']}:{db_config['password']}@"
        f"{db_config['host']}:{db_config['port']}/{db_config['dbname']}"
    )

    query = f"SELECT * FROM {table_name}"
    where_clauses = []
    if start_date:
        where_clauses.append(f"timestamp >= '{start_date}'")
    if end_date:
        where_clauses.append(f"timestamp <= '{end_date}'")
    if where_clauses:
        query += " WHERE " + " AND ".join(where_clauses)
    query += " ORDER BY timestamp"
    if limit:
        query += f" LIMIT {limit}"

    df = pd.read_sql(query, engine, parse_dates=['timestamp'])
    df.set_index('timestamp', inplace=True)
    return df

def delete_ohlcv_tables_by_symbol(
    symbol: str,
    schema: str = 'public',
    db_config: Optional[dict] = None
) -> None:
    """
    지정 심볼과 매칭되는 모든 테이블을 삭제합니다.
    schema: 사용할 스키마 (기본 'public')
    """
    if db_config is None:
        db_config = DATABASE

    symbol_for_table = symbol.replace("/", "").lower()

    conn = psycopg2.connect(
        user=db_config['user'],
        password=db_config['password'],
        host=db_config['host'],
        port=db_config['port'],
        dbname=db_config['dbname']
    )
    cur = conn.cursor()

    find_tables_query = f"""
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = '{schema}'
          AND table_name LIKE 'ohlcv_{symbol_for_table}_%';
    """
    cur.execute(find_tables_query)
    tables = cur.fetchall()

    for (table_name,) in tables:
        drop_query = f"DROP TABLE IF EXISTS {table_name} CASCADE;"
        print(f"[*] Dropping table: {table_name}")
        cur.execute(drop_query)

    conn.commit()
    cur.close()
    conn.close()

---

# data_collection/ohlcv_data_fetcher.py

import ccxt
import pandas as pd
import time
from datetime import datetime

def fetch_historical_ohlcv_data(
    symbol: str,
    timeframe: str = '4h',
    start_date: str = '2021-01-01 00:00:00',
    limit_per_request: int = 1000,
    pause_sec: float = 1.0,
    exchange_id: str = 'binance',
    time_offset_ms: int = 1
) -> pd.DataFrame:
    """
    거래소에서 과거 가격 데이터를 여러 번 나눠 요청하여 대량으로 수집합니다.
    추가 매개변수:
      - exchange_id: 사용할 거래소 ID (기본 'binance')
      - time_offset_ms: 마지막 데이터 이후 요청 시 오프셋 (기본 1ms)
    """
    exchange = getattr(ccxt, exchange_id)()
    since_ms = exchange.parse8601(start_date)
    all_ohlcv = []

    while True:
        ohlcv = exchange.fetch_ohlcv(
            symbol=symbol,
            timeframe=timeframe,
            since=since_ms,
            limit=limit_per_request
        )

        if not ohlcv:
            break

        all_ohlcv += ohlcv
        last_ts = ohlcv[-1][0]
        since_ms = last_ts + time_offset_ms  # 시간 오프셋 적용

        time.sleep(pause_sec)

        if len(ohlcv) < limit_per_request:
            break

    df = pd.DataFrame(all_ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)
    df = df[~df.index.duplicated()]
    df.dropna(inplace=True)

    return df

def fetch_latest_ohlcv_data(
    symbol: str,
    timeframe: str = '4h',
    limit: int = 500,
    exchange_id: str = 'binance'
) -> pd.DataFrame:
    """
    거래소에서 가장 최근 시세 데이터를 가져옵니다.
    추가 매개변수:
      - exchange_id: 사용할 거래소 ID (기본 'binance')
    """
    exchange = getattr(ccxt, exchange_id)()
    
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)
    df = df[~df.index.duplicated()]
    df.dropna(inplace=True)

    return df

---

# data_collection/ohlcv_pipeline.py

import time
from typing import List, Optional

from data_collection.ohlcv_data_fetcher import (
    fetch_historical_ohlcv_data,
    fetch_latest_ohlcv_data
)
from data_collection.db_ohlcv_manager import insert_ohlcv_records

def collect_and_store_ohlcv_data(
    symbols: List[str],
    timeframes: List[str],
    use_historical: bool = True,
    start_date: Optional[str] = '2018-01-01 00:00:00',
    limit_per_request: int = 1000,
    latest_limit: int = 500,
    pause_sec: float = 1.0,
    table_name_format: str = "ohlcv_{symbol}_{timeframe}",
    exchange_id: str = 'binance',
    time_offset_ms: int = 1
) -> None:
    """
    지정한 심볼과 타임프레임에 대해 데이터를 수집하여 PostgreSQL에 저장합니다.
    table_name_format: 예) "ohlcv_{symbol}_{timeframe}" 형식
    """
    for symbol in symbols:
        for tf in timeframes:
            print(f"\n[*] Fetching {symbol} - {tf} data...")

            if use_historical:
                if not start_date:
                    raise ValueError("start_date는 과거 데이터 수집 시 반드시 필요합니다.")
                df = fetch_historical_ohlcv_data(
                    symbol=symbol,
                    timeframe=tf,
                    start_date=start_date,
                    limit_per_request=limit_per_request,
                    pause_sec=pause_sec,
                    exchange_id=exchange_id,
                    time_offset_ms=time_offset_ms
                )
            else:
                df = fetch_latest_ohlcv_data(
                    symbol=symbol,
                    timeframe=tf,
                    limit=latest_limit,
                    exchange_id=exchange_id
                )

            # 테이블 이름 생성 (table_name_format 활용)
            table_name = table_name_format.format(symbol=symbol.replace('/', '').lower(), timeframe=tf)
            print(f"    -> Total Rows Fetched: {len(df)}")

            insert_ohlcv_records(df, table_name=table_name)
            print(f"    -> Saved to table: {table_name}")

            time.sleep(pause_sec)

---

# init_db.py

import sys
from data_collection.ohlcv_pipeline import collect_and_store_ohlcv_data

def main():
    # 예시: 바이낸스에서 가장 시가총액이 큰 코인 3개
    symbols = ["BTC/USDT", "ETH/USDT", "BNB/USDT"]
    
    # 사용하고자 하는 타임프레임 리스트
    timeframes = ["1d", "4h", "1h", "15m"]
    
    # 2016년부터 최신까지 데이터를 수집 (실제로는 거래소가 지원하는 가장 과거 데이터부터)
    start_date = "2016-01-01 00:00:00"
    
    # 과거 데이터를 모두 받아와서 PostgreSQL에 저장
    collect_and_store_ohlcv_data(
        symbols=symbols,
        timeframes=timeframes,
        use_historical=True,
        start_date=start_date,
        limit_per_request=1000,
        latest_limit=500,  # 최신 데이터 수집 시에만 사용됨
        pause_sec=1.0
    )

    print("\n[완료] 초기 DB 세팅이 끝났습니다.")
    print("지정한 코인들(BTC/USDT, ETH/USDT, BNB/USDT)에 대해")
    print("15m, 1h, 4h, 1d 봉 데이터를 모두 PostgreSQL에 저장했습니다.")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"[오류 발생] {e}", file=sys.stderr)
        sys.exit(1)

---

# trading/indicators.py
import pandas as pd
from ta.trend import SMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volatility import BollingerBands

def compute_sma(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 20,
    fillna: bool = False,
    output_col: str = 'sma'
) -> pd.DataFrame:
    sma = SMAIndicator(
        close=data[price_column],
        window=period,
        fillna=fillna
    )
    data[output_col] = sma.sma_indicator()
    return data

def compute_macd(
    data: pd.DataFrame,
    price_column: str = 'close',
    slow_period: int = 26,
    fast_period: int = 12,
    signal_period: int = 9,
    fillna: bool = False,
    prefix: str = 'macd_'
) -> pd.DataFrame:
    macd = MACD(
        close=data[price_column],
        window_slow=slow_period,
        window_fast=fast_period,
        window_sign=signal_period,
        fillna=fillna
    )
    data[f'{prefix}macd'] = macd.macd()
    data[f'{prefix}signal'] = macd.macd_signal()
    data[f'{prefix}diff'] = macd.macd_diff()
    return data

def compute_rsi(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 14,
    fillna: bool = False,
    output_col: str = 'rsi'
) -> pd.DataFrame:
    rsi = RSIIndicator(
        close=data[price_column],
        window=period,
        fillna=fillna
    )
    data[output_col] = rsi.rsi()
    return data

def compute_bollinger_bands(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 20,
    std_multiplier: float = 2.0,
    fillna: bool = False,
    prefix: str = 'bb_'
) -> pd.DataFrame:
    bb = BollingerBands(
        close=data[price_column],
        window=period,
        window_dev=std_multiplier,
        fillna=fillna
    )
    data[f'{prefix}mavg'] = bb.bollinger_mavg()
    data[f'{prefix}hband'] = bb.bollinger_hband()
    data[f'{prefix}lband'] = bb.bollinger_lband()
    data[f'{prefix}pband'] = bb.bollinger_pband()
    data[f'{prefix}wband'] = bb.bollinger_wband()
    data[f'{prefix}hband_ind'] = bb.bollinger_hband_indicator()
    data[f'{prefix}lband_ind'] = bb.bollinger_lband_indicator()
    return data

---

# trading/positions.py

import uuid

class TradePosition:
    """
    거래 포지션 관리 클래스.
    
    Attributes:
      - position_id: 포지션에 대한 고유 식별자 (UUID 문자열)
      - side: "LONG" 혹은 "SHORT"
      - executions: 개별 체결 내역 리스트 (각 execution은 entry_price, size 등 기록)
      - initial_price: 첫 체결 기준 가격
      - maximum_size: 포지션의 총 목표 수량
      - total_splits: 계획된 분할 매수 횟수
      - executed_splits: 현재까지 체결된 분할 횟수
      - allocation_plan: 각 분할 매수 비중 리스트 (예: [0.3, 0.3, 0.4])
    """
    def __init__(
        self,
        side: str = "LONG",
        initial_price: float = None,
        maximum_size: float = 0.0,
        total_splits: int = 1,
        allocation_plan: list = None
    ):
        self.position_id = str(uuid.uuid4())  # 포지션 고유 식별자 생성
        self.side = side
        self.executions = []  # 각 체결 내역을 저장
        self.initial_price = initial_price
        self.maximum_size = maximum_size
        self.total_splits = total_splits
        self.executed_splits = 0
        self.allocation_plan = allocation_plan if allocation_plan is not None else []

    def add_execution(
        self,
        entry_price: float,
        size: float,
        stop_loss: float = None,
        take_profit: float = None,
        entry_time = None,
        exit_targets: list = None,
        trade_type: str = "unknown"  # 신규 진입("new_entry") 또는 분할 매수("scale_in") 구분
    ):
        """
        하나의 체결(실제 매수)를 기록.
        exit_targets: [(target_price, exit_ratio), ...]
                      예) 첫 목표가 도달 시 50% 청산, 이후 전량 청산
        trade_type: 체결의 유형. 신규 진입("new_entry") 또는 분할 매수("scale_in") 등
        """
        exit_targets_flagged = []
        if exit_targets is not None:
            for target_price, exit_ratio in exit_targets:
                exit_targets_flagged.append({
                    'price': target_price,
                    'exit_ratio': exit_ratio,
                    'hit': False
                })
        self.executions.append({
            'entry_price': entry_price,
            'size': size,
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'entry_time': entry_time,
            'exit_targets': exit_targets_flagged,
            'trade_type': trade_type
        })
        
    def get_total_size(self) -> float:
        """현재까지 체결된 총 수량"""
        return sum(exec_record['size'] for exec_record in self.executions)

    def get_average_entry_price(self) -> float:
        """가중평균 매수가 계산"""
        total_cost = sum(exec_record['entry_price'] * exec_record['size'] for exec_record in self.executions)
        total_qty = self.get_total_size()
        return (total_cost / total_qty) if total_qty > 0 else 0.0

    def remove_execution(self, index: int):
        """지정된 인덱스의 체결 내역을 제거 (전량 청산)"""
        if 0 <= index < len(self.executions):
            self.executions.pop(index)

    def is_empty(self) -> bool:
        """포지션에 체결 내역이 없으면 True"""
        return len(self.executions) == 0

    def partial_close_execution(self, index: int, close_ratio: float) -> float:
        """
        지정된 체결 내역의 일정 비율(close_ratio)만 청산.
        반환: 청산된 수량
        """
        if 0 <= index < len(self.executions):
            exec_record = self.executions[index]
            qty_to_close = exec_record['size'] * close_ratio
            exec_record['size'] -= qty_to_close
            return qty_to_close
        return 0.0

---

# trading/risk.py
import math

def compute_position_size(
    account_balance: float,
    risk_percentage: float,
    entry_price: float,
    stop_loss: float,
    fee_rate: float = 0.001
) -> float:
    """
    계좌 자산 대비 지정 위험 비율에 따라 매수할 수 있는 포지션 사이즈 계산.
    
    계산:
      1) 1코인당 손실 = |entry_price - stop_loss|
      2) 허용 손실 금액 = account_balance * risk_percentage
      3) 수수료(fee_rate) 고려: 1코인당 총 손실 = 가격 차이 + (entry_price * fee_rate)
      4) 포지션 사이즈 = 허용 손실 금액 / (1코인당 총 손실)
    """
    price_diff = abs(entry_price - stop_loss)
    max_risk = account_balance * risk_percentage
    fee_amount = entry_price * fee_rate
    loss_per_unit = price_diff + fee_amount

    return max_risk / loss_per_unit if loss_per_unit > 0 else 0.0

def allocate_position_splits(
    total_size: float,
    splits_count: int = 3,
    allocation_mode: str = 'equal'
) -> list:
    """
    전체 포지션 사이즈를 여러 분할 체결하기 위한 비중 리스트 계산.
    
    - allocation_mode:
        'equal'        : 같은 비중
        'pyramid_up'   : 후속 분할일수록 비중 증가
        'pyramid_down' : 초기 분할일수록 비중 증가
    """
    if splits_count < 1:
        raise ValueError("splits_count는 1 이상이어야 합니다.")
    if allocation_mode not in ['equal', 'pyramid_up', 'pyramid_down']:
        raise ValueError("allocation_mode는 'equal', 'pyramid_up', 'pyramid_down' 중 하나여야 합니다.")
    
    if allocation_mode == 'equal':
        split_amount = total_size / splits_count
        return [split_amount] * splits_count
    elif allocation_mode == 'pyramid_up':
        ratio_sum = splits_count * (splits_count + 1) / 2
        return [(i / ratio_sum) * total_size for i in range(1, splits_count + 1)]
    elif allocation_mode == 'pyramid_down':
        ratio_sum = splits_count * (splits_count + 1) / 2
        return [(i / ratio_sum) * total_size for i in range(splits_count, 0, -1)]

def attempt_scale_in_position(
    position,
    current_price: float,
    scale_in_threshold: float = 0.02,
    slippage_rate: float = 0.0,
    stop_loss: float = None,
    take_profit: float = None,
    entry_time = None,
    trade_type: str = "scale_in"  # 기본적으로 "scale_in"으로 설정
):
    """
    분할 매수(스케일 인) 조건 확인 및 실행.
    - scale_in_threshold: 초기 진입가 대비 몇 퍼센트 상승하면 추가 체결
    - slippage_rate: 체결시 발생하는 슬리피지 (가격 상승 비율)
    - trade_type: 추가 체결에 대한 거래 유형 (기본값 "scale_in")
    """
    if position is None or position.is_empty():
        return
    
    # 분할 매수 실행: 아직 체결되지 않은 분할이 남은 경우
    while position.executed_splits < position.total_splits:
        next_split = position.executed_splits
        # 목표 가격 계산: initial_price * (1 + scale_in_threshold * split_index)
        target_price = position.initial_price * (1.0 + scale_in_threshold * next_split)
        if current_price < target_price:
            break  # 아직 추가 체결 조건 미충족
        if next_split < len(position.allocation_plan):
            portion = position.allocation_plan[next_split]
        else:
            break
        
        # 매수 수량 계산: 전체 최대 수량의 해당 비중
        chunk_size = position.maximum_size * portion
        # 슬리피지 적용: 체결가는 current_price * (1 + slippage_rate)
        executed_price = current_price * (1.0 + slippage_rate)
        # 체결 시 trade_type 인수를 명시적으로 전달
        position.add_execution(
            entry_price=executed_price,
            size=chunk_size,
            stop_loss=stop_loss,
            take_profit=take_profit,
            entry_time=entry_time,
            trade_type=trade_type
        )
        position.executed_splits += 1

---

# trading/signals.py

import pandas as pd
from trading.indicators import compute_sma, compute_macd, compute_rsi, compute_bollinger_bands

def generate_breakout_signals(
    data: pd.DataFrame,
    lookback_window: int = 20,
    volume_factor: float = 1.5,
    confirmation_bars: int = 2,
    use_high_price: bool = False,
    breakout_buffer: float = 0.0,
    high_max_prefix: str = "highest_",
    breakout_flag_col: str = "breakout_signal",
    vol_ma_prefix: str = "vol_ma_",
    confirmed_breakout_flag_col: str = "confirmed_breakout"
) -> pd.DataFrame:
    """
    돌파 전략 신호 생성 함수.
    - 과거 봉 기준 최고가와 거래량 조건을 적용하여 신호를 생성하고,
    - confirmation_bars만큼 연속해서 조건이 충족될 때 최종 신호를 확정합니다.
    """
    # 1) 이전 봉들 중 최고가 (현재 봉 제외)
    data[f'{high_max_prefix}{lookback_window}'] = (
        data['high'].shift(1).rolling(lookback_window).max()
    )
    # 2) 돌파 신호 (고가 또는 종가 기준)
    price_source = data['high'] if use_high_price else data['close']
    data[breakout_flag_col] = price_source > (data[f'{high_max_prefix}{lookback_window}'] * (1 + breakout_buffer))
    # 3) 거래량 이동 평균
    data[f'{vol_ma_prefix}{lookback_window}'] = (
        data['volume'].shift(1).rolling(lookback_window).mean()
    )
    data['volume_condition'] = data['volume'] > (volume_factor * data[f'{vol_ma_prefix}{lookback_window}'])
    
    # 4) 최종 신호: 돌파 및 거래량 조건 모두 충족되어야 함.
    data[breakout_flag_col] = data[breakout_flag_col] & data['volume_condition']
    
    # 5) 확정 돌파 (연속 확인)
    data[confirmed_breakout_flag_col] = (
        data[breakout_flag_col].rolling(confirmation_bars).sum() == confirmation_bars
    ).fillna(False)
    
    return data

def generate_retest_signals(
    data: pd.DataFrame,
    retest_threshold: float = 0.005,
    confirmation_bars: int = 2,
    breakout_reference_col: str = "highest_20",
    breakout_signal_col: str = "breakout_signal",
    retest_signal_col: str = "retest_signal"
) -> pd.DataFrame:
    """
    돌파 신호 발생 후 일정 기간 내에 가격이 돌파 기준가 근처로 풀백하고, 이후 반등하는 경우를 리테스트 신호로 생성합니다.
    
    Parameters:
      - data: OHLCV 데이터가 포함된 DataFrame. 반드시 breakout_reference_col과 breakout_signal_col이 포함되어 있어야 합니다.
      - retest_threshold: 돌파 기준가 대비 허용 풀백 범위 (예: 0.005는 0.5% 풀백 허용)
      - confirmation_bars: 리테스트 신호를 확인하기 위해 확인할 연속 캔들 수
      - breakout_reference_col: 돌파 기준가(예: 이전 lookback_window 동안의 최고가) 컬럼명
      - breakout_signal_col: 기존 돌파 신호 컬럼명 (예: breakout_signal)
      - retest_signal_col: 생성할 리테스트 신호 컬럼명 (예: retest_signal)
    
    Returns:
      - DataFrame에 retest_signal_col 컬럼이 추가되어 리테스트 신호(True/False)가 기록됩니다.
    """
    data[retest_signal_col] = False
    
    # 돌파 신호가 발생한 인덱스 위치들을 확인합니다.
    breakout_indices = data.index[data[breakout_signal_col] == True]
    for br_idx in breakout_indices:
        # 해당 행의 돌파 기준 가격
        breakout_level = data.loc[br_idx, breakout_reference_col]
        try:
            pos = data.index.get_loc(br_idx)
        except Exception:
            continue
        # 이후 confirmation_bars 기간 동안 리테스트 조건을 확인합니다.
        for offset in range(1, confirmation_bars + 1):
            if pos + offset >= len(data):
                break
            current_row = data.iloc[pos + offset]
            # 조건: 현재 행의 low가 breakout_level 범위 내 (즉, breakout_level*(1 - retest_threshold) 이상)
            if current_row['low'] <= breakout_level and current_row['low'] >= breakout_level * (1 - retest_threshold):
                # 다음 캔들이 존재하는지 확인한 후, 그 캔들의 close가 breakout_level을 상회하면 리테스트 신호로 간주
                if pos + offset + 1 < len(data):
                    next_row = data.iloc[pos + offset + 1]
                    if next_row['close'] > breakout_level:
                        retest_idx = next_row.name
                        data.at[retest_idx, retest_signal_col] = True
                        break
    return data

def filter_long_trend(
    data: pd.DataFrame,
    price_column: str = 'close',
    sma_period: int = 200,
    macd_slow_period: int = 26,
    macd_fast_period: int = 12,
    macd_signal_period: int = 9,
    rsi_period: int = 14,
    rsi_threshold: float = 70.0,
    bb_period: int = 20,
    bb_std_multiplier: float = 2.0,
    fillna: bool = False,
    macd_diff_column: str = 'macd_diff',
    rsi_column: str = 'rsi',
    bb_upper_band_column: str = 'bb_hband'
) -> pd.DataFrame:
    """
    장기 추세 필터 함수.
    SMA, MACD, RSI, Bollinger Bands를 계산한 후, 여러 조건을 만족하면 long_filter_pass가 True가 됩니다.
    """
    # 1) SMA 계산
    sma_col = f"sma{sma_period}"
    data = compute_sma(
        data,
        price_column=price_column,
        period=sma_period,
        fillna=fillna,
        output_col=sma_col
    )
    # 2) MACD 계산
    data = compute_macd(
        data,
        price_column=price_column,
        slow_period=macd_slow_period,
        fast_period=macd_fast_period,
        signal_period=macd_signal_period,
        fillna=fillna,
        prefix='macd_'
    )
    # 3) RSI 계산
    data = compute_rsi(
        data,
        price_column=price_column,
        period=rsi_period,
        fillna=fillna,
        output_col=rsi_column
    )
    # 4) Bollinger Bands 계산
    data = compute_bollinger_bands(
        data,
        price_column=price_column,
        period=bb_period,
        std_multiplier=bb_std_multiplier,
        fillna=fillna,
        prefix='bb_'
    )
    # 5) 추세 필터 조건 적용
    data['long_filter_pass'] = (
        (data[price_column] >= data[sma_col]) &
        (data[macd_diff_column] > 0) &
        (data[rsi_column] < rsi_threshold) &
        (data[bb_upper_band_column] > data[price_column])
    )
    return data

---

# trading/trade_management.py
import pandas as pd
import numpy as np
import ta

def calculate_atr_stop_loss(
    data: pd.DataFrame,
    atr_period: int = 14,
    atr_factor: float = 2.0,
    stop_loss_col: str = 'stop_loss_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    ATR 기반 손절가 계산.
    손절가 = entry_price - (ATR * atr_factor)
    """
    atr_indicator = ta.volatility.AverageTrueRange(
        high=data['high'],
        low=data['low'],
        close=data['close'],
        window=atr_period,
        fillna=True
    )
    data['atr'] = atr_indicator.average_true_range()
    data[entry_price_col] = np.where(data.get('long_entry', False), data['close'], np.nan)
    data[entry_price_col] = data[entry_price_col].ffill()
    data[stop_loss_col] = data[entry_price_col] - (data['atr'] * atr_factor)
    return data

def adjust_trailing_stop(
    current_stop: float,
    current_price: float,
    highest_price: float,
    trailing_percentage: float
) -> float:
    """
    트레일링 스탑 업데이트:
      새로운 손절가는 최고가 대비 trailing_percentage만큼 낮은 가격.
      단, 업데이트된 손절가는 기존 손절가보다 높고 현재 가격보다는 낮아야 함.
    """
    new_stop = highest_price * (1.0 - trailing_percentage)
    if new_stop > current_stop and new_stop < current_price:
        return new_stop
    else:
        return current_stop

def set_fixed_take_profit(
    data: pd.DataFrame,
    profit_ratio: float = 0.05,
    take_profit_col: str = 'take_profit_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    고정 수익률 기반 익절가 설정:
      take_profit = entry_price * (1 + profit_ratio)
    """
    data[take_profit_col] = data[entry_price_col] * (1 + profit_ratio)
    return data

def should_exit_trend(
    data: pd.DataFrame,
    current_time,
    window_length: int = 20,
    price_column: str = 'close'
) -> bool:
    """
    추세 종료(청산) 신호 판단 함수.
    - 최근 window_length 봉의 최저가보다 현재 종가가 낮으면 추세가 꺾였다고 판단.
    """
    if current_time not in data.index:
        data_sub = data.loc[:current_time]
        if len(data_sub) < window_length:
            return False
        window_data = data_sub.iloc[-window_length:]
        current_row = data_sub.iloc[-1]
    else:
        idx = data.index.get_loc(current_time)
        if idx < window_length:
            return False
        window_data = data.iloc[idx - window_length + 1: idx + 1]
        current_row = data.loc[current_time]
    
    recent_min = window_data[price_column].min()
    current_price = current_row[price_column]
    
    return current_price < recent_min

def calculate_partial_exit_targets(
    entry_price: float,
    partial_exit_ratio: float = 0.5,
    partial_profit_ratio: float = 0.03,  # 예: 3% 상승 시 일부 청산
    final_profit_ratio: float = 0.06     # 예: 6% 상승 시 전량 청산
):
    """
    분할 청산 목표가 계산 함수.
    예) entry_price=10000 인 경우:
         - partial_profit_ratio=0.03 → 10,300 달성 시 50% 청산
         - final_profit_ratio=0.06   → 10,600 달성 시 나머지 전량 청산
    반환: [(target_price, exit_ratio), ...]
    """
    partial_target = entry_price * (1.0 + partial_profit_ratio)
    final_target = entry_price * (1.0 + final_profit_ratio)
    return [
        (partial_target, partial_exit_ratio),
        (final_target, 1.0)
    ]

def calculate_fibonacci_take_profit(
    entry_price: float,
    recent_high: float,
    recent_low: float,
    levels: list = [0.382, 0.618, 1.0]
):
    """
    피보나치 되돌림 기반으로 익절 목표가를 계산합니다.
    Parameters:
      - entry_price: 진입 가격
      - recent_high: 최근 고가 (지지/저항 분석에 활용)
      - recent_low: 최근 저가
      - levels: 사용할 피보나치 비율 리스트
    Returns:
      - [(target_price, exit_ratio), ...] 형식의 리스트.
        예를 들어, 첫 목표는 50% 청산, 이후 전량 청산 등으로 설정.
    """
    range_price = recent_high - recent_low
    targets = []
    for idx, level in enumerate(levels):
        target = recent_low + range_price * (1 + level)
        exit_ratio = 0.5 if idx < len(levels) - 1 else 1.0
        targets.append((target, exit_ratio))
    return targets

---

# backtesting/backtest_advanced.py

import pandas as pd
import numpy as np
from typing import Optional

# 기존 함수 임포트
from data_collection.db_ohlcv_manager import fetch_ohlcv_records
from trading.signals import (
    generate_breakout_signals,
    filter_long_trend,
    generate_retest_signals
)
from trading.trade_management import (
    calculate_atr_stop_loss,
    adjust_trailing_stop,
    set_fixed_take_profit,
    should_exit_trend,
    calculate_partial_exit_targets
)
from trading.risk import (
    compute_position_size,
    allocate_position_splits,
    attempt_scale_in_position
)
from trading.positions import TradePosition
from backtesting.performance_metrics import print_performance_report
from trading.indicators import compute_rsi

# --- 개선된 백테스트 로직 ---
def run_advanced_backtest(
    symbol: str = "BTC/USDT",
    short_timeframe: str = "4h",
    long_timeframe: str = "1d",
    window: int = 20,
    volume_factor: float = 1.5,
    confirm_bars: int = 2,
    breakout_buffer: float = 0.005,
    atr_window: int = 14,
    atr_multiplier: float = 2.5,
    profit_ratio: float = 0.05,
    account_size: float = 10000.0,
    risk_per_trade: float = 0.01,
    fee_rate: float = 0.001,
    slippage_rate: float = 0.0005,
    taker_fee_rate: float = 0.001,
    total_splits: int = 3,
    allocation_mode: str = "equal",
    threshold_percent: float = 0.02,
    use_trailing_stop: bool = False,
    trailing_percent: float = 0.05,
    use_trend_exit: bool = False,
    trend_exit_lookback: int = 30,
    trend_exit_price_column: str = "close",
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    use_partial_take_profit: bool = False,
    partial_tp_factor: float = 0.03,
    final_tp_factor: float = 0.06,
    short_table_format: str = "ohlcv_{symbol}_{timeframe}",
    long_table_format: str = "ohlcv_{symbol}_{timeframe}",
    position_side: str = "LONG",
    stop_loss_col: str = "stop_loss_price",      # 미사용(각 거래별 계산)
    entry_price_col: str = "entry_price",         # 미사용(각 거래별 저장)
    take_profit_col: str = "take_profit_price",   # 미사용(각 거래별 계산)
    # 장기 추세 필터 관련 파라미터
    sma_period: int = 200,
    macd_slow_period: int = 26,
    macd_fast_period: int = 12,
    macd_signal_period: int = 9,
    rsi_period: int = 14,
    rsi_threshold: float = 70.0,
    bb_period: int = 20,
    bb_std_multiplier: float = 2.0,
    # 단기 보조지표 관련 파라미터
    use_short_term_indicators: bool = True,
    short_rsi_threshold: float = 40.0,
    short_rsi_period: int = 14,
    # 리테스트 관련 파라미터
    retest_threshold: float = 0.005,
    retest_confirmation_bars: int = 2,
    # 신호 컬럼명 (기본값)
    breakout_flag_col: str = "breakout_signal",
    confirmed_breakout_flag_col: str = "confirmed_breakout",
    retest_signal_col: str = "retest_signal",
    long_entry_col: str = "long_entry"
):
    """
    개선된 백테스트 함수
      - 거래 진입 전에 단기 데이터에 대해 ATR(및 관련 지표)를 미리 계산합니다.
      - 각 봉마다 포지션 상태(청산, 트레일링 스탑, 분할 매수)를 업데이트합니다.
      - 신호 조건(돌파/리테스트/단기 보조지표)와 장기 추세 필터를 모두 고려하여 거래 진입 여부를 결정합니다.
    """
    # 1. 데이터 로드 및 정렬
    short_table = short_table_format.format(symbol=symbol.replace('/', '').lower(), timeframe=short_timeframe)
    long_table = long_table_format.format(symbol=symbol.replace('/', '').lower(), timeframe=long_timeframe)
    df_short = fetch_ohlcv_records(table_name=short_table, start_date=start_date, end_date=end_date)
    df_long = fetch_ohlcv_records(table_name=long_table, start_date=start_date, end_date=end_date)
    if df_short.empty or df_long.empty:
        print("[ERROR] No data loaded.")
        return None
    df_short.sort_index(inplace=True)
    df_long.sort_index(inplace=True)
    
    # 2. 신호 생성 (단기: 돌파, 리테스트, 보조지표)
    df_short = generate_breakout_signals(
        data=df_short,
        lookback_window=window,
        volume_factor=volume_factor,
        confirmation_bars=confirm_bars,
        breakout_buffer=breakout_buffer,
        breakout_flag_col=breakout_flag_col,
        confirmed_breakout_flag_col=confirmed_breakout_flag_col
    )
    df_short = generate_retest_signals(
        data=df_short,
        retest_threshold=retest_threshold,
        confirmation_bars=retest_confirmation_bars,
        breakout_reference_col=f"highest_{window}",
        breakout_signal_col=breakout_flag_col,
        retest_signal_col=retest_signal_col
    )
    if use_short_term_indicators:
        df_short = compute_rsi(df_short, price_column="close", period=short_rsi_period, output_col="short_rsi")
        short_filter = df_short["short_rsi"] < short_rsi_threshold
    else:
        short_filter = True
    df_short[long_entry_col] = (df_short[confirmed_breakout_flag_col] | df_short[retest_signal_col]) & short_filter

    # 3. 장기 추세 필터 (동일 시간대의 데이터 사용)
    df_long = filter_long_trend(
        data=df_long,
        price_column='close',
        sma_period=sma_period,
        macd_slow_period=macd_slow_period,
        macd_fast_period=macd_fast_period,
        macd_signal_period=macd_signal_period,
        rsi_period=rsi_period,
        rsi_threshold=rsi_threshold,
        bb_period=bb_period,
        bb_std_multiplier=bb_std_multiplier,
        fillna=False
    )
    
    # 4. 단기 데이터에 대해 ATR를 미리 계산 (이후 각 거래 진입 시 사용)
    try:
        import ta
    except ImportError:
        print("[ERROR] 'ta' 라이브러리가 필요합니다.")
        return None

    atr_indicator = ta.volatility.AverageTrueRange(
        high=df_short['high'],
        low=df_short['low'],
        close=df_short['close'],
        window=atr_window,
        fillna=True
    )
    df_short['atr'] = atr_indicator.average_true_range()

    # 5. 백테스트 시뮬레이션
    current_position = None
    trades = []       # 개별 체결별 거래 내역 저장 리스트
    trade_logs = []   # 체결 상세 기록
    highest_price_since_entry = None  # 포지션 진입 후 최고가 기록

    # 각 봉마다 시뮬레이션 진행
    for current_time, row in df_short.iterrows():
        close_price = row['close']
        high_price = row['high']
        low_price = row['low']
        atr_value = row['atr']
        
        # 5-1. 열린 포지션 업데이트 (청산, 트레일링 스탑, 분할 매수)
        if current_position is not None:
            # (A) 트레일링 스탑 업데이트
            if use_trailing_stop:
                if highest_price_since_entry is None or high_price > highest_price_since_entry:
                    highest_price_since_entry = high_price
                for execution in current_position.executions:
                    if not execution.get("closed", False):
                        old_sl = execution['stop_loss']
                        new_sl = adjust_trailing_stop(
                            current_stop=old_sl,
                            current_price=close_price,
                            highest_price=highest_price_since_entry,
                            trailing_percentage=trailing_percent
                        )
                        execution['stop_loss'] = new_sl

            # (B) 각 체결에 대해 청산 조건 확인 (Stop Loss, Take Profit, Trend Exit)
            executions_to_close = []
            for i, exec_record in enumerate(current_position.executions):
                if exec_record.get("closed", False):
                    continue
                ep = exec_record['entry_price']
                sl = exec_record['stop_loss']
                tp = exec_record.get("take_profit")
                size = exec_record['size']
                exit_triggered = False
                exit_price = None
                exit_reason = None

                # Stop Loss 조건
                if low_price <= sl:
                    exit_triggered = True
                    exit_price = sl  # 슬리피지 적용 가능: sl * (1 - slippage_rate)
                    exit_reason = "stop_loss"
                # Take Profit 조건
                elif tp is not None and high_price >= tp:
                    exit_triggered = True
                    exit_price = tp  # 슬리피지 적용 가능: tp * (1 - slippage_rate)
                    exit_reason = "take_profit"
                # Trend Exit 조건 (장기 추세 필터 기반)
                elif use_trend_exit:
                    # 현재 시간에 대응하는 장기 데이터(또는 가장 최근 데이터) 사용
                    if current_time in df_long.index:
                        trend_row = df_long.loc[current_time]
                    else:
                        trend_row = df_long.iloc[-1]
                    df_long_sub = df_long.loc[:current_time]
                    if len(df_long_sub) >= trend_exit_lookback:
                        recent_window = df_long_sub.iloc[-trend_exit_lookback:]
                        recent_min = recent_window[trend_exit_price_column].min()
                        if close_price < recent_min:
                            exit_triggered = True
                            exit_price = close_price
                            exit_reason = "trend_exit"

                if exit_triggered:
                    # 체결 종료 처리
                    exec_record["closed"] = True
                    fee = exit_price * size * fee_rate
                    pnl = (exit_price - ep) * size - fee
                    trade_detail = {
                        'entry_time': exec_record['entry_time'],
                        'entry_price': ep,
                        'exit_time': current_time,
                        'exit_price': exit_price,
                        'size': size,
                        'pnl': pnl,
                        'reason': exit_reason,
                        'trade_type': exec_record.get("trade_type", "unknown"),
                        'position_id': current_position.position_id
                    }
                    trade_logs.append(trade_detail)
                    trades.append(trade_detail)
                    executions_to_close.append(i)
            
            # 제거: 종료된 체결은 리스트에서 제거하고, 포지션이 완전히 청산되었으면 None으로 처리
            for i in sorted(executions_to_close, reverse=True):
                current_position.executions.pop(i)
            if current_position.is_empty():
                current_position = None
                highest_price_since_entry = None

            # (C) 분할 매수 (Scale-In): 열린 포지션이 있고, 아직 전체 분할 횟수 미달이며, 현재 봉이 신규 진입 신호이면 추가 체결 시도
            if current_position is not None and current_position.executed_splits < current_position.total_splits and row[long_entry_col]:
                next_split = current_position.executed_splits
                # 다음 추가 체결 목표가: 초기 진입가의 (1 + threshold_percent * split_index)
                target_price = current_position.initial_price * (1.0 + threshold_percent * next_split)
                if close_price >= target_price:
                    total_size = current_position.maximum_size
                    plan_list = current_position.allocation_plan
                    if next_split < len(plan_list):
                        scale_in_size = total_size * plan_list[next_split]
                        scale_in_price = close_price  # 현재 가격 사용
                        scale_in_stop = scale_in_price - (atr_value * atr_multiplier)
                        scale_in_take_profit = scale_in_price * (1 + profit_ratio)
                        current_position.add_execution(
                            entry_price=scale_in_price,
                            size=scale_in_size,
                            stop_loss=scale_in_stop,
                            take_profit=scale_in_take_profit,
                            entry_time=current_time,
                            exit_targets=[],  # 분할 청산 목표 계산 함수 적용 가능
                            trade_type="scale_in"
                        )
                        current_position.executed_splits += 1

        # 5-2. 신규 진입: 열린 포지션이 없고, 단기 신호와 장기 추세 필터 조건 모두 만족할 때 진입
        if current_position is None and row[long_entry_col]:
            if current_time in df_long.index:
                trend_row = df_long.loc[current_time]
            else:
                trend_row = df_long.iloc[-1]
            if trend_row.get('long_filter_pass', False):
                current_position = TradePosition(
                    side=position_side,
                    initial_price=close_price,
                    maximum_size=0.0,  # 아래에서 계산
                    total_splits=total_splits,
                    allocation_plan=[]
                )
                # 진입 시 ATR을 기반으로 Stop Loss 계산
                entry_price_for_calc = close_price  # 슬리피지 미적용 가격
                initial_stop = close_price - (atr_value * atr_multiplier)
                total_size = compute_position_size(
                    account_balance=account_size,
                    risk_percentage=risk_per_trade,
                    entry_price=entry_price_for_calc,
                    stop_loss=initial_stop,
                    fee_rate=fee_rate
                )
                current_position.maximum_size = total_size
                plan_list = allocate_position_splits(
                    total_size=1.0,
                    splits_count=total_splits,
                    allocation_mode=allocation_mode
                )
                current_position.allocation_plan = plan_list
                # 첫 체결: 신규 진입
                buy_size = total_size * plan_list[0]
                buy_price = close_price
                initial_take_profit = buy_price * (1 + profit_ratio)
                current_position.add_execution(
                    entry_price=buy_price,
                    size=buy_size,
                    stop_loss=initial_stop,
                    take_profit=initial_take_profit,
                    entry_time=current_time,
                    exit_targets=[],  # 필요시 분할 청산 목표 계산 적용
                    trade_type="new_entry"
                )
                current_position.executed_splits = 1
                highest_price_since_entry = close_price

    # 6. 시뮬레이션 종료 후, 미체결 포지션은 마지막 봉의 종가로 청산 처리
    if current_position is not None and not current_position.is_empty():
        final_time = df_short.index[-1]
        final_close = df_short.iloc[-1]['close']
        for exec_record in current_position.executions:
            if not exec_record.get("closed", False):
                fee = final_close * exec_record['size'] * fee_rate
                pnl = (final_close - exec_record['entry_price']) * exec_record['size'] - fee
                exec_record["closed"] = True
                trade_detail = {
                    'entry_time': exec_record['entry_time'],
                    'entry_price': exec_record['entry_price'],
                    'exit_time': final_time,
                    'exit_price': final_close,
                    'size': exec_record['size'],
                    'pnl': pnl,
                    'reason': "final_exit",
                    'trade_type': exec_record.get("trade_type", "unknown"),
                    'position_id': current_position.position_id
                }
                trade_logs.append(trade_detail)
                trades.append(trade_detail)

    # 7. 결과 정리 및 성과 출력
    trades_df = pd.DataFrame(trades)
    if trades_df.empty:
        print("[INFO] No trades executed.")
        return None

    total_pnl = trades_df['pnl'].sum()
    final_balance = account_size + total_pnl
    roi_percent = (final_balance - account_size) / account_size * 100.0

    print("\n=== 백테스트 결과 ===")
    print(f"총 거래 횟수(분할 포함): {len(trades_df)}")
    print(f"총 손익: {total_pnl:.2f} USDT")
    print(f"최종 잔고: {final_balance:.2f} USDT")
    print(f"수익률: {roi_percent:.2f}%")

    print_performance_report(trades_df, initial_balance=account_size)
    return trades_df, trade_logs

---
# backtesting/parameter_group.json

{
  "signal_generation": {
    "breakout_signal": {
      "lookback_window": {
        "description": "과거 몇 개 봉의 데이터를 참고해 최고가 산출 기간",
        "range": { "min": 10, "max": 30 }
      },
      "volume_factor": {
        "description": "거래량 이동평균 대비 현재 거래량 배수 조건",
        "range": { "min": 1.2, "max": 2.0 }
      },
      "confirmation_bars": {
        "description": "조건이 연속으로 충족되어야 하는 봉의 수",
        "range": { "min": 1, "max": 3 }
      },
      "breakout_buffer": {
        "description": "돌파 시 가격에 적용하는 여유 비율",
        "range": { "min": 0.001, "max": 0.005 }
      },
      "retest_settings": {
        "retest_threshold": {
          "description": "돌파 후 리테스트 허용 범위 (비율). 예: 0.005는 0.5% 범위 내 풀백 허용",
          "range": { "min": 0.003, "max": 0.01 }
        },
        "retest_confirmation_bars": {
          "description": "리테스트 신호 확인에 사용할 연속 캔들 수",
          "range": { "min": 1, "max": 3 }
        }
      },
      "signal_options": {
        "use_short_term_indicators": {
          "description": "단기 보조지표(RSI 등) 사용 여부",
          "type": "boolean"
        },
        "short_rsi_threshold": {
          "description": "단기 보조지표(RSI)가 진입 조건을 충족하기 위한 임계값",
          "range": { "min": 20, "max": 50 }
        },
        "short_rsi_period": {
          "description": "단기 보조지표(RSI) 계산에 사용할 기간",
          "range": { "min": 10, "max": 20 }
        }
      }
    },
    "trend_filter": {
      "sma_period": {
        "description": "장기 단순이동평균(SMA) 계산 기간",
        "options": [100, 150, 200]
      },
      "macd_slow_period": {
        "description": "MACD 계산 시 느린 기간",
        "range": { "min": 20, "max": 30 }
      },
      "macd_fast_period": {
        "description": "MACD 계산 시 빠른 기간",
        "range": { "min": 10, "max": 15 }
      },
      "macd_signal_period": {
        "description": "MACD 신호선 계산 기간",
        "range": { "min": 7, "max": 12 }
      },
      "rsi_period": {
        "description": "장기 RSI 계산 기간",
        "range": { "min": 10, "max": 20 }
      },
      "rsi_threshold": {
        "description": "장기 RSI 임계값",
        "range": { "min": 60, "max": 80 }
      },
      "bb_period": {
        "description": "Bollinger Bands 계산 기간",
        "range": { "min": 15, "max": 25 }
      },
      "bb_std_multiplier": {
        "description": "Bollinger Bands 표준편차 배수",
        "range": { "min": 1.5, "max": 2.5 }
      }
    }
  },
  "risk_management": {
    "atr_stop": {
      "atr_period": {
        "description": "ATR 계산에 사용할 기간",
        "range": { "min": 10, "max": 20 }
      },
      "atr_multiplier": {
        "description": "ATR에 곱하여 손절 가격 산출 계수",
        "range": { "min": 1.5, "max": 3.5 }
      }
    },
    "take_profit": {
      "profit_ratio": {
        "description": "익절 비율",
        "range": { "min": 0.05, "max": 0.20 }
      },
      "use_trailing_stop": {
        "description": "트레일링 스탑 사용 여부",
        "type": "boolean"
      },
      "trailing_percent": {
        "description": "트레일링 스탑 후행 비율",
        "range": { "min": 0.03, "max": 0.06 }
      },
      "use_partial_take_profit": {
        "description": "분할 청산 사용 여부",
        "type": "boolean"
      },
      "partial_tp_factor": {
        "description": "분할 청산 익절 목표 비율",
        "range": { "min": 0.03, "max": 0.06 }
      },
      "final_tp_factor": {
        "description": "최종 청산 익절 목표 비율",
        "range": { "min": 0.06, "max": 0.10 }
      },
      "use_trend_exit": {
        "description": "추세 종료(exit trend) 조건 적용 여부",
        "type": "boolean"
      },
      "risk_per_trade": {
        "description": "한 거래에서 감수할 위험 비율 (계좌 자산 대비)",
        "range": { "min": 0.005, "max": 0.02 }
      }
    }
  },
  "position_sizing": {
    "total_splits": {
      "description": "분할 진입(또는 분할 매수) 횟수",
      "range": { "min": 2, "max": 3 }
    },
    "allocation_mode": {
      "description": "분할 매수 시 각 체결 비중 분배 방식",
      "options": ["equal", "pyramid_up", "pyramid_down"]
    },
    "scale_in_threshold": {
      "description": "추가 매수(스케일인)를 위한 가격 상승 비율 조건",
      "range": { "min": 0.01, "max": 0.02 }
    }
  },
  "exit_management": {
    "trend_exit_lookback": {
      "description": "추세 종료 판별 시 사용되는 lookback 기간",
      "range": { "min": 20, "max": 40 }
    }
  },
  "misc": {
    "short_timeframe": {
      "description": "단기 봉 데이터 타임프레임",
      "example": "4h"
    },
    "long_timeframe": {
      "description": "장기 봉 데이터 타임프레임",
      "example": "1d"
    }
  }
}

---

# backtesting/parameter_optimization.py

import os
import json
import hashlib
import optuna
import traceback

from backtesting.backtest_advanced import run_advanced_backtest

# 캐시 폴더 설정 (없으면 생성)
CACHE_DIR = os.path.join(os.path.dirname(__file__), "cache")
if not os.path.exists(CACHE_DIR):
    os.makedirs(CACHE_DIR)

def get_cache_key(params: dict, start_date: str, end_date: str) -> str:
    key_data = {"params": params, "start_date": start_date, "end_date": end_date}
    key_str = json.dumps(key_data, sort_keys=True)
    key_hash = hashlib.md5(key_str.encode("utf-8")).hexdigest()
    return key_hash

def load_cached_result(cache_key: str):
    cache_file = os.path.join(CACHE_DIR, f"{cache_key}.json")
    if os.path.exists(cache_file):
        try:
            with open(cache_file, "r") as f:
                data = json.load(f)
            return data.get("roi")
        except Exception:
            return None
    return None

def save_cached_result(cache_key: str, roi: float):
    cache_file = os.path.join(CACHE_DIR, f"{cache_key}.json")
    with open(cache_file, "w") as f:
        json.dump({"roi": roi}, f)

def sample_parameter(trial, name, param_spec):
    if "options" in param_spec:
        return trial.suggest_categorical(name, param_spec["options"])
    elif "type" in param_spec and param_spec["type"] == "boolean":
        return trial.suggest_categorical(name, [True, False])
    elif "range" in param_spec:
        min_val = param_spec["range"]["min"]
        max_val = param_spec["range"]["max"]
        if isinstance(min_val, int) and isinstance(max_val, int):
            return trial.suggest_int(name, min_val, max_val)
        else:
            return trial.suggest_float(name, min_val, max_val)
    else:
        raise ValueError(f"Parameter spec for {name} not recognized.")

def objective(trial: optuna.trial.Trial) -> float:
    # parameter_group.json 파일 읽기
    param_file = os.path.join(os.path.dirname(__file__), "parameter_group.json")
    with open(param_file, "r", encoding="utf-8") as f:
        param_groups = json.load(f)

    candidate_params = {}

    # [신호 생성] - breakout_signal 그룹
    breakout_signal = param_groups["signal_generation"]["breakout_signal"]
    candidate_params["lookback_window"] = sample_parameter(trial, "lookback_window", breakout_signal["lookback_window"])
    candidate_params["volume_factor"] = sample_parameter(trial, "volume_factor", breakout_signal["volume_factor"])
    candidate_params["confirmation_bars"] = sample_parameter(trial, "confirmation_bars", breakout_signal["confirmation_bars"])
    candidate_params["breakout_buffer"] = sample_parameter(trial, "breakout_buffer", breakout_signal["breakout_buffer"])
    
    # [신호 생성] - 리테스트 관련
    retest_settings = breakout_signal["retest_settings"]
    candidate_params["retest_threshold"] = sample_parameter(trial, "retest_threshold", retest_settings["retest_threshold"])
    candidate_params["retest_confirmation_bars"] = sample_parameter(trial, "retest_confirmation_bars", retest_settings["retest_confirmation_bars"])
    
    # [신호 생성] - 옵션 (signal_options 그룹)
    signal_options = breakout_signal["signal_options"]
    candidate_params["use_short_term_indicators"] = sample_parameter(trial, "use_short_term_indicators", signal_options["use_short_term_indicators"])
    candidate_params["short_rsi_threshold"] = sample_parameter(trial, "short_rsi_threshold", signal_options["short_rsi_threshold"])
    candidate_params["short_rsi_period"] = sample_parameter(trial, "short_rsi_period", signal_options["short_rsi_period"])

    # [신호 생성] - trend_filter 그룹
    trend_filter = param_groups["signal_generation"]["trend_filter"]
    candidate_params["sma_period"] = sample_parameter(trial, "sma_period", trend_filter["sma_period"])
    candidate_params["macd_slow_period"] = sample_parameter(trial, "macd_slow_period", trend_filter["macd_slow_period"])
    candidate_params["macd_fast_period"] = sample_parameter(trial, "macd_fast_period", trend_filter["macd_fast_period"])
    candidate_params["macd_signal_period"] = sample_parameter(trial, "macd_signal_period", trend_filter["macd_signal_period"])
    candidate_params["rsi_period"] = sample_parameter(trial, "rsi_period", trend_filter["rsi_period"])
    candidate_params["rsi_threshold"] = sample_parameter(trial, "rsi_threshold", trend_filter["rsi_threshold"])
    candidate_params["bb_period"] = sample_parameter(trial, "bb_period", trend_filter["bb_period"])
    candidate_params["bb_std_multiplier"] = sample_parameter(trial, "bb_std_multiplier", trend_filter["bb_std_multiplier"])

    # [리스크 관리] - atr_stop 그룹
    atr_stop = param_groups["risk_management"]["atr_stop"]
    candidate_params["atr_period"] = sample_parameter(trial, "atr_period", atr_stop["atr_period"])
    candidate_params["atr_multiplier"] = sample_parameter(trial, "atr_multiplier", atr_stop["atr_multiplier"])

    # [리스크 관리] - take_profit 그룹
    take_profit = param_groups["risk_management"]["take_profit"]
    candidate_params["profit_ratio"] = sample_parameter(trial, "profit_ratio", take_profit["profit_ratio"])
    candidate_params["use_trailing_stop"] = sample_parameter(trial, "use_trailing_stop", take_profit["use_trailing_stop"])
    candidate_params["trailing_percent"] = (
        sample_parameter(trial, "trailing_percent", take_profit["trailing_percent"])
        if candidate_params["use_trailing_stop"] else 0.0
    )
    candidate_params["use_partial_take_profit"] = sample_parameter(trial, "use_partial_take_profit", take_profit["use_partial_take_profit"])
    candidate_params["partial_tp_factor"] = sample_parameter(trial, "partial_tp_factor", take_profit["partial_tp_factor"])
    candidate_params["final_tp_factor"] = sample_parameter(trial, "final_tp_factor", take_profit["final_tp_factor"])
    candidate_params["use_trend_exit"] = sample_parameter(trial, "use_trend_exit", take_profit["use_trend_exit"])
    candidate_params["risk_per_trade"] = sample_parameter(trial, "risk_per_trade", take_profit["risk_per_trade"])

    # [포지션 사이징]
    position_sizing = param_groups["position_sizing"]
    candidate_params["total_splits"] = sample_parameter(trial, "total_splits", position_sizing["total_splits"])
    candidate_params["allocation_mode"] = sample_parameter(trial, "allocation_mode", position_sizing["allocation_mode"])
    candidate_params["scale_in_threshold"] = sample_parameter(trial, "scale_in_threshold", position_sizing["scale_in_threshold"])

    # [청산 관리] - exit_management 그룹
    exit_management = param_groups["exit_management"]
    candidate_params["trend_exit_lookback"] = sample_parameter(trial, "trend_exit_lookback", exit_management["trend_exit_lookback"])

    # [기타] - misc (타임프레임은 최적화 대상이 아니므로 예시값 사용)
    candidate_params["short_timeframe"] = param_groups["misc"]["short_timeframe"]["example"]
    candidate_params["long_timeframe"] = param_groups["misc"]["long_timeframe"]["example"]
    candidate_params["trend_exit_price_column"] = "close"

    # 추가 고정 파라미터
    candidate_params["atr_window"] = candidate_params["atr_period"]
    candidate_params["window"] = candidate_params["lookback_window"]

    # 신호 관련 컬럼명 (고정값)
    candidate_params["breakout_flag_col"] = "breakout_signal"
    candidate_params["confirmed_breakout_flag_col"] = "confirmed_breakout"
    candidate_params["retest_signal_col"] = "retest_signal"
    candidate_params["long_entry_col"] = "long_entry"

    fee_rate = 0.001
    slippage_rate = 0.0005
    taker_fee_rate = 0.001
    account_size = 10000.0

    walk_forward_periods = [
        ("2018-01-01", "2019-01-01"),
        ("2019-01-01", "2020-01-01"),
        ("2020-01-01", "2021-01-01")
    ]

    cumulative_roi = 0.0
    period_count = 0

    params_for_cache = candidate_params.copy()

    for start_date, end_date in walk_forward_periods:
        cache_key = get_cache_key(params_for_cache, start_date, end_date)
        cached_roi = load_cached_result(cache_key)
        if cached_roi is not None:
            roi = cached_roi
        else:
            try:
                result = run_advanced_backtest(
                    symbol="BTC/USDT",
                    short_timeframe=candidate_params["short_timeframe"],
                    long_timeframe=candidate_params["long_timeframe"],
                    window=candidate_params["window"],
                    volume_factor=candidate_params["volume_factor"],
                    confirm_bars=candidate_params["confirmation_bars"],
                    breakout_buffer=candidate_params["breakout_buffer"],
                    atr_window=candidate_params["atr_window"],
                    atr_multiplier=candidate_params["atr_multiplier"],
                    profit_ratio=candidate_params["profit_ratio"],
                    account_size=account_size,
                    risk_per_trade=candidate_params["risk_per_trade"],
                    fee_rate=fee_rate,
                    slippage_rate=slippage_rate,
                    taker_fee_rate=taker_fee_rate,
                    total_splits=candidate_params["total_splits"],
                    allocation_mode=candidate_params["allocation_mode"],
                    threshold_percent=candidate_params["scale_in_threshold"],
                    use_trailing_stop=candidate_params["use_trailing_stop"],
                    trailing_percent=candidate_params["trailing_percent"],
                    use_trend_exit=candidate_params["use_trend_exit"],
                    trend_exit_lookback=candidate_params["trend_exit_lookback"],
                    trend_exit_price_column=candidate_params["trend_exit_price_column"],
                    start_date=start_date,
                    end_date=end_date,
                    use_partial_take_profit=candidate_params["use_partial_take_profit"],
                    partial_tp_factor=candidate_params["partial_tp_factor"],
                    final_tp_factor=candidate_params["final_tp_factor"],
                    # Trend Filter 관련 파라미터
                    sma_period=candidate_params["sma_period"],
                    macd_slow_period=candidate_params["macd_slow_period"],
                    macd_fast_period=candidate_params["macd_fast_period"],
                    macd_signal_period=candidate_params["macd_signal_period"],
                    rsi_period=candidate_params["rsi_period"],
                    rsi_threshold=candidate_params["rsi_threshold"],
                    bb_period=candidate_params["bb_period"],
                    bb_std_multiplier=candidate_params["bb_std_multiplier"],
                    # 리테스트 및 신호 관련 파라미터
                    retest_threshold=candidate_params["retest_threshold"],
                    retest_confirmation_bars=candidate_params["retest_confirmation_bars"],
                    breakout_flag_col=candidate_params["breakout_flag_col"],
                    confirmed_breakout_flag_col=candidate_params["confirmed_breakout_flag_col"],
                    retest_signal_col=candidate_params["retest_signal_col"],
                    long_entry_col=candidate_params["long_entry_col"]
                )
            except Exception:
                trial.set_user_attr("error", traceback.format_exc())
                return 1e6

            if result is None:
                roi = -5.0
            else:
                trades_df, _ = result
                if trades_df is None or trades_df.empty:
                    roi = -5.0
                else:
                    total_pnl = trades_df["pnl"].sum()
                    final_balance = account_size + total_pnl
                    roi = (final_balance - account_size) / account_size * 100
            save_cached_result(cache_key, roi)
        cumulative_roi += roi
        period_count += 1

    average_roi = cumulative_roi / period_count if period_count > 0 else -100.0
    return -average_roi  # Optuna는 최소화를 목표로 하므로 ROI 부호를 반전

def optimize_parameters(n_trials: int = 50) -> optuna.study.Study:
    study = optuna.create_study(direction="minimize")
    study.optimize(objective, n_trials=n_trials)
    return study

---

# backtesting/performance_metrics.py

import pandas as pd
import numpy as np

def calculate_monthly_performance(
    trades_df: pd.DataFrame,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl"
) -> pd.DataFrame:
    """
    월별(YYYY-MM) 손익, 매매 횟수, 승률을 계산하여 요약한 DataFrame을 반환합니다.
    
    매개변수:
      - trades_df: 거래 내역 DataFrame
      - exit_time_col: 거래 종료 시간 컬럼 이름 (기본: "exit_time")
      - pnl_col: 손익(PnL) 컬럼 이름 (기본: "pnl")
    """
    if exit_time_col not in trades_df.columns:
        return pd.DataFrame()

    trades_df["year_month"] = trades_df[exit_time_col].dt.to_period('M')
    grouped = trades_df.groupby("year_month")

    results = []
    for ym, grp in grouped:
        total_pnl = grp[pnl_col].sum()
        num_trades = len(grp)
        win_trades = (grp[pnl_col] > 0).sum()
        win_rate = (win_trades / num_trades * 100.0) if num_trades > 0 else 0.0

        results.append({
            'year_month': str(ym),
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })

    return pd.DataFrame(results)


def calculate_yearly_performance(
    trades_df: pd.DataFrame,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl"
) -> pd.DataFrame:
    """
    연도별(YYYY)로 손익, 매매 횟수, 승률을 계산합니다.
    
    매개변수:
      - trades_df: 거래 내역 DataFrame
      - exit_time_col: 거래 종료 시간 컬럼 이름 (기본: "exit_time")
      - pnl_col: 손익(PnL) 컬럼 이름 (기본: "pnl")
    """
    if exit_time_col not in trades_df.columns:
        return pd.DataFrame()

    trades_df["year"] = trades_df[exit_time_col].dt.year
    grouped = trades_df.groupby("year")

    results = []
    for y, grp in grouped:
        total_pnl = grp[pnl_col].sum()
        num_trades = len(grp)
        win_trades = (grp[pnl_col] > 0).sum()
        win_rate = (win_trades / num_trades * 100.0) if num_trades > 0 else 0.0

        results.append({
            'year': y,
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })

    return pd.DataFrame(results)


def calculate_mdd(
    trades_df: pd.DataFrame,
    initial_balance: float,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl"
) -> float:
    """
    MDD(최대낙폭) %를 계산합니다.
    
    매개변수:
      - trades_df: 거래 내역 DataFrame (종료 시간 컬럼을 포함)
      - initial_balance: 초기 잔고
      - exit_time_col: 거래 종료 시간 컬럼 이름 (기본: "exit_time")
      - pnl_col: 손익(PnL) 컬럼 이름 (기본: "pnl")
    """
    if exit_time_col not in trades_df.columns:
        return 0.0

    trades_df = trades_df.sort_values(by=exit_time_col)
    equity_list = []
    current_balance = initial_balance

    for _, row in trades_df.iterrows():
        current_balance += row[pnl_col]
        equity_list.append(current_balance)

    equity_arr = np.array(equity_list)
    peak_arr = np.maximum.accumulate(equity_arr)
    drawdown_arr = (equity_arr - peak_arr) / peak_arr
    mdd = drawdown_arr.min() * 100.0
    return mdd


def calculate_sharpe_ratio(
    trades_df: pd.DataFrame,
    initial_balance: float,
    risk_free_rate: float = 0.0,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl"
) -> float:
    """
    단순 Sharpe 지수를 계산합니다.
    
    매개변수:
      - trades_df: 거래 내역 DataFrame (종료 시간 컬럼을 포함)
      - initial_balance: 초기 잔고
      - risk_free_rate: 무위험 이자율 (기본: 0.0)
      - exit_time_col: 거래 종료 시간 컬럼 이름 (기본: "exit_time")
      - pnl_col: 손익(PnL) 컬럼 이름 (기본: "pnl")
    """
    if trades_df.empty:
        return 0.0

    if len(trades_df) < 2:
        return 0.0

    trades_df = trades_df.sort_values(by=exit_time_col)
    current_balance = initial_balance
    returns_list = []

    for _, row in trades_df.iterrows():
        pnl = row[pnl_col]
        ret = pnl / current_balance
        returns_list.append(ret)
        current_balance += pnl

    returns_arr = np.array(returns_list)
    if len(returns_arr) < 2:
        return 0.0

    mean_return = returns_arr.mean()
    std_return = returns_arr.std(ddof=1)
    if std_return == 0:
        return 0.0

    sharpe = (mean_return - risk_free_rate) / std_return
    return sharpe


def print_performance_report(
    trades_df: pd.DataFrame,
    initial_balance: float,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl"
) -> None:
    """
    월별, 연도별, 전체 성과(ROI, MDD, 총손익, 승률 등)를 콘솔에 출력합니다.
    
    매개변수:
      - trades_df: 거래 내역 DataFrame
      - initial_balance: 초기 잔고
      - exit_time_col: 거래 종료 시간 컬럼 이름 (기본: "exit_time")
      - pnl_col: 손익(PnL) 컬럼 이름 (기본: "pnl")
    """
    if trades_df.empty:
        print("No trades to report.")
        return

    monthly_df = calculate_monthly_performance(trades_df, exit_time_col, pnl_col)
    yearly_df = calculate_yearly_performance(trades_df, exit_time_col, pnl_col)
    total_pnl = trades_df[pnl_col].sum()
    final_balance = initial_balance + total_pnl
    mdd = calculate_mdd(trades_df, initial_balance=initial_balance, exit_time_col=exit_time_col, pnl_col=pnl_col)
    sharpe = calculate_sharpe_ratio(trades_df, initial_balance=initial_balance, exit_time_col=exit_time_col, pnl_col=pnl_col)

    print("=== (A) 월별 성과 ===")
    print(monthly_df)

    print("\n=== (B) 연도별 성과 ===")
    print(yearly_df)

    print("\n=== (C) 전체 성과 ===")
    print(f"  - 초기 잔고       : {initial_balance:.2f}")
    print(f"  - 최종 잔고       : {final_balance:.2f}")
    print(f"  - 총 손익         : {total_pnl:.2f}")
    print(f"  - ROI(%)          : {(final_balance - initial_balance) / initial_balance * 100:.2f}%")
    print(f"  - 최대낙폭(MDD)   : {mdd:.2f}%")
    print(f"  - 샤프 지수(단순) : {sharpe:.3f}")

    num_trades = len(trades_df)
    wins = (trades_df[pnl_col] > 0).sum()
    win_rate = (wins / num_trades * 100.0) if num_trades > 0 else 0.0
    print(f"  - 총 매매 횟수    : {num_trades}")
    print(f"  - 승률(%)         : {win_rate:.2f}%")

---

# backtest_validation.py

import os
import json
import pandas as pd
from backtesting.backtest_advanced import run_advanced_backtest

def main():
    # 백테스트 기본 설정
    symbol = "BTC/USDT"
    short_tf = "4h"
    long_tf = "1d"
    start_date = "2018-01-01"
    end_date   = "2025-02-01"
    
    # best_params.json 파일 읽기
    best_params_path = os.path.join(os.path.dirname(__file__), "best_params.json")
    with open(best_params_path, "r", encoding="utf-8") as f:
        best_params = json.load(f)
    
    # best_params.json 에 없는 파라미터는 기본값으로 설정합니다.
    # 예를 들어, 추세 종료(Trend Exit) 관련 파라미터가 없으면 기본값 30 사용
    default_trend_exit_lookback = 30
    
    # 백테스트 실행 시 최적 파라미터들을 적용합니다.
    result = run_advanced_backtest(
        symbol=symbol,
        short_timeframe=short_tf,
        long_timeframe=long_tf,
        window=best_params["lookback_window"],
        volume_factor=best_params["volume_factor"],
        confirm_bars=best_params["confirmation_bars"],
        breakout_buffer=best_params["breakout_buffer"],
        atr_window=best_params["atr_period"],
        atr_multiplier=best_params["atr_multiplier"],
        profit_ratio=best_params["profit_ratio"],
        account_size=10000.0,
        risk_per_trade=best_params["risk_per_trade"],
        fee_rate=0.001,
        slippage_rate=0.0005,
        taker_fee_rate=0.001,
        total_splits=best_params["total_splits"],
        allocation_mode=best_params["allocation_mode"],
        threshold_percent=best_params["scale_in_threshold"],
        use_trailing_stop=best_params["use_trailing_stop"],
        trailing_percent=best_params["trailing_percent"],
        use_trend_exit=best_params["use_trend_exit"],
        trend_exit_lookback=default_trend_exit_lookback,
        trend_exit_price_column="close",
        start_date=start_date,
        end_date=end_date,
        use_partial_take_profit=best_params["use_partial_take_profit"],
        partial_tp_factor=best_params["partial_tp_factor"],
        final_tp_factor=best_params["final_tp_factor"],
        # 장기 추세 필터 관련 파라미터
        sma_period=best_params["sma_period"],
        macd_slow_period=best_params["macd_slow_period"],
        macd_fast_period=best_params["macd_fast_period"],
        macd_signal_period=best_params["macd_signal_period"],
        rsi_period=best_params["rsi_period"],
        rsi_threshold=best_params["rsi_threshold"],
        bb_period=best_params["bb_period"],
        bb_std_multiplier=best_params["bb_std_multiplier"],
        # 리테스트 관련 파라미터
        retest_threshold=best_params["retest_threshold"],
        retest_confirmation_bars=best_params["retest_confirmation_bars"],
        # 신호 옵션 (돌파, 리테스트, 단기 보조지표)
        use_breakout_signal=best_params["use_breakout_signal"],
        use_retest_signal=best_params["use_retest_signal"],
        use_short_term_indicators=best_params["use_short_term_indicators"],
        short_rsi_threshold=best_params["short_rsi_threshold"],
        short_rsi_period=best_params["short_rsi_period"],
        # 신호 컬럼명 (기본값 사용)
        breakout_flag_col="breakout_signal",
        confirmed_breakout_flag_col="confirmed_breakout",
        retest_signal_col="retest_signal",
        long_entry_col="long_entry"
    )
    
    if result is not None:
        trades_df, trade_logs = result
        
        # 거래 요약 결과를 CSV 파일로 저장합니다.
        trades_df.to_csv("backtest_validation.csv", index=False)
        print("백테스트 결과가 'backtest_validation.csv'로 저장되었습니다.")
        
        # 거래 체결 상세 정보를 CSV 파일로 저장합니다.
        if trade_logs:
            trade_logs_df = pd.DataFrame(trade_logs)
            trade_logs_df.to_csv("trade_details.csv", index=False)
            print("거래 체결 상세 정보가 'trade_details.csv'로 저장되었습니다.")
        else:
            print("거래 체결 상세 정보가 없습니다.")
    else:
        print("매매가 발생하지 않았거나 백테스트 결과가 없습니다.")

if __name__ == "__main__":
    main()

---

# run_optimization.py
import json
from backtesting.parameter_optimization import optimize_parameters

def main():
    study = optimize_parameters(n_trials=50)
    best_trial = study.best_trial
    print("===== 최적 파라미터 =====")
    print(best_trial)
    with open("best_params.json", "w") as f:
        json.dump(best_trial.params, f, indent=4)

if __name__ == "__main__":
    main()
