코인 시장에 **systrader79**와 **김대현 저자**의 저서 *“돌파매매 전략”* 을 적용해서 자동매매 프로그램을 만들고 있어.

---
# fetch_binance_data.py

import ccxt  # 다양한 암호화폐 거래소와의 연동을 위한 라이브러리
import pandas as pd  # 데이터 분석용 라이브러리

def fetch_binance_ohlcv(symbol: str, timeframe='4h', limit=500) -> pd.DataFrame:
    """
    Binance에서 OHLCV(시가, 고가, 저가, 종가, 거래량) 데이터를 수집하고,
    이를 pandas DataFrame으로 반환합니다.
    
    :param symbol: 암호화폐 심볼(예: 'BTC/USDT')
    :param timeframe: 바이낸스가 지원하는 데이터 간격(예: '1m', '5m', '15m', '1h', '4h', '1d' 등)
    :param limit: 한 번에 가져올 캔들의 개수 (바이낸스 기준, 대개 1000개까지 가능)
    :return: 인덱스가 timestamp(날짜/시간)이고,
             컬럼으로 open, high, low, close, volume이 있는 pandas DataFrame
    """
    
    # 1) ccxt를 이용해 binance 거래소 객체 생성
    exchange = ccxt.binance()
    
    # 2) binance 거래소에서 OHLCV 데이터를 가져옵니다.
    #    fetch_ohlcv의 반환형: [[timestamp, open, high, low, close, volume], ...] 형태
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    
    # 3) 가져온 OHLCV 리스트를 pandas DataFrame으로 변환합니다.
    #    columns 인자로 컬럼 이름을 지정해서 보기 좋게 만듭니다.
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    
    # 4) timestamp가 밀리초(ms) 단위로 되어 있으므로, 이를 datetime(YYYY-MM-DD hh:mm:ss) 형태로 변환합니다.
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    
    # 5) timestamp 컬럼을 데이터프레임의 인덱스로 설정합니다.
    df.set_index('timestamp', inplace=True)
    
    # 6) open, high, low, close, volume 컬럼을 float 형태로 변환하여, 숫자로 연산 가능하게 만듭니다.
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)
    
    # 7) 혹시 중복된 인덱스(같은 timestamp 데이터)가 있다면 제거해줍니다.
    if df.index.duplicated().sum() > 0:
        df = df[~df.index.duplicated()]
    
    # 8) 데이터 중 NaN(결측치)이 있다면 해당 행을 제거하여, 분석에 문제가 없도록 합니다.
    if df.isna().any().any():
        df.dropna(inplace=True)
    
    # 9) 최종적으로 정리된 DataFrame을 반환합니다.
    return df
---
# signal_generator.py

import pandas as pd

def calculate_breakout_signals(
    df: pd.DataFrame,
    window: int = 20,
    vol_factor: float = 1.5,
    confirm_bars: int = 2,
    use_high: bool = False,
    breakout_buffer: float = 0.0
) -> pd.DataFrame:
    """
    전고점(rolling max) 돌파, 거래량 필터, 확정 돌파 시그널을 계산하는 함수입니다.
    ------------------------------------------------------------------------
    매개변수(Parameter)
    - df: 시가, 고가, 저가, 종가, 거래량 등의 정보를 담고 있는 DataFrame
    - window: '전고점' 및 '평균 거래량' 계산 시 사용할 이동 윈도우 크기 (기본값: 20)
    - vol_factor: 돌파 시 거래량이 얼마만큼(배수) 증가했는지 확인하기 위한 배수 (기본값: 1.5)
    - confirm_bars: 돌파 신호가 연속으로 몇 개의 봉에서 이어져야 '확정 돌파'로 볼지 설정 (기본값: 2)
    - use_high: True면 고가 기준, False면 종가 기준으로 돌파 판단 (기본값: False)
    - breakout_buffer: 돌파 시 (전고점 + 버퍼)의 형태로 추가 여유를 둘 때 사용 (기본값: 0.0)
    ------------------------------------------------------------------------
    반환(Return)
    - 원본 DataFrame(df)에 돌파 신호 컬럼들이 추가된 DataFrame.
      (highest_xx, breakout_signal, volume_condition, confirmed_breakout 등)
    """

    # 1) 전고점(rolling max) 계산: 과거 window개의 'high' 값 중 최댓값
    #    - 예: window=20이면 지난 20봉(캔들) 동안 가장 높았던 고가
    df[f'highest_{window}'] = df['high'].rolling(window).max()
    
    # 2) 돌파 시그널 계산: 종가 or 고가가 '전고점 + 버퍼'보다 높은지 확인
    if use_high:
        # use_high=True일 경우: 'high(고가)' 기준으로 돌파 여부 확인
        df['breakout_signal'] = df['high'] > (df[f'highest_{window}'] + df[f'highest_{window}'] * breakout_buffer)
    else:
        # use_high=False일 경우: 'close(종가)' 기준으로 돌파 여부 확인
        df['breakout_signal'] = df['close'] > (df[f'highest_{window}'] + df[f'highest_{window}'] * breakout_buffer)
    
    # 3) 거래량 조건: 과거 window봉의 평균 거래량 대비 vol_factor(배수) 이상인지 체크
    #    - 예: window=20, vol_factor=1.5 => 최근 20봉 평균 거래량의 1.5배 이상인지
    df[f'vol_ma_{window}'] = df['volume'].rolling(window).mean()  # 거래량 이동평균
    df['volume_condition'] = df['volume'] > (vol_factor * df[f'vol_ma_{window}'])
    
    # 4) '확정 돌파(confirmed_breakout)' 계산
    #    - 예: confirm_bars=2 => 돌파 신호(breakout_signal)가 연속 2봉 이상 True 이어야 확정으로 판정
    df['confirmed_breakout'] = (
        df['breakout_signal']
        .rolling(confirm_bars)               # 최근 confirm_bars 봉 범위로 rolling
        .apply(lambda x: all(x), raw=True)   # 해당 범위 내의 값이 모두 True인지 확인
        .fillna(False)                       # 첫 부분(rolling 불충분 구간)은 NaN이므로 False 처리
    )
    
    return df


def calculate_vcp_pattern(
    df: pd.DataFrame,
    window_list: list = [20, 10, 5]
) -> pd.DataFrame:
    """
    VCP(Volatility Contraction Pattern) 패턴을 단순 계산하는 함수입니다.
    ------------------------------------------------------------------------
    매개변수(Parameter)
    - df: 시가, 고가, 저가, 종가, 거래량 등의 정보를 담고 있는 DataFrame
    - window_list: 변동 폭(고가-저가)의 이동평균을 계산할 기간을 담은 리스트 (예: [20, 10, 5])
    ------------------------------------------------------------------------
    반환(Return)
    - 원본 DataFrame(df)에 VCP 관련 컬럼이 추가된 DataFrame.
      (예: range_ma_20, range_ma_10, range_ma_5, vcp_signal 등)
    """

    # 1) 각 window마다 (고가 - 저가)의 이동평균을 구함
    #    예: window=20 -> 최근 20봉의 (high - low)의 평균 (변동 폭 평균)
    for w in window_list:
        df[f'range_ma_{w}'] = (df['high'] - df['low']).rolling(w).mean()
    
    # 2) (단순한 예시)
    #    - ex) window_list = [20, 10, 5]
    #    - 세 구간의 변동 폭 평균이 큰 순서대로(20봉 > 10봉 > 5봉) '연속 감소'한다면 VCP로 판정
    w1, w2, w3 = window_list
    df['vcp_signal'] = (
        (df[f'range_ma_{w1}'] > df[f'range_ma_{w2}']) &
        (df[f'range_ma_{w2}'] > df[f'range_ma_{w3}'])
    )
    
    return df
---
# trade_logic.py

import pandas as pd
import numpy as np
import ta  # 'ta' 라이브러리는 여러 기술적 지표(ATR, RSI, MACD 등)를 제공

def apply_entry_signal(
    df: pd.DataFrame,
    entry_colname: str = 'long_entry'
) -> pd.DataFrame:
    """
    이전 단계에서 생성된 시그널(breakout_signal, volume_condition, confirmed_breakout)을 종합하여,
    최종 매수 여부(long_entry)를 확정하는 로직을 구현한 함수입니다.
    
    매개변수
    ----------
    df : pd.DataFrame
        시가, 고가, 저가, 종가, 거래량, 및 돌파 관련 시그널 등이 포함된 DataFrame
    entry_colname : str
        매수 여부를 저장할 컬럼명 (기본값: 'long_entry')
    
    반환값
    ----------
    pd.DataFrame
        원본 DataFrame에 'long_entry' 컬럼이 추가된 상태
    """
    # 예시 로직:
    # 전고점 돌파, 거래량 조건, 확정 돌파가 모두 True이면 매수 신호를 True로 설정
    df[entry_colname] = (
        (df['breakout_signal'] == True) &    # 돌파 여부
        (df['volume_condition'] == True) &   # 거래량 조건
        (df['confirmed_breakout'] == True)   # 확정 돌파
    )
    return df


def apply_stop_loss_atr(
    df: pd.DataFrame,
    atr_window: int = 14,
    atr_multiplier: float = 2.0,
    sl_colname: str = 'stop_loss_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    ATR(평균진폭)을 활용하여 손절가(stop_loss_price)를 DataFrame에 추가하는 함수입니다.
    실제 매매에서는 '진입 가격'에 기반해 손절가를 설정하는 경우가 많습니다.
    
    매개변수
    ----------
    df : pd.DataFrame
        시가, 고가, 저가, 종가 등의 기본 정보와 매수신호(long_entry) 등이 포함된 DataFrame
    atr_window : int
        ATR 계산에 사용하는 봉(캔들)의 개수 (기본값: 14)
    atr_multiplier : float
        ATR에 곱해줄 배수 (기본값: 2.0 -> '진입가 - 2*ATR' 형태의 손절가)
    sl_colname : str
        결과로 저장할 손절가 컬럼명 (기본값: 'stop_loss_price')
    entry_price_col : str
        진입가(매수가)를 저장/유지할 컬럼명 (기본값: 'entry_price')

    반환값
    ----------
    pd.DataFrame
        원본 DataFrame에 'atr', 'entry_price', 'stop_loss_price' 컬럼이 추가된 상태
    """
    # 1) ta 라이브러리의 AverageTrueRange 클래스를 이용해 ATR을 계산합니다.
    #    - high, low, close 컬럼과, atr_window(14)가 필요
    #    - fillna=True를 사용해 결측치가 생기지 않도록 처리
    atr_indicator = ta.volatility.AverageTrueRange(
        high=df['high'],
        low=df['low'],
        close=df['close'],
        window=atr_window,
        fillna=True
    )
    
    # ATR 계산 결과를 'atr' 컬럼에 저장
    df['atr'] = atr_indicator.average_true_range()
    
    # 2) entry_price: 진입 시점(= long_entry가 True인 곳)의 종가를 저장
    #    - np.where를 이용해 매수신호(True)인 지점에서는 'close'를, 
    #      아니라면 np.nan을 저장
    df[entry_price_col] = np.where(df['long_entry'], df['close'], np.nan)
    
    # 3) forward fill: 한 번 진입한 뒤에는 별도 청산 시점이 오기 전까지 
    #    같은 entry_price를 유지(단순 예시).
    #    => 이렇게 해서 전체 구간에 걸쳐 진입가가 '계속' 기록됨
    df[entry_price_col] = df[entry_price_col].ffill()
    
    # 4) 손절가 계산: 
    #    예) 손절가 = entry_price - (atr * atr_multiplier)
    df[sl_colname] = df[entry_price_col] - (df['atr'] * atr_multiplier)
    
    return df


def apply_take_profit_ratio(
    df: pd.DataFrame,
    profit_ratio: float = 0.05,
    tp_colname: str = 'take_profit_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    고정된 이익률( profit_ratio )을 사용하여 익절가(take_profit_price)를 계산하는 함수입니다.
    
    매개변수
    ----------
    df : pd.DataFrame
        매수 시그널과 진입가가 포함된 DataFrame
    profit_ratio : float
        목표 수익률 (기본값: 0.05 => 5% 수익에 익절)
    tp_colname : str
        익절가를 저장할 컬럼명
    entry_price_col : str
        진입가가 기록된 컬럼명
    
    반환값
    ----------
    pd.DataFrame
        원본 DataFrame에 익절가(take_profit_price)가 추가된 상태
    """
    # 익절가 = 진입가 * (1 + 목표 수익률)
    df[tp_colname] = df[entry_price_col] * (1 + profit_ratio)
    return df


def generate_trade_signals(
    df: pd.DataFrame,
    atr_window: int = 14,
    atr_multiplier: float = 2.0,
    profit_ratio: float = 0.05,
) -> pd.DataFrame:
    """
    종합 매매 로직을 한 번에 수행하는 함수입니다.
    1) apply_entry_signal : 매수 신호(long_entry) 확정
    2) apply_stop_loss_atr: ATR 기반 손절가(stop_loss_price) 계산
    3) apply_take_profit_ratio: 고정 이익률 기반 익절가(take_profit_price) 계산
    
    매개변수
    ----------
    df : pd.DataFrame
        돌파, 거래량, 확정 돌파 등이 포함된 DataFrame
    atr_window : int
        ATR 계산 시 사용할 봉 개수 (기본값: 14)
    atr_multiplier : float
        ATR에 곱해줄 배수 (기본값: 2.0)
    profit_ratio : float
        익절 목표 수익률 (기본값: 0.05 => 5% 수익 시 익절)
    
    반환값
    ----------
    pd.DataFrame
        원본 DataFrame에 매수 신호, 손절가, 익절가 등이 추가된 상태
    """
    # 1) 매수 신호 확정
    df = apply_entry_signal(df, entry_colname='long_entry')
    
    # 2) ATR 손절가 계산
    df = apply_stop_loss_atr(
        df,
        atr_window=atr_window,
        atr_multiplier=atr_multiplier,
        sl_colname='stop_loss_price',
        entry_price_col='entry_price'
    )
    
    # 3) 고정 이익률 기반 익절가 계산
    df = apply_take_profit_ratio(
        df,
        profit_ratio=profit_ratio,
        tp_colname='take_profit_price',
        entry_price_col='entry_price'
    )
    
    return df
---