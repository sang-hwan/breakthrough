[역할 부여]
너는 SW 전문가이자, 동시에 투자 전문가야.














[상황]
코인 시장에 **systrader79**와 **김대현 저자**의 저서 *“돌파매매 전략”* 을 적용해서 자동매매 하는 프로그램을 만들고 있어.
연 10~20% 수익을 목표로 약 200~500만원의 시드머니를 투자할 생각이야.











[참고사항1]
# data_collection/fetch_binance_data.py
# 이 파일은 바이낸스(Binance) 거래소에서 시세 데이터를 수집하는 데 사용됩니다.

import ccxt  # 다양한 거래소 API를 쉽게 사용할 수 있게 해주는 라이브러리
import pandas as pd  # 데이터 분석을 위한 라이브러리
import time  # 시간 관련 작업을 처리하기 위한 모듈
from datetime import datetime  # 날짜 및 시간을 처리하기 위한 모듈


def fetch_binance_historical_ohlcv(
    symbol: str,
    timeframe: str = '4h',
    start_date: str = '2021-01-01 00:00:00',
    limit_per_request: int = 1000,
    pause_sec: float = 1.0
) -> pd.DataFrame:
    """
    바이낸스에서 과거 데이터를 대량으로 수집하는 함수입니다.

    주요 기능:
    - 특정 시작 날짜부터 현재까지 데이터를 가져옵니다.
    - 데이터를 한 번에 'limit_per_request'만큼 가져오며,
      반복 호출로 더 많은 데이터를 수집합니다.
    - API 호출 제한을 피하기 위해 요청 사이에 대기 시간을 추가합니다.

    매개변수:
    - symbol: str
        거래 쌍을 나타냅니다. 예: 'BTC/USDT'
    - timeframe: str
        데이터 간격을 설정합니다. 예: '1m'(1분), '4h'(4시간), '1d'(1일)
    - start_date: str
        데이터 수집을 시작할 시점입니다. 예: '2021-01-01 00:00:00'
    - limit_per_request: int
        한 번 호출 시 가져올 데이터 개수입니다. 기본값은 1000입니다.
    - pause_sec: float
        연속 호출 사이에 대기할 시간(초)입니다. 기본값은 1.0초입니다.

    반환값:
    - pd.DataFrame
        날짜와 시세 데이터(open, high, low, close, volume)가 포함된 데이터프레임
    """
    # 바이낸스 거래소 객체 생성
    exchange = ccxt.binance()

    # 시작 날짜를 타임스탬프(ms 단위)로 변환
    since_ms = exchange.parse8601(start_date)

    # 수집한 데이터를 저장할 빈 리스트 생성
    all_ohlcv = []

    # 데이터 수집 반복문
    while True:
        # 바이낸스 API를 사용해 OHLCV(시세 데이터) 수집
        ohlcv = exchange.fetch_ohlcv(
            symbol=symbol,
            timeframe=timeframe,
            since=since_ms,
            limit=limit_per_request
        )

        # 불러온 데이터가 없으면 종료
        if not ohlcv:
            break

        # 가져온 데이터를 리스트에 추가
        all_ohlcv += ohlcv

        # 가장 최근 데이터의 타임스탬프를 가져와 다음 요청의 시작점으로 설정
        last_ts = ohlcv[-1][0]
        since_ms = last_ts + 1

        # API 호출 제한을 피하기 위해 대기
        time.sleep(pause_sec)

        # 마지막으로 가져온 데이터 개수가 한 번 호출의 최대 개수보다 적으면 종료
        if len(ohlcv) < limit_per_request:
            break

    # 수집된 데이터를 데이터프레임으로 변환
    df = pd.DataFrame(all_ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # 타임스탬프를 datetime 형식으로 변환
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

    # 타임스탬프를 데이터프레임의 인덱스로 설정
    df.set_index('timestamp', inplace=True)

    # 시세 데이터 컬럼들을 실수(float)형으로 변환
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)

    # 중복된 인덱스와 결측치 제거
    df = df[~df.index.duplicated()]
    df.dropna(inplace=True)

    # 최종 데이터프레임 반환
    return df


def fetch_binance_latest_ohlcv(symbol: str, timeframe: str = '4h', limit: int = 500) -> pd.DataFrame:
    """
    바이낸스에서 가장 최근 시세 데이터를 가져오는 함수입니다.

    주요 기능:
    - 지정된 개수의 최신 데이터를 가져옵니다.
    - 실시간 분석이나 단기 데이터가 필요한 경우 유용합니다.

    매개변수:
    - symbol: str
        거래 쌍을 나타냅니다. 예: 'BTC/USDT'
    - timeframe: str
        데이터 간격을 설정합니다. 예: '1m'(1분), '4h'(4시간), '1d'(1일)
    - limit: int
        가져올 데이터의 최대 개수입니다. 기본값은 500입니다.

    반환값:
    - pd.DataFrame
        날짜와 시세 데이터(open, high, low, close, volume)가 포함된 데이터프레임
    """
    # 바이낸스 거래소 객체 생성
    exchange = ccxt.binance()

    # 최신 데이터를 요청
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)

    # 데이터를 데이터프레임으로 변환
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # 타임스탬프를 datetime 형식으로 변환
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

    # 타임스탬프를 데이터프레임의 인덱스로 설정
    df.set_index('timestamp', inplace=True)

    # 시세 데이터 컬럼들을 실수(float)형으로 변환
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)

    # 중복된 인덱스와 결측치 제거
    df = df[~df.index.duplicated()]
    df.dropna(inplace=True)

    # 최종 데이터프레임 반환
    return df
---
# config/db_config.py
# 이 파일은 데이터베이스에 연결하기 위한 설정 정보를 저장합니다.

DATABASE = {
    # 데이터베이스 사용자 계정 정보
    'user': 'postgres',         # 데이터베이스 사용자 이름
    'password': '1234',         # 데이터베이스 사용자 비밀번호

    # 데이터베이스 서버 정보
    'host': 'localhost',        # 서버 주소 (localhost는 현재 컴퓨터를 의미)
    'port': 5432,               # 서버 포트 번호 (PostgreSQL의 기본 포트)

    # 데이터베이스 이름
    'dbname': 'my_trading_db'   # 연결할 데이터베이스의 이름
}
---
# data_collection/postgres_ohlcv_handler.py

from sqlalchemy import create_engine # SQL 작업을 쉽고 직관적으로 처리하는 라이브러리
import psycopg2 # PostgreSQL 데이터베이스와 직접 통신할 때 사용.
import pandas as pd # 데이터 분석 및 조작을 위한 라이브러리.
from typing import Optional # 함수 매개변수의 타입을 명시하기 위한 라이브러리.
from config.db_config import DATABASE # 데이터베이스 연결 정보를 포함한 설정 파일에서 DATABASE 정보를 가져옵니다.

# OHLCV 데이터를 PostgreSQL에 저장하는 함수입니다.
def save_ohlcv_to_postgres(df: pd.DataFrame, table_name: str = 'ohlcv_data') -> None:
    """
    OHLCV 데이터를 PostgreSQL 데이터베이스에 저장합니다.
    
    Parameters
    ----------
    df : pd.DataFrame
        OHLCV 데이터를 담고 있는 pandas DataFrame입니다.
        필요한 컬럼: timestamp(인덱스), open, high, low, close, volume.
    table_name : str
        데이터를 저장할 데이터베이스 테이블 이름. 기본값은 'ohlcv_data'입니다.
    """
    
    # 1) 데이터베이스 연결 생성
    # 데이터베이스 접속 정보를 사용하여 PostgreSQL에 연결합니다.
    conn = psycopg2.connect(
        user=DATABASE['user'],          # 사용자 이름
        password=DATABASE['password'],  # 비밀번호
        host=DATABASE['host'],          # 데이터베이스 호스트 주소
        port=DATABASE['port'],          # 데이터베이스 포트 번호
        dbname=DATABASE['dbname']       # 데이터베이스 이름
    )
    cur = conn.cursor()  # SQL 작업을 수행할 커서 생성

    # 2) 테이블 생성
    # 테이블이 존재하지 않으면 새로 생성합니다.
    create_table_query = f"""
    CREATE TABLE IF NOT EXISTS {table_name} (
        timestamp TIMESTAMP NOT NULL,       -- 데이터의 시간 정보
        open DOUBLE PRECISION,             -- 시가
        high DOUBLE PRECISION,             -- 고가
        low DOUBLE PRECISION,              -- 저가
        close DOUBLE PRECISION,            -- 종가
        volume DOUBLE PRECISION,           -- 거래량
        PRIMARY KEY (timestamp)            -- 기본 키로 timestamp를 사용
    );
    """
    cur.execute(create_table_query)  # SQL 쿼리 실행
    conn.commit()  # 변경사항 저장

    # 3) DataFrame 데이터를 테이블에 삽입
    # DataFrame의 각 행(row)을 데이터베이스에 추가합니다.
    for index, row in df.iterrows():
        insert_query = f"""
        INSERT INTO {table_name} (timestamp, open, high, low, close, volume)
        VALUES (%s, %s, %s, %s, %s, %s)
        ON CONFLICT (timestamp)
        DO NOTHING;  -- 중복된 timestamp 데이터는 무시
        """
        cur.execute(insert_query, (
            index.to_pydatetime(),  # 인덱스를 datetime 형식으로 변환
            float(row['open']),    # 시가
            float(row['high']),    # 고가
            float(row['low']),     # 저가
            float(row['close']),   # 종가
            float(row['volume'])   # 거래량
        ))
    conn.commit()  # 변경사항 저장

    # 4) 데이터베이스 연결 종료
    cur.close()  # 커서 닫기
    conn.close()  # 연결 종료

# PostgreSQL에서 OHLCV 데이터를 읽어오는 함수입니다.
def load_ohlcv_from_postgres(table_name: str = 'ohlcv_data', limit: Optional[int] = None) -> pd.DataFrame:
    """
    PostgreSQL 데이터베이스에서 OHLCV 데이터를 가져옵니다.
    
    Parameters
    ----------
    table_name : str
        데이터를 가져올 테이블 이름. 기본값은 'ohlcv_data'입니다.
    limit : Optional[int]
        가져올 데이터의 최대 개수. 기본값은 제한 없음(None)입니다.
        
    Returns
    -------
    pd.DataFrame
        OHLCV 데이터를 담고 있는 pandas DataFrame을 반환합니다.
    """
    
    # 1) SQLAlchemy 엔진 생성
    # 데이터베이스 연결 정보를 이용하여 엔진을 생성합니다.
    engine = create_engine(f"postgresql://{DATABASE['user']}:{DATABASE['password']}@{DATABASE['host']}:{DATABASE['port']}/{DATABASE['dbname']}")

    # 2) SQL 쿼리 생성
    query = f"SELECT * FROM {table_name} ORDER BY timestamp"  # 데이터를 timestamp 기준으로 정렬
    if limit:  # limit 값이 있으면 최대 limit 개수만 가져옴
        query += f" LIMIT {limit}"

    # 3) SQL 결과를 DataFrame으로 변환
    # pandas의 read_sql()을 사용하여 SQL 결과를 읽어옵니다.
    df = pd.read_sql(query, engine, parse_dates=['timestamp'])  # timestamp를 datetime 형식으로 변환

    # 4) DataFrame 인덱스 설정
    df.set_index('timestamp', inplace=True)  # timestamp를 인덱스로 설정

    # 5) DataFrame 반환
    return df
---
# data_collection/ohlcv_data_pipeline.py

# 시간 관리 및 데이터 타입을 위한 모듈
import time
from datetime import datetime
from typing import List, Optional

# 외부 파일에서 데이터 수집 및 저장 함수 가져오기
from data_collection.fetch_binance_data import (
    fetch_binance_historical_ohlcv,  # 바이낸스에서 역사적 OHLCV 데이터 수집 함수
    fetch_binance_latest_ohlcv       # 바이낸스에서 최신 OHLCV 데이터 수집 함수
)
from data_collection.postgres_ohlcv_handler import save_ohlcv_to_postgres  # 데이터 저장 함수

def collect_data_for_backtest(
    symbols: List[str],
    timeframes: List[str],
    use_historical: bool = True,
    start_date: Optional[str] = '2018-01-01 00:00:00',
    limit_per_request: int = 1000,
    latest_limit: int = 500,
    pause_sec: float = 1.0
) -> None:
    """
    Binance에서 OHLCV 데이터를 수집 후 PostgreSQL 데이터베이스에 저장하는 함수입니다.

    Parameters:
        symbols (List[str]): 데이터 수집을 원하는 암호화폐 심볼 리스트. 예: ["BTC/USDT", "ETH/USDT"]
        timeframes (List[str]): 데이터 수집을 원하는 타임프레임 리스트. 예: ["1h", "4h", "1d"]
        use_historical (bool): True면 start_date부터 모든 데이터를 수집, False면 최신 데이터만 수집.
        start_date (str, optional): 역사적 데이터 수집 시작 날짜 (UTC 기준). 기본값: '2018-01-01 00:00:00'
        limit_per_request (int): 한 번의 요청에서 가져올 데이터 수. 기본값: 1000
        latest_limit (int): 최신 데이터 수집 시 가져올 데이터 수. 기본값: 500
        pause_sec (float): 각 요청 사이의 대기 시간(초). 기본값: 1.0

    Returns:
        None
    """
    # (1) 각 암호화폐 심볼에 대해 작업 시작
    for symbol in symbols:
        # (2) 각 타임프레임에 대해 작업 시작
        for tf in timeframes:
            print(f"\n[*] Fetching {symbol} - {tf} data...")

            # 데이터 수집 단계
            if use_historical:
                # (a) 역사적 데이터 수집
                if not start_date:
                    raise ValueError("start_date는 역사적 데이터 수집에 필수입니다.")
                df = fetch_binance_historical_ohlcv(
                    symbol=symbol,
                    timeframe=tf,
                    start_date=start_date,
                    limit_per_request=limit_per_request,
                    pause_sec=pause_sec
                )
            else:
                # (b) 최신 데이터 수집
                df = fetch_binance_latest_ohlcv(
                    symbol=symbol,
                    timeframe=tf,
                    limit=latest_limit
                )

            # 테이블 이름 생성
            table_name = f"ohlcv_{symbol.replace('/', '').lower()}_{tf}"
            print(f"    -> Total Rows Fetched: {len(df)}")

            # 수집한 데이터를 PostgreSQL 데이터베이스에 저장
            save_ohlcv_to_postgres(df, table_name=table_name)
            print(f"    -> Saved to table: {table_name}")

            # 다음 요청 전 잠시 대기 (API 부하 방지)
            time.sleep(pause_sec)
---
# strategies/breakout_signal.py

import pandas as pd # Pandas 라이브러리: 데이터 분석 및 처리 도구

def calculate_breakout_signals(
    df: pd.DataFrame,
    window: int = 20,
    vol_factor: float = 1.5,
    confirm_bars: int = 2,
    use_high: bool = False,
    breakout_buffer: float = 0.0
) -> pd.DataFrame:
    """
    데이터에서 전고점 돌파, 거래량 조건, 확정 돌파 신호를 계산하는 함수입니다.

    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 데이터를 포함한 DataFrame (열: 시가, 고가, 저가, 종가, 거래량 등)
    - window (int): 전고점과 평균 거래량 계산 기준이 되는 과거 데이터 기간 (기본값: 20)
    - vol_factor (float): 거래량이 과거 평균 대비 얼마나 높은지를 결정하는 배수 (기본값: 1.5)
    - confirm_bars (int): 돌파 신호가 몇 개의 연속 봉에서 발생해야 확정 돌파로 간주할지 (기본값: 2)
    - use_high (bool): True이면 고가 기준, False이면 종가 기준으로 돌파 여부 판단 (기본값: False)
    - breakout_buffer (float): 돌파 기준에 추가 여유값 (비율) (기본값: 0.0)
    ------------------------------------------------------------------------
    반환 (Return):
    - 추가 컬럼들이 포함된 DataFrame:
      - highest_xx: window 기간 동안의 전고점
      - breakout_signal: 돌파 신호(True/False)
      - volume_condition: 거래량 조건 만족 여부(True/False)
      - confirmed_breakout: 확정 돌파 신호(True/False)
    """

    # 1. 전고점(highest_xx) 계산
    # - window 기간 동안 고가(high)의 최댓값(전고점)을 구합니다.
    # - shift(1)를 통해 현재 봉 데이터를 제외하고 계산.
    df[f'highest_{window}'] = (
        df['high'].shift(1)  # 현재 봉 제외
        .rolling(window)    # 지정한 window 기간 동안 계산
        .max()              # 해당 기간 내 최대값(전고점)
    )

    # 2. 돌파 신호(breakout_signal) 계산
    # - 주가가 (전고점 + breakout_buffer)보다 높은 경우 돌파로 간주.
    # - use_high가 True일 경우 고가(high), False일 경우 종가(close)를 기준으로 계산.
    if use_high:
        df['breakout_signal'] = df['high'] > (
            df[f'highest_{window}'] * (1 + breakout_buffer)
        )
    else:
        df['breakout_signal'] = df['close'] > (
            df[f'highest_{window}'] * (1 + breakout_buffer)
        )

    # 3. 거래량 조건(volume_condition) 계산
    # - window 기간 동안 평균 거래량(vol_ma_xx)을 계산.
    # - 현재 거래량이 평균 거래량 * vol_factor보다 큰 경우 조건 만족(True).
    df[f'vol_ma_{window}'] = (
        df['volume'].shift(1)  # 현재 봉 제외
        .rolling(window)      # 지정된 window 기간 동안 평균값 계산
        .mean()               # 평균 거래량
    )
    df['volume_condition'] = df['volume'] > (vol_factor * df[f'vol_ma_{window}'])

    # 4. 확정 돌파(confirmed_breakout) 계산
    # - 돌파 신호가 confirm_bars 기간 동안 연속 발생하면 확정 돌파(True).
    # - rolling(confirm_bars)을 사용해 연속 신호 수를 합산.
    df['confirmed_breakout'] = (
        df['breakout_signal'].rolling(confirm_bars).sum() == confirm_bars
    )

    # NaN(초기 값 없음) 처리: False로 채움
    df['confirmed_breakout'] = df['confirmed_breakout'].fillna(False)

    return df
---
# strategies/technical_indicators.py

import pandas as pd

# `ta` 라이브러리를 사용하여 기술적 지표를 계산합니다.
from ta.trend import SMAIndicator, MACD # 추세 지표(SMA, MACD 등)
from ta.momentum import RSIIndicator # 모멘텀 지표(RSI 등)
from ta.volatility import BollingerBands # 변동성 지표(볼린저 밴드 등)

# 단순 이동평균(SMA) 계산 함수
def apply_sma(
    df: pd.DataFrame,  # 시세 데이터 (DataFrame 형식)
    price_col: str = 'close',  # 사용할 가격 데이터 컬럼 (기본값: '종가')
    window: int = 20,  # 이동평균 기간 (기본값: 20일)
    fillna: bool = False,  # 결측치(NaN) 처리 여부
    colname: str = 'sma'  # 계산 결과를 저장할 컬럼 이름
) -> pd.DataFrame:
    """
    단순 이동평균(SMA)을 계산하고 DataFrame에 결과를 추가합니다.
    """
    # ta 라이브러리의 SMAIndicator 클래스 생성
    indicator = SMAIndicator(
        close=df[price_col],
        window=window,
        fillna=fillna
    )
    # 계산된 SMA 값을 새로운 컬럼으로 추가
    df[colname] = indicator.sma_indicator()
    return df

# MACD (이동평균 수렴/확산) 계산 함수
def apply_macd(
    df: pd.DataFrame,
    price_col: str = 'close',  # 사용할 가격 데이터 컬럼
    window_slow: int = 26,  # 느린 이동평균 기간
    window_fast: int = 12,  # 빠른 이동평균 기간
    window_sign: int = 9,  # 시그널선 이동평균 기간
    fillna: bool = False,  # 결측치 처리 여부
    prefix: str = 'macd_'  # 결과 컬럼 접두사
) -> pd.DataFrame:
    """
    MACD 지표를 계산하고 MACD, 시그널선, 히스토그램을 추가합니다.
    """
    # MACD 지표 생성
    macd_indicator = MACD(
        close=df[price_col],
        window_slow=window_slow,
        window_fast=window_fast,
        window_sign=window_sign,
        fillna=fillna
    )
    # 계산 결과를 DataFrame에 추가
    df[f'{prefix}macd'] = macd_indicator.macd()
    df[f'{prefix}signal'] = macd_indicator.macd_signal()
    df[f'{prefix}diff'] = macd_indicator.macd_diff()
    return df

# RSI (Relative Strength Index) 계산 함수
def apply_rsi(
    df: pd.DataFrame,
    price_col: str = 'close',  # 사용할 가격 데이터 컬럼
    window: int = 14,  # RSI 계산 기간
    fillna: bool = False,  # 결측치 처리 여부
    colname: str = 'rsi'  # 결과를 저장할 컬럼 이름
) -> pd.DataFrame:
    """
    RSI 지표를 계산하고 DataFrame에 추가합니다.
    """
    # RSIIndicator 클래스 생성
    rsi_indicator = RSIIndicator(
        close=df[price_col],
        window=window,
        fillna=fillna
    )
    # 계산된 RSI 값을 DataFrame에 추가
    df[colname] = rsi_indicator.rsi()
    return df

# 볼린저 밴드 계산 함수
def apply_bollinger(
    df: pd.DataFrame,
    price_col: str = 'close',  # 사용할 가격 데이터 컬럼
    window: int = 20,  # 이동평균 및 표준편차 계산 기간
    window_dev: float = 2.0,  # 표준편차 곱
    fillna: bool = False,  # 결측치 처리 여부
    prefix: str = 'bb_'  # 결과 컬럼 접두사
) -> pd.DataFrame:
    """
    볼린저 밴드를 계산하고 관련 데이터를 DataFrame에 추가합니다.
    """
    # BollingerBands 클래스 생성
    bb = BollingerBands(
        close=df[price_col],
        window=window,
        window_dev=window_dev,
        fillna=fillna
    )
    # 각 계산 결과를 DataFrame에 추가
    df[f'{prefix}mavg'] = bb.bollinger_mavg()  # 중간선
    df[f'{prefix}hband'] = bb.bollinger_hband()  # 상단선
    df[f'{prefix}lband'] = bb.bollinger_lband()  # 하단선
    df[f'{prefix}pband'] = bb.bollinger_pband()  # 퍼센트 밴드
    df[f'{prefix}wband'] = bb.bollinger_wband()  # 폭 밴드
    df[f'{prefix}hband_ind'] = bb.bollinger_hband_indicator()  # 상단선 접촉 여부
    df[f'{prefix}lband_ind'] = bb.bollinger_lband_indicator()  # 하단선 접촉 여부
    return df
---
# strategies/stop_loss_take_profit.py

# 데이터 분석 및 수치 연산 라이브러리
import pandas as pd
import numpy as np
import ta  # 'ta'는 ATR, RSI 등 다양한 기술적 지표를 제공하는 라이브러리

def apply_stop_loss_atr(
    df: pd.DataFrame,
    atr_window: int = 14,
    atr_multiplier: float = 2.0,
    sl_colname: str = 'stop_loss_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    ATR(평균진폭)을 기반으로 손절가(stop_loss_price)를 계산하여 DataFrame에 추가합니다.
    
    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 매수 신호(long_entry)와 가격 정보(시가, 고가, 저가, 종가 등)가 포함된 데이터.
    - atr_window (int): ATR 계산에 사용할 과거 캔들 수. 기본값: 14
    - atr_multiplier (float): 손절가 계산 시 ATR에 곱할 배수. 기본값: 2.0
    - sl_colname (str): 계산된 손절가를 저장할 컬럼명. 기본값: 'stop_loss_price'
    - entry_price_col (str): 진입가(매수가)를 저장할 컬럼명. 기본값: 'entry_price'

    반환값 (Return):
    - DataFrame: 'atr', 'entry_price', 'stop_loss_price' 컬럼이 추가된 데이터프레임.
    """

    # 1) ATR(평균진폭) 계산
    # - AverageTrueRange: 고가(high), 저가(low), 종가(close)를 사용해 변동성을 계산.
    # - window: 계산 기준이 되는 캔들 수
    atr_indicator = ta.volatility.AverageTrueRange(
        high=df['high'],
        low=df['low'],
        close=df['close'],
        window=atr_window,
        fillna=True  # 결측값 발생 방지
    )
    df['atr'] = atr_indicator.average_true_range()

    # 2) 매수 시점의 종가(entry_price) 기록
    # - 매수 신호(long_entry=True) 발생 시 종가(close)를 진입가로 설정.
    df[entry_price_col] = np.where(df['long_entry'], df['close'], np.nan)

    # 3) 진입가 유지 (forward fill)
    # - 진입 이후 익절/손절까지 동일한 진입가 유지.
    df[entry_price_col] = df[entry_price_col].ffill()

    # 4) 손절가(stop_loss_price) 계산
    # - 손절가 = 진입가 - (ATR × ATR 배수)
    df[sl_colname] = df[entry_price_col] - (df['atr'] * atr_multiplier)

    return df


def apply_take_profit_ratio(
    df: pd.DataFrame,
    profit_ratio: float = 0.05,
    tp_colname: str = 'take_profit_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    고정된 목표 수익률을 사용하여 익절가(take_profit_price)를 계산합니다.
    
    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 매수 신호와 진입가가 포함된 데이터프레임.
    - profit_ratio (float): 목표 수익률 (기본값: 0.05, 즉 5% 수익에 익절).
    - tp_colname (str): 계산된 익절가를 저장할 컬럼명.
    - entry_price_col (str): 진입가가 기록된 컬럼명.

    반환값 (Return):
    - DataFrame: 익절가(take_profit_price)가 추가된 데이터프레임.
    """

    # 익절가 계산: 진입가 × (1 + 목표 수익률)
    df[tp_colname] = df[entry_price_col] * (1 + profit_ratio)
    return df
---
# strategies/risk_management.py

import math # 수학 함수 사용을 위한 math 모듈

def calculate_position_size(
    account_balance: float,
    risk_per_trade: float,
    entry_price: float,
    stop_loss_price: float,
    fee_rate: float = 0.001
) -> float:
    """
    한 번의 매매에서 최대 손실을 제한하도록 포지션 크기를 계산하는 함수입니다.

    매개변수:
    ----------
    - account_balance (float): 계좌 잔고 (예: 10,000 USDT)
    - risk_per_trade (float): 허용 가능한 손실 비율 (예: 0.01 = 1%)
    - entry_price (float): 매수 가격
    - stop_loss_price (float): 손절 가격
    - fee_rate (float): 매수 수수료 비율 (기본값: 0.001 = 0.1%)

    반환값:
    ----------
    - float: 계산된 매수 가능 코인(또는 계약) 수량

    계산 절차:
    1. 코인 1개당 손실 금액 계산:
       `price_diff = abs(entry_price - stop_loss_price)`
    2. 최대 감당 가능 손실 금액 계산:
       `max_risk_amount = account_balance * risk_per_trade`
    3. 수수료 계산:
       `fee_amount = entry_price * fee_rate`
    4. 코인 1개당 총 손실:
       `per_unit_loss = price_diff + fee_amount`
    5. 허용 손실 금액 내에서 매수 가능한 최대 코인 수 계산:
       `position_size = max_risk_amount / per_unit_loss`
    """

    # 코인 1개당 손실 계산 (진입가와 손절가의 차이)
    price_diff = abs(entry_price - stop_loss_price)

    # 감당 가능한 최대 손실 금액
    max_risk_amount = account_balance * risk_per_trade

    # 매수 시 발생할 수수료
    fee_amount = entry_price * fee_rate

    # 코인 1개당 총 손실 계산
    per_unit_loss = price_diff + fee_amount

    # 최대 매수 가능 코인 수 계산
    if per_unit_loss > 0:
        position_size = max_risk_amount / per_unit_loss
    else:
        position_size = 0.0

    return position_size


def split_position_sizes(
    total_position_size: float,
    split_count: int = 3,
    scale_mode: str = 'equal'
) -> list:
    """
    전체 매수 물량을 여러 단계로 나누는 분할 매매 함수입니다.

    매개변수:
    ----------
    - total_position_size (float): 매수할 총 코인 수량
    - split_count (int): 매수 단계를 몇 번으로 나눌지 (기본값: 3)
    - scale_mode (str): 분할 비율 설정
        * 'equal': 균등 분할
        * 'pyramid_up': 뒤로 갈수록 매수 물량 증가
        * 'pyramid_down': 앞으로 갈수록 매수 물량 감소

    반환값:
    ----------
    - list: 각 단계별 매수 물량

    예시:
    ------
    >>> split_position_sizes(9, split_count=3, scale_mode='equal')
    [3.0, 3.0, 3.0]

    >>> split_position_sizes(9, split_count=3, scale_mode='pyramid_up')
    [1.5, 3.0, 4.5]
    """

    # 최소 1회 이상 매수를 나눌 수 있어야 함
    if split_count < 1:
        raise ValueError("split_count는 최소 1 이상이어야 합니다.")

    # 지원하지 않는 모드는 예외 처리
    if scale_mode not in ['equal', 'pyramid_up', 'pyramid_down']:
        raise ValueError("scale_mode는 'equal', 'pyramid_up', 'pyramid_down' 중 하나여야 합니다.")

    if scale_mode == 'equal':
        # 균등 분할
        split_size = total_position_size / split_count
        return [split_size] * split_count

    elif scale_mode == 'pyramid_up':
        # 피라미드 업: 뒤로 갈수록 더 많은 매수 비중
        ratio_sum = split_count * (split_count + 1) / 2  # 합계 계산 (1+2+3...)
        return [(i / ratio_sum) * total_position_size for i in range(1, split_count + 1)]

    elif scale_mode == 'pyramid_down':
        # 피라미드 다운: 앞으로 갈수록 더 많은 매수 비중
        ratio_sum = split_count * (split_count + 1) / 2
        return [(i / ratio_sum) * total_position_size for i in range(split_count, 0, -1)]
---
# backtesting/verify_signals.py

import matplotlib.pyplot as plt # 시각화를 위한 matplotlib
import pandas as pd

# 데이터베이스 및 시그널 계산 함수
from data_collection.postgres_ohlcv_handler import load_ohlcv_from_postgres
from strategies.breakout_signal import calculate_breakout_signals

def verify_breakout_signals(
    symbol: str,
    timeframe: str,
    table_name: str,
    window: int = 20,
    vol_factor: float = 1.5,
    confirm_bars: int = 2,
    use_high: bool = False,
    breakout_buffer: float = 0.0,
    plot_chart: bool = False
):
    """
    돌파 시그널 검증 및 시각화 함수.

    주요 기능:
    ----------
    1. PostgreSQL에서 (symbol, timeframe)에 해당하는 데이터를 로드.
    2. 돌파 시그널(전고점, 거래량, 확정 돌파)을 계산.
    3. 시그널이 의도대로 생성되었는지 수치적으로 검증.
    4. (선택적) 차트를 통해 시그널을 시각적으로 확인.

    매개변수:
    ----------
    - symbol (str): 자산 심볼 (예: "BTC/USDT")
    - timeframe (str): 데이터의 시간 간격 (예: "4h")
    - table_name (str): 데이터베이스 테이블명
    - window (int): 전고점 계산 기간
    - vol_factor (float): 거래량 필터 배수
    - confirm_bars (int): 확정 돌파를 위한 봉 개수
    - use_high (bool): True면 고가 기준 돌파, False면 종가 기준 돌파
    - breakout_buffer (float): 돌파 기준에 추가할 버퍼 비율
    - plot_chart (bool): True면 차트로 결과 시각화

    반환값:
    ----------
    None
    """

    print(f"\n[Verification] symbol={symbol}, timeframe={timeframe}, table={table_name}")

    # 1. 데이터 로드
    df = load_ohlcv_from_postgres(table_name=table_name)
    if df.empty:
        print(f"  -> No data loaded from table: {table_name}")
        return

    # 2. 돌파 시그널 계산
    df = calculate_breakout_signals(
        df=df,
        window=window,
        vol_factor=vol_factor,
        confirm_bars=confirm_bars,
        use_high=use_high,
        breakout_buffer=breakout_buffer
    )

    # -------------------------------
    # 3. 수치적 검증
    # -------------------------------

    # (A) breakout_signal 검증
    condition_breakout_true = (df['breakout_signal'] == True)
    error_rows = df[condition_breakout_true & 
                    (df['close'] <= df[f'highest_{window}'] * (1 + breakout_buffer))]
    if not error_rows.empty:
        print("[Warning] breakout_signal=True 이지만 실제로 돌파되지 않은 봉이 발견됨!")
        print(error_rows[['close', f'highest_{window}', 'breakout_signal']].head(10))
    else:
        print(" -> breakout_signal과 실제 가격 돌파가 일치합니다. (수치상 오차 없음)")

    # (B) volume_condition 검증
    cond_vol_true = (df['volume_condition'] == True)
    error_vol = df[cond_vol_true & (df['volume'] <= df[f'vol_ma_{window}'] * vol_factor)]
    if not error_vol.empty:
        print("[Warning] volume_condition=True 이지만 실제 거래량 조건이 만족되지 않은 봉 발견!")
        print(error_vol[['volume', f'vol_ma_{window}', 'volume_condition']].head(10))
    else:
        print(" -> volume_condition과 실제 거래량 조건이 일치합니다. (수치상 오차 없음)")

    # -------------------------------
    # 4. 차트 시각화 (선택 사항)
    # -------------------------------
    if plot_chart:
        # 최근 300개 봉만 시각화 (데이터가 많을 경우 복잡해짐)
        df_plot = df.tail(300)

        plt.figure(figsize=(12, 6))
        plt.plot(df_plot.index, df_plot['close'], label='Close', color='blue')

        # 전고점(highest_xx) 표시
        plt.plot(df_plot.index, df_plot[f'highest_{window}'], label=f"Highest({window})", linestyle='--', color='orange')

        # breakout_signal이 True인 지점에 빨간 마커
        breakout_points = df_plot[df_plot['breakout_signal'] == True]
        plt.scatter(breakout_points.index, breakout_points['close'], color='red', marker='^', label='Breakout Signal')

        # confirmed_breakout이 True인 지점에 녹색 마커
        confirmed_points = df_plot[df_plot['confirmed_breakout'] == True]
        plt.scatter(confirmed_points.index, confirmed_points['close'], color='green', marker='o', label='Confirmed Breakout')

        plt.title(f"{symbol} {timeframe} - Breakout Signal Verification")
        plt.xlabel("Time")
        plt.ylabel("Price")
        plt.legend()
        plt.show()
---
# backtesting/performance_metrics.py

# 데이터 분석과 수치 연산을 위한 라이브러리
import pandas as pd
import numpy as np

def calculate_monthly_performance(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    월별 손익(PnL), 매매 횟수, 승률을 계산하는 함수.

    주요 기능:
    ----------
    - 월(YYYY-MM) 단위로 매매 데이터를 그룹화.
    - 각 월별 총 손익, 매매 횟수, 승률을 계산.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).

    반환값:
    ----------
    - DataFrame: 월별 성과를 요약한 데이터프레임.
    """
    # 연월(YYYY-MM) 기준으로 그룹화
    trades_df['year_month'] = trades_df['exit_time'].dt.to_period('M')

    # 그룹별 성과 계산
    grouped = trades_df.groupby('year_month')
    results = []

    for ym, grp in grouped:
        total_pnl = grp['pnl'].sum()  # 총 손익
        num_trades = len(grp)        # 매매 횟수
        win_trades = (grp['pnl'] > 0).sum()  # 이긴 매매 수
        win_rate = win_trades / num_trades * 100.0 if num_trades > 0 else 0.0  # 승률 계산

        results.append({
            'year_month': str(ym),
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })

    return pd.DataFrame(results)


def calculate_yearly_performance(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    연도별 손익(PnL), 매매 횟수, 승률을 계산하는 함수.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).

    반환값:
    ----------
    - DataFrame: 연도별 성과를 요약한 데이터프레임.
    """
    # 연도별 그룹화
    trades_df['year'] = trades_df['exit_time'].dt.year
    grouped = trades_df.groupby('year')

    results = []
    for y, grp in grouped:
        total_pnl = grp['pnl'].sum()
        num_trades = len(grp)
        win_trades = (grp['pnl'] > 0).sum()
        win_rate = win_trades / num_trades * 100.0 if num_trades > 0 else 0.0

        results.append({
            'year': y,
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })

    return pd.DataFrame(results)


def calculate_mdd(trades_df: pd.DataFrame, initial_balance: float) -> float:
    """
    최대낙폭(MDD)을 계산하는 함수.

    주요 기능:
    ----------
    - 매매 기록을 순서대로 처리하여 최대낙폭(MDD)을 계산.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).
    - initial_balance (float): 초기 계좌 잔고.

    반환값:
    ----------
    - float: 최대낙폭(MDD) 값(음수, % 단위).
    """
    # 시간 순 정렬
    trades_df = trades_df.sort_values(by='exit_time')

    # 잔고 추적
    equity_list = []
    current_balance = initial_balance

    for _, row in trades_df.iterrows():
        current_balance += row['pnl']
        equity_list.append(current_balance)

    # MDD 계산
    equity_arr = np.array(equity_list)
    peak_arr = np.maximum.accumulate(equity_arr)  # 최고점 추적
    drawdown_arr = (equity_arr - peak_arr) / peak_arr  # 낙폭 계산
    mdd = drawdown_arr.min() * 100.0  # %로 변환
    return mdd


def print_performance_report(trades_df: pd.DataFrame, initial_balance: float) -> None:
    """
    전체 성과를 요약 출력하는 함수.

    주요 기능:
    ----------
    - 월별, 연도별 성과와 MDD(최대낙폭), ROI, 승률 등을 출력.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
    - initial_balance (float): 초기 계좌 잔고.

    반환값:
    ----------
    - None
    """
    if trades_df.empty:
        print("No trades to report.")
        return

    # 성과 계산
    monthly_df = calculate_monthly_performance(trades_df)
    yearly_df = calculate_yearly_performance(trades_df)
    total_pnl = trades_df['pnl'].sum()
    final_balance = initial_balance + total_pnl
    mdd = calculate_mdd(trades_df, initial_balance=initial_balance)

    # 출력
    print("=== (A) 월별 성과 ===")
    print(monthly_df)

    print("\n=== (B) 연도별 성과 ===")
    print(yearly_df)

    print("\n=== (C) 전체 성과 ===")
    print(f"  - 초기 잔고       : {initial_balance:.2f}")
    print(f"  - 최종 잔고       : {final_balance:.2f}")
    print(f"  - 총 손익         : {total_pnl:.2f}")
    print(f"  - ROI(%)          : {(final_balance - initial_balance) / initial_balance * 100:.2f}%")
    print(f"  - 최대낙폭(MDD)   : {mdd:.2f}%")

    # 매매 통계
    num_trades = len(trades_df)
    wins = (trades_df['pnl'] > 0).sum()
    win_rate = wins / num_trades * 100.0 if num_trades > 0 else 0.0
    print(f"  - 총 매매 횟수    : {num_trades}")
    print(f"  - 승률(%)         : {win_rate:.2f}%")
---
# backtesting/backtest_simple.py

import pandas as pd
import numpy as np

# 데이터베이스에서 시세 데이터를 불러오는 함수
from data_collection.postgres_ohlcv_handler import load_ohlcv_from_postgres

# 단기 돌파 전략을 위한 신호 계산 함수
from strategies.breakout_signal import calculate_breakout_signals

# 장기 보조 지표 계산을 위한 함수 (SMA, MACD, RSI, Bollinger Bands)
from strategies.technical_indicators import (
    apply_sma,  # 단순 이동평균
    apply_macd,  # 이동평균 수렴·확산
    apply_rsi,  # 상대 강도 지수
    apply_bollinger  # 볼린저 밴드
)

# 손절/익절 전략과 리스크 관리를 위한 함수
from strategies.stop_loss_take_profit import apply_stop_loss_atr, apply_take_profit_ratio
from strategies.risk_management import calculate_position_size

# 백테스트 결과를 출력하는 함수
from backtesting.performance_metrics import print_performance_report


def run_simple_backtest(
    symbol="BTC/USDT",  # 거래할 종목 (예: 비트코인/테더)
    short_timeframe="4h",  # 단기 봉 주기 (4시간)
    long_timeframe="1d",  # 장기 봉 주기 (1일)
    window=20,  # 돌파 전략에 사용할 기간
    volume_factor=1.5,  # 돌파 신호의 거래량 필터 기준
    confirm_bars=2,  # 돌파 신호 확인을 위한 추가 봉 수
    breakout_buffer=0.0,  # 돌파 신호 버퍼 (추가 여유 범위)
    atr_window=14,  # ATR(평균 진폭) 계산 기간
    atr_multiplier=2.0,  # 손절 기준 ATR 배수
    profit_ratio=0.05,  # 고정 익절 비율
    account_size=10_000.0,  # 초기 계좌 잔액
    risk_per_trade=0.01,  # 1회 매매 시 총 자산 대비 위험 비율
    fee_rate=0.001  # 거래 수수료 비율
):
    """
    다중 타임프레임 백테스트 실행 함수.

    단기 전략(4시간 봉)을 사용해 돌파 신호를 확인하고,
    장기 전략(1일 봉)으로 보조 지표를 통해 신호를 검증합니다.

    1. 단기 봉 데이터를 사용해 돌파 신호 계산
    2. 장기 봉 데이터를 통해 SMA, MACD, RSI, Bollinger Bands 조건 확인
    3. 매매 시 ATR 기반 손절과 고정 비율 익절 적용
    4. 결과를 출력하여 총 수익률, 성과 등을 확인
    """

    # -------------------------------
    # 1) 데이터 불러오기
    # -------------------------------
    # 데이터베이스에서 단기/장기 데이터를 불러옵니다.
    short_table = f"ohlcv_{symbol.replace('/', '').lower()}_{short_timeframe}"  # 단기 데이터 테이블 이름
    long_table = f"ohlcv_{symbol.replace('/', '').lower()}_{long_timeframe}"  # 장기 데이터 테이블 이름

    # 단기/장기 데이터를 로드
    df_short = load_ohlcv_from_postgres(table_name=short_table)
    df_long = load_ohlcv_from_postgres(table_name=long_table)

    # 데이터 정렬
    df_short.sort_index(inplace=True)
    df_long.sort_index(inplace=True)

    # 데이터 유효성 검사
    if df_short.empty:
        print(f"[ERROR] 단기 데이터가 비어 있습니다: {short_table}")
        return None
    if df_long.empty:
        print(f"[ERROR] 장기 데이터가 비어 있습니다: {long_table}")
        return None

    print(f"[INFO] 단기 데이터 로드 완료: {df_short.shape[0]} 행")
    print(f"[INFO] 장기 데이터 로드 완료: {df_long.shape[0]} 행\n")

    # -------------------------------
    # 2) 돌파 신호 계산 (단기 데이터)
    # -------------------------------
    # 단기 봉 데이터에서 돌파 신호를 계산합니다.
    df_short = calculate_breakout_signals(
        df=df_short,
        window=window,  # 돌파 기간
        vol_factor=volume_factor,  # 거래량 필터
        confirm_bars=confirm_bars,  # 추가 확인 봉 수
        use_high=False,  # 고점 대신 종가 기준 사용
        breakout_buffer=breakout_buffer  # 돌파 신호 버퍼
    )

    # 돌파 신호 통계 출력
    print("[단기 봉] 신호 통계:")
    print(f"  -> 돌파 신호: {df_short['breakout_signal'].sum()} 개")
    print(f"  -> 확인된 돌파: {df_short['confirmed_breakout'].sum()} 개")

    # -------------------------------
    # 3) 보조 지표 계산 (장기 데이터)
    # -------------------------------

    # (a) SMA 200 계산
    df_long = apply_sma(
        df=df_long,
        price_col='close',  # 종가를 기준으로 계산
        window=200,  # 200일 이동평균
        colname='sma200'  # 결과를 저장할 컬럼 이름
    )

    # (b) MACD 계산
    df_long = apply_macd(
        df=df_long,
        price_col='close',  # 종가 사용
        window_slow=26,  # 느린 이동평균
        window_fast=12,  # 빠른 이동평균
        window_sign=9,  # 시그널 이동평균
        prefix='macd_'  # 컬럼 접두사
    )

    # (c) RSI(14) 계산
    df_long = apply_rsi(
        df=df_long,
        price_col='close',  # 종가 기준
        window=14,  # RSI 기간
        colname='rsi14'  # 결과 저장 컬럼 이름
    )

    # (d) 볼린저 밴드 계산
    df_long = apply_bollinger(
        df=df_long,
        price_col='close',  # 종가 기준
        window=20,  # 이동평균 기간
        window_dev=2.0,  # 표준편차 배수
        prefix='bb_'  # 컬럼 접두사
    )

    # 장기 필터 조건 정의 (예시)
    df_long['long_ok'] = (
        (df_long['close'] >= df_long['sma200']) &  # SMA200 이상
        (df_long['rsi14'] < 70) &  # RSI가 과매수 상태가 아님
        (df_long['macd_diff'] > 0) &  # MACD 상승
        (df_long['close'] < df_long['bb_hband'])  # 볼린저 상단 밴드 미돌파
    )

    # -------------------------------
    # 4) 손절 및 익절 계산
    # -------------------------------
    # 단기 신호에서 손절/익절 가격 설정
    df_short['long_entry'] = df_short['confirmed_breakout'] & df_short['volume_condition']

    # ATR 기반 손절 설정
    df_short = apply_stop_loss_atr(
        df=df_short,
        atr_window=atr_window,  # ATR 기간
        atr_multiplier=atr_multiplier,  # 손절 배수
        sl_colname='stop_loss_price',  # 손절 가격 컬럼
        entry_price_col='entry_price'  # 진입 가격
    )

    # 고정 익절 비율 설정
    df_short = apply_take_profit_ratio(
        df=df_short,
        profit_ratio=profit_ratio,  # 익절 비율
        tp_colname='take_profit_price',  # 익절 가격 컬럼
        entry_price_col='entry_price'  # 진입 가격
    )

    # -------------------------------
    # 5) 백테스트 수행
    # -------------------------------
    # 거래 내역 기록용 리스트
    trades = []
    # 현재 포지션 보유 여부
    in_position = False

    # 단기 데이터를 순회하며 매매 전략 실행
    for i in range(len(df_short)):
        row_s = df_short.iloc[i]
        current_time = row_s.name  # 현재 시간(봉 기준)

        # (A) 포지션 진입
        if not in_position and row_s['long_entry']:
            # 장기 데이터에서 현재 시간까지의 데이터 가져오기
            df_long_sub = df_long.loc[:current_time]
            if df_long_sub.empty:
                continue
            row_l = df_long_sub.iloc[-1]

            # 장기 필터 조건 통과 시 매수
            if row_l['long_ok']:
                # 진입 가격, 손절/익절 설정
                entry_price = row_s['entry_price']
                stop_loss = row_s['stop_loss_price']
                take_profit = row_s['take_profit_price']

                # 포지션 크기 계산
                size = calculate_position_size(
                    account_balance=account_size,
                    risk_per_trade=risk_per_trade,
                    entry_price=entry_price,
                    stop_loss_price=stop_loss,
                    fee_rate=fee_rate
                )

                # 포지션 활성화 및 거래 기록 추가
                in_position = True
                trades.append({
                    'entry_time': current_time,
                    'entry_price': entry_price,
                    'size': size,
                    'stop_loss': stop_loss,
                    'take_profit': take_profit,
                    'exit_time': None,
                    'exit_price': None,
                    'pnl': None,
                    'exit_reason': None
                })

        # (B) 포지션 청산
        elif in_position:
            # 손절 조건 확인
            if row_s['close'] <= trades[-1]['stop_loss']:
                in_position = False
                exit_price = row_s['close']
                trades[-1].update({
                    'exit_time': current_time,
                    'exit_price': exit_price,
                    'pnl': (exit_price - trades[-1]['entry_price']) * trades[-1]['size'],
                    'exit_reason': 'stop_loss'
                })
            # 익절 조건 확인
            elif row_s['close'] >= trades[-1]['take_profit']:
                in_position = False
                exit_price = row_s['close']
                trades[-1].update({
                    'exit_time': current_time,
                    'exit_price': exit_price,
                    'pnl': (exit_price - trades[-1]['entry_price']) * trades[-1]['size'],
                    'exit_reason': 'take_profit'
                })

    # -------------------------------
    # 6) 결과 출력
    # -------------------------------
    # 거래 내역을 DataFrame으로 변환
    trades_df = pd.DataFrame(trades)
    trades_df.dropna(subset=['exit_time'], inplace=True)

    # 결과 출력
    if trades_df.empty:
        print("매매가 실행되지 않았습니다.")
        return None

    total_pnl = trades_df['pnl'].sum()  # 총 수익 계산
    final_balance = account_size + total_pnl  # 최종 계좌 잔액
    roi_percent = (final_balance - account_size) / account_size * 100.0  # 총 수익률

    # 성과 요약 출력
    print("\n=== 백테스트 결과 ===")
    print(f"총 거래 수: {len(trades_df)}")
    print(f"총 수익: {total_pnl:.2f} USDT")
    print(f"최종 계좌 잔액: {final_balance:.2f} USDT")
    print(f"수익률: {roi_percent:.2f}%")

    # 성과 세부 지표 출력 (월별 성과 등)
    print_performance_report(trades_df, initial_balance=account_size)

    return trades_df
---
# backtesting/param_tuning.py

import itertools  # 파라미터 조합을 만들기 위한 라이브러리
import pandas as pd  # 데이터 처리를 위한 라이브러리

# 단순 백테스트 함수 임포트
from backtesting.backtest_simple import run_simple_backtest
# 성과 지표 계산 함수 임포트
from backtesting.performance_metrics import calculate_mdd

def param_sweep_test():
    """
    여러 가지 전략 파라미터 조합(window, atr_multiplier, profit_ratio)을 테스트하여,
    각 조합의 백테스트 결과를 요약한 데이터프레임을 반환합니다.
    """
    # -------------------------------
    # (A) 테스트할 파라미터 정의
    # -------------------------------
    # 전략에서 조정할 파라미터 리스트
    window_list = [10, 20, 30]  # 돌파 신호를 위한 기간
    atr_list = [1.5, 2.0]  # ATR(평균 진폭) 배수: 손절 기준 설정
    profit_ratio_list = [0.03, 0.05]  # 고정 익절 비율

    # 결과를 저장할 리스트
    results = []

    # itertools.product를 사용해 모든 파라미터 조합 생성
    for window, atr_mult, pr in itertools.product(window_list, atr_list, profit_ratio_list):
        print(f"\n[Running] window={window}, atr_multiplier={atr_mult}, profit_ratio={pr}")

        # -------------------------------
        # (B) 각 조합에 대해 백테스트 실행
        # -------------------------------
        trades_df = run_simple_backtest(
            symbol="BTC/USDT",  # 거래 종목 (비트코인/테더)
            short_timeframe="4h",  # 단기 봉 주기 (4시간)
            long_timeframe="1d",  # 장기 봉 주기 (1일)
            window=window,  # 돌파 신호를 위한 기간
            volume_factor=1.5,  # 거래량 필터
            confirm_bars=2,  # 추가 확인 봉 수
            breakout_buffer=0.0,  # 돌파 신호 버퍼
            atr_window=14,  # ATR 계산 기간
            atr_multiplier=atr_mult,  # 손절 기준 ATR 배수
            profit_ratio=pr,  # 익절 비율
            account_size=10_000.0,  # 초기 계좌 잔액
            risk_per_trade=0.01,  # 1회 거래 시 총 자산 대비 위험 비율
            fee_rate=0.001  # 거래 수수료 비율
        )

        # 백테스트 결과가 없거나 거래가 발생하지 않은 경우, 다음 조합으로 넘어감
        if trades_df is None or trades_df.empty:
            continue

        # -------------------------------
        # (C) 성과 지표 계산
        # -------------------------------
        initial_balance = 10_000.0  # 초기 자산

        # 총 손익 (PnL)
        total_pnl = trades_df['pnl'].sum()
        final_balance = initial_balance + total_pnl  # 최종 잔액 계산
        roi_percent = (final_balance - initial_balance) / initial_balance * 100.0  # ROI 계산

        # 최대 낙폭(MDD)
        mdd_percent = calculate_mdd(trades_df, initial_balance=initial_balance)

        # 승률 계산
        num_trades = len(trades_df)  # 총 거래 수
        wins = (trades_df['pnl'] > 0).sum()  # 수익 거래 수
        win_rate = wins / num_trades * 100.0 if num_trades > 0 else 0.0  # 승률 (%)

        # -------------------------------
        # (D) 결과를 정리해 리스트에 저장
        # -------------------------------
        results.append({
            'window'        : window,  # 돌파 신호 기간
            'atr_multiplier': atr_mult,  # ATR 배수
            'profit_ratio'  : pr,  # 익절 비율
            'num_trades'    : num_trades,  # 총 거래 수
            'win_rate(%)'   : round(win_rate, 2),  # 승률 (%)
            'final_balance' : round(final_balance, 2),  # 최종 잔액
            'ROI(%)'        : round(roi_percent, 2),  # 수익률 (%)
            'MDD(%)'        : round(mdd_percent, 2),  # 최대 낙폭 (%)
        })

    # -------------------------------
    # (F) 결과를 데이터프레임으로 변환 후 반환
    # -------------------------------
    results_df = pd.DataFrame(results)
    return results_df  # 최종 결과를 호출부로 반환
---
# test.py

import pandas as pd  # 데이터 처리를 위한 라이브러리
# 파라미터 조합 테스트 함수 임포트
from backtesting.param_tuning import param_sweep_test

# 메인 함수 정의
def main():
    """
    파라미터 조합 테스트를 실행하고 결과를 CSV로 저장하며,
    ROI 기준 상위 5개의 결과를 출력합니다.
    """

    # -------------------------------
    # 1) 파라미터 조합 테스트 실행
    # -------------------------------
    # param_sweep_test 함수 호출 → 백테스트 실행 및 결과 반환
    results_df = param_sweep_test()

    # 결과가 비어 있으면 처리 중단
    if results_df.empty:
        print("\nNo valid results returned.")  # 유효한 결과 없음 메시지 출력
        return

    # -------------------------------
    # 2) 결과를 CSV 파일로 저장
    # -------------------------------
    csv_filename = "param_sweep_results_with_metrics.csv"  # 저장할 파일 이름
    results_df.to_csv(csv_filename, index=False, encoding='utf-8-sig')  # 파일 저장
    print(f"CSV saved: {csv_filename}")  # 저장 완료 메시지 출력

    # -------------------------------
    # 3) ROI 기준 상위 5개 결과 출력
    # -------------------------------
    # ROI(%) 열을 기준으로 결과를 내림차순 정렬
    sorted_df = results_df.sort_values(by='ROI(%)', ascending=False)
    
    # 정렬된 데이터프레임의 상위 5개 출력
    print("\n=== Top 5 by ROI ===")
    print(sorted_df.head(5))

# 이 스크립트가 직접 실행될 때만 main() 함수를 호출
if __name__ == "__main__":
    main()
---
window,atr_multiplier,profit_ratio,num_trades,win_rate(%),final_balance,ROI(%),MDD(%)
10,1.5,0.03,13,69.23,11048.51,10.49,-1.98
10,1.5,0.05,13,69.23,11794.65,17.95,-1.92
10,2.0,0.03,12,75.0,10853.27,8.53,-1.87
10,2.0,0.05,12,75.0,11326.39,13.26,-1.85
20,1.5,0.03,8,62.5,10521.09,5.21,-2.07
20,1.5,0.05,8,50.0,10453.5,4.54,-2.06
20,2.0,0.03,8,75.0,10600.97,6.01,-1.92
20,2.0,0.05,8,62.5,10549.13,5.49,-1.92
30,1.5,0.03,8,62.5,10521.09,5.21,-2.07
30,1.5,0.05,8,50.0,10453.5,4.54,-2.06
30,2.0,0.03,8,75.0,10600.97,6.01,-1.92
30,2.0,0.05,8,62.5,10549.13,5.49,-1.92


















[참고사항2]
아래는 **복잡한 백테스트 로직**을 **단계별**로 구축해나갈 때 유용한 **가이드라인**입니다.  
(실무 경험상, 이런 과정을 밟으면 “큰 그림이 어지럽지 않게” 조금씩 확장해나갈 수 있습니다.)

---

## 1. 가장 ‘단순한’ 버전부터 시작

1. **단순 로직(예: 단일 타임프레임, 단일 심볼, 고정 파라미터)** 으로 먼저 백테스트 시스템을 ‘완성’해보세요.  
   - 예) “BTC/USDT, 4시간봉”에서 “전고점 돌파 & 거래량 필터” + “ATR 손절 & 5% 익절” 정도의 **아주 단순한** 전략.  
   - 여기서도 “시그널 계산 → 포지션 진입 → (손절/익절) → 청산”이 최소한으로 동작하면 됩니다.  

2. **백테스트 엔진(루프) 골격** 잡기  
   - 캔들(OHLCV)을 한 봉씩 순회하며,  
     - (a) 포지션 보유 중이면 손절·익절 체크,  
     - (b) 보유 중이 아니면 시그널 체크, → 진입  
     - (c) 거래 내역(진입·청산 로그) 및 잔고 변동 기록  
   - 한 번 이 기본 틀만 돌아가도, `최종 수익률`, `승률`, `손익비` 등 지표를 계산할 수 있게 됩니다.  

3. **단순 버전도 ‘완성’**이 중요  
   - 흔히 “이것도 넣어야지, 저것도 넣어야지” 하다가 정작 “동작하는 코드”를 못 만드는 경우가 많습니다.  
   - 일단 **단일 타임프레임 + 단일 심볼 + 고정 파라미터**로,  
     - **(a) 백테스트 결과가 정상적으로 나오는지**,  
     - **(b) 매수·매도 시점이 엑셀·차트로 검증했을 때 맞는지**  
   - 를 먼저 확인하면, 자신감도 생기고 전반적인 구조도 파악이 쉬워집니다.

####################################################################################################
## 1 단계와 2 단계 사이의 추가적인 점검/보완 
단순 버전(backtest_simple.py)까지 일단 “제대로 돌아가는 코드”를 완성하셨다면, **큰 흐름상 바로 ‘다중 타임프레임(MTF) 확장’으로 넘어가도 무방**합니다.  
다만, **실무 경험상** 다음과 같은 **중간 점검/보완**을 거친 뒤에 넘어가면, 이후 단계에서 훨씬 수월해집니다.

---

## 1) 현재 단순 버전의 **정상 동작** 여부를 더 꼼꼼하게 검증

1. **매수·매도 시점(시그널) 점검**  
   - 예: 2019~2020년 특정 상승장 구간을 구체적으로 골라,  
     - **차트**(TradingView 등)로 실제 BTC 가격 움직임을 확인하고,  
     - 백테스트 결과 매수·매도가 발생한 구간이 과연 “전고점 돌파”와 맞아떨어지는지 **핸드체크**  
   - 이렇게 눈으로 여러 구간을 대조해보면, 돌파 계산(rolling/shift)이나 익절·손절(ATR / 5%) 로직이 **의도대로** 동작하는지 확신을 가질 수 있습니다.

-> 결론:
자동 검증(verify_signals.py) 결과, “돌파 시그널이 실제 데이터와 오차 없이 일치한다”는 메시지가 나왔고, 차트에서도 신호가 의도한 대로 찍혀 있음을 확인할 수 있습니다.
이는 (상황1)에서 원하는 **‘시그널 로직이 정말 의도대로 동작하는지 검증’**이 제대로 수행되었다는 의미이므로, 다음 단계(월별·연도별 성과, 파라미터 튜닝 등)로 넘어가시면 됩니다.

2. **추가적인 지표(월별/연도별 손익, MDD 등) 계산**  
   - “최종 잔고가 얼마다”만 보고 넘어가기보다는,  
   - **연도별 혹은 월별 성과**, 최대낙폭(MDD), 승률, 손익비(RR) 등도 함께 봐야 합니다.  
   - 예를 들어, 특정 해(또는 특정 구간)에 큰 손실이 난다면, 그 원인이 무엇인지 파악할 필요가 있습니다.

-> 결론:
큰 추세(2019~2020 상승장 등)에는 수익을 크게 내고, 일부 구간(예: 2018, 2022)에는 손실이 발생하며,
전반적으로 약 **45%**의 최종 수익률, 낮은 MDD(-5.05%)로, 안정적이나 폭발적이지는 않은 성장을 달성한 결과로 보입니다.
세부 지표(연도별·월별 성과, 승률, MDD) 역시 크게 이질적인 구간이 없으므로, “월별·연간 성과 및 MDD 확인”은 정상적으로 마무리되었다고 볼 수 있습니다.
---

## 2) (옵션) 파라미터 튜닝(Param Sweep) 간단 시도

현재 단일 파라미터로 `window=20`, `atr_multiplier=2.0`, `profit_ratio=0.05` 등이 고정되어 있을 텐데,  
- `window`를 10/20/30, `atr_multiplier`를 1.5/2.0/2.5 식으로 몇 가지만 바꿔가며,  
- **“여러 후보 파라미터” → 백테스트 결과를 비교**해보는 작업을 해도 좋습니다.

이 과정을 통해서
- “단순버전에서 내 전략이 어떤 파라미터 조합에서 가장 나은가?”  
- “극단적 파라미터로 넣었을 때 이상한 결과가 나오지 않는가?”  

등을 확인할 수 있습니다.  
물론 **과최적화**를 피하려면, 이 튜닝 작업도 어디까지 할지 적절한 선에서 마무리해야겠지만,  
**MTF 확장 전에** 한 번쯤 해보면 코드 안정성/유연성을 더 잘 느낄 수 있습니다.

-> 결론:
가장 높은 ROI: (window=10, atr_multiplier=1.5, profit_ratio=0.05) → 66.14%
공격적 매매(잦은 진입/청산 + 짧은 손절 + 큰 익절폭)
MDD -7.19%, 승률 48.82%

전반적 트렌드:
ATR 배수 1.5가 대체로 ROI를 높임 (적극적 손절)
**익절(0.05)**가 0.03보다 큰 수익을 냄 (추세 이어갈 때 더 많은 이익)
window=10이 가장 공격적, window=30은 좀 더 보수적

주의:
과최적화(Overfitting) 가능성을 반드시 염두에 두어야 함
“높은 ROI” 조합이 실전에서 좋은 성과를 낸다는 보장은 없음 (슬리피지, 수수료 증가, 시장 변동성 변화 등)
워크포워드(Out-of-Sample) 검증, 실시간 모의매매 등을 통해 추가 확인이 필요

추가 지표
연속 손실 횟수, 손익비(R:R), 최대 승률 / 최소 손익률 구간 등도 검토
실제 투자 성향(고승률 vs 고수익 vs 안정성)에 따라 최적 조합이 달라질 수 있음

단순 ROI만 보면 (10, 1.5, 0.05)가 가장 강력.
그러나 안정성 면에서 window=20 or 30 + atr_multiplier=1.5도 충분히 매력적 (ROI 50% 전후, MDD -5% 내외).
최종 선택 전 추가 검증 & 개인 성향 고려가 필수.
####################################################################################################

---

## 2. 다중 타임프레임(MTF)로 확장

1. **데이터 수집 측면**  
   - 이미 4시간봉(예)만 있던 것을, “1일봉, 1시간봉” 등 원하는 타임프레임을 추가로 DB에 쌓거나, CSV로 준비.  

2. **시그널 계산 측면**  
   - “하이타임프레임(예: 1일봉) 추세 확인 → 로우타임프레임(예: 4시간봉) 돌파 시그널만 매매” 같은 로직이 많습니다.  
   - 구현 방식은 크게 두 가지:
     - (A) **단일 DataFrame**에 여러 타임프레임 데이터를 병합(merge)하여, “일봉 지표 컬럼”, “4시간봉 지표 컬럼”을 같이 가지고 있음.  
     - (B) **각 타임프레임별로 별도 DataFrame**을 유지하고, 백테스트 중에 시간 축을 맞춰가며(동기화) 참조.  

3. **백테스트 루프에서의 처리**  
   - “이번 4시간봉 시점에, 일봉에서의 (MA, MACD 등) 최근 값은 무엇인가?”를 찾아 반영.  
   - 데이터 인덱스/타임스탬프를 맞춰서 다룰 수 있어야 하므로, **리샘플링**이나 **정렬**이 필요할 수 있습니다.  

4. **차근차근**  
   - 처음부터 여러 타임프레임 다 쓰려면 복잡도가 확 올라가니,  
   - **(1일봉 시그널) + (4시간봉 매매 타이밍)** 같은 2개 TF 조합부터 시도해보면 좋습니다.

####################################################################################################
## 2. 다중 타임프레임(MTF)로 확장 상세
아주 자연스러운 확장 플로우 같습니다. 전체 구조를 크게 변경하지 않고, **단기(돌파 신호) + 장기(보조지표 필터)** 방식으로 발전시키는 방향이군요. 각 항목별로 검토 의견을 드릴게요.

---

## 1. `signal_generator.py` 파일명 변경

- `signal_generator.py`는 현재 “돌파매매 시그널을 계산하는” 로직에 집중되어 있으므로,  
  - 예: `breakout_signal.py`, `breakout_strategy.py`, `breakout_signals.py` 등 **돌파 전략**임이 드러나는 이름으로 바꾸면 좋겠습니다.  
- 만약 “다양한 시그널(돌파, 추세, 스윙 등)을 모두 계산”하고 싶다면, 범용적인 `signal_generator.py`가 나쁘지 않을 수도 있지만,  
- “돌파 전략에 특화된 파일”이라면 이름을 변경하는 게 가독성에 유리합니다.

---

## 2. `strategies` 디렉토리에 “보조지표 계산 모듈” 추가

- 현재 `strategies` 폴더 아래에 **ATR 손절, 고정익절, 리스크 관리** 등이 분리되어 있듯이,  
- **MA, MACD, RSI, 볼린저 밴드** 등의 “기술 지표” 계산 로직을 하나의 파일에 모아서 두면, 재사용성이 높아지고 깔끔해집니다.
- 예) `technical_indicators.py` 파일 안에,
  ```python
  def calculate_ma(df: pd.DataFrame, window: int=20):
      ...
  def calculate_macd(df: pd.DataFrame, fast=12, slow=26, signal=9):
      ...
  def calculate_rsi(df: pd.DataFrame, window=14):
      ...
  def calculate_bollinger(df: pd.DataFrame, window=20, nb_std=2):
      ...
  ```
- 다만, 외부 라이브러리(`ta` 등)를 적극 활용하면, 직접 구현 로직을 줄일 수 있습니다. 필요하다면 내부 계산 방식을 커스터마이징할 수도 있겠죠.

---

## 3. `backtest_simple.py`에서 MTF 로직으로 수정

- 현재 코드는 “단일 타임프레임”만 받아서 백테스트를 수행하지만,  
- 새로 만든 지표 모듈(장기 지표) + 돌파 매매 시그널(단기 지표)을 함께 사용하려면 **2개 이상의 타임프레임**을 불러와야 합니다.

### 3-1) 단기프레임(LTF) + 장기프레임(HTF) 입력 구조

- 예:  
  ```python
  def run_simple_backtest(
      symbol="BTC/USDT",
      short_timeframe="4h",
      long_timeframe="1d",
      ...
  ):
      # 1) 단기(4h) 데이터 & 장기(1d) 데이터 불러오기
      # 2) 장기프레임 DF에 (MA, MACD, RSI, etc.) 계산
      # 3) 단기프레임 DF에 “돌파 시그널” 계산
      # 4) 백테스트 루프에서 둘 다 확인 → 진입 여부 결정
      ...
  ```
- 내부에서 `load_ohlcv_from_postgres(...)`를 두 번 호출하여 `df_short`, `df_long`를 각각 가져와 쓰면 됩니다.

### 3-2) “단기에서 시그널 발생 시 → 장기 지표 체크” 방법

- (1) **단기프레임**을 순회(캔들 by 캔들)  
- (2) 돌파 신호가 True라면,  
  - 현재 단기 봉 시간(`row_short.name`)에 해당하는 장기봉의 **최근 확정 값**을 `df_long`에서 찾는다.  
  - 이때 보조지표(예: MA>0, RSI<70, MACD 시그널>0, etc.)가 조건에 부합하면 → 최종 매수 신호  
- (3) 진입 후 손절/익절도 기존과 동일하게 처리.  

> 구체 코드는 [이전 답변](https://example.com/...)에서 언급된 “다중 타임프레임(HTF/LTF)을 분리해서 참조” 로직과 동일합니다.  
> 핵심은 “단기봉 시간과 가장 가까운 장기봉 데이터를 `loc[:time].iloc[-1]`로 찾는다.” 입니다.

---

## 4. `param_tuning.py` 수정

- `param_sweep_test()` 등에서 `run_simple_backtest()`를 호출할 때,  
  - “단일 `timeframe`” 만 넘겨주던 부분을 → “`short_timeframe`, `long_timeframe`” 같이 변경해야 합니다.  
- “장기프레임”용 파라미터(예: MA기간, MACD설정 등)를 추가하려면,  
  - `itertools.product(...)`에서 **해당 변수들을 함께 스윕**하거나,  
  - 일단은 단기 파라미터만 튜닝하고, 장기 파라미터는 고정(예: MA20)으로 놓을 수도 있습니다.  
- 구현 범위를 어떻게 잡느냐에 따라 `param_tuning.py`가 꽤 복잡해질 수 있습니다.  
  - 가령, `window_list=[10,20,30]` × `atr_list=[1.5,2.0]` × `profit_ratio_list=[0.03,0.05]` × **`ma_period_list=[20,50]`** ... 이런 식으로 늘어날 수 있으니 주의하세요.

---

## 5. `test.py` 수정

- `test.py`에서 `param_sweep_test()`를 실행하는 부분에서,  
  - “단일 timeframe”을 넘기던 것을 → “short_timeframe, long_timeframe” 2개 이상으로 수정,  
  - 또는 `param_sweep_test()` 내부에서 “다중 타임프레임”을 돌리는 로직을 추가해야 합니다.  
- 만약 기존 코드를 그대로 두면, `backtest_simple.py`의 함수 인자가 바뀌면서 에러가 날 수 있으니 반드시 함께 수정해줘야 합니다.  

---

## 결론

1. **파일명 변경** (`signal_generator.py` → `breakout_signals.py` 등)은 좋은 아이디어입니다.  
2. **보조지표** 모듈(`technical_indicators.py` 등)을 만드는 것도 깔끔한 구조를 위해 권장합니다.  
3. **MTF 로직**으로 `backtest_simple.py`를 확장할 때는, “(단기)돌파 신호 → (장기)지표 체크” 순서가 핵심입니다.  
4. 이후, **`param_tuning.py` + `test.py`**도 같이 수정해야 정상 동작하겠지요.

전반적으로 **단계별**로 잘 잡으신 계획이라 문제 없어 보입니다.  
- **1차**로는 “MTF 백테스트”가 제대로 작동만 해도 큰 진전입니다.  
- **2차**로는 파라미터 튜닝까지 가면, 다소 코드가 복잡해질 수 있으니 구조화(함수/클래스/모듈 분리)를 계속 유지해 주세요.

이렇게 진행하시면 무난히 확장 가능합니다. 파이팅입니다!
####################################################################################################

---

## 3. 과적합 방지

1. **과적합(Overfitting)**이란?  
   - 백테스트 결과는 ‘과거 데이터’에서 최적화되었지만, 실제 미래 시장에서는 성과가 기대에 미치지 못하는 현상.  
   - 파라미터를 너무 많이 혹은 너무 세밀하게 튜닝하면 발생 확률이 커짐.

2. **대표적 방법**  
   1) **Out-of-Sample(검증 구간) 분리**  
      - 과거 5년치 데이터 중 3년은 훈련(파라미터 최적화), 나머지 2년은 검증(테스트) 구간으로 나누어, 최적 파라미터를 검증 구간에 적용해보는 방식.  
   2) **Walk-Forward Analysis(워크포워드)**  
      - 일정 기간(예: 1년) 간 데이터를 학습해 파라미터를 정하고, 그 파라미터로 다음 3개월(실전)에 적용 → 성과 기록. → 다음 구간으로 넘어가 반복.  
   3) **Cross Validation**  
      - 여러 시계열 구간을 겹치지 않게 나누어 각각 성능을 평가.  
   4) **복잡도 줄이기**  
      - 파라미터 개수를 너무 많이 두지 않고(단순화), “기초적 로직” 위주로 전략을 설계.

3. **테스트 자동화**  
   - 백테스트 스크립트를 짜놓고, 파라미터 여러 후보(예: window=10,20,30 / atr_multiplier=1.5,2.0,2.5 …)에 대해 일괄 실행시키면서,  
   - Out-of-Sample 구간 성능이 가장 좋은 쪽을 찾거나, 여러 지표(승률, MDD, Profit Factor 등)를 비교해서 최종 선택.

---

## 4. 동적 파라미터 조정(Adaptive Parameter)

1. **정적 파라미터** 예  
   - (예) 돌파기간 `window=20`, ATR배수 `atr_multiplier=2.0`, 거래량 배수 `vol_factor=1.5` …  
   - 백테스트 시, 하나씩 바꿔가며 실험(브루트포스) → 최적값 찾기(파라메트릭 스윕).  
   - 이 단계까지만 해도 충분히 할 일이 많습니다.

2. **동적(Adaptive) 파라미터**  
   - 시간 경과나 시장 상황에 따라 파라미터를 실시간으로 변경하는 기법. (예: 변동성이 높아지면 window를 줄이고, 낮아지면 늘린다 등)  
   - 구현 방식:  
     - 백테스트 루프 속에서, 일정 주기(예: 매 N 봉)마다 시장 상태를 판단 → 파라미터 재설정.  
     - 또는, 일봉 지표나 VIX(파생상품) 등으로 변동성 지표를 측정해, “ATR 높으면 돌파기간 단축” 같은 규칙을 세움.

3. **단계적 접근**  
   - 먼저 “정적 파라미터 전략”을 충분히 시험해보고, 그 이후 “어떤 기준으로 파라미터를 동적으로 바꿀지” 규칙을 구체화.  
   - 동적 파라미터는 구현 복잡도 + 과적합 가능성도 올라가기 때문에, 주의 깊게 진행해야 합니다.

---

## 5. 페이퍼 트레이딩(실전 모의)

1. **백테스트 → 실전 적용 전**  
   - 한두 달 정도 “실시간 모의매매(페이퍼 트레이딩)”를 운영해보면,  
   - 백테스트와 실제 시장 흐름의 차이(슬리피지, 재정거래, API 지연 등)를 체감할 수 있음.

2. **실시간 데이터 처리**  
   - 백테스트는 과거 데이터 일괄처리지만, 페이퍼 트레이딩은 **실시간으로 들어오는 시세**를 받으며, 매 봉이 끝날 때마다 전략을 수행.  
   - 구조적으로는 “백테스트의 루프”가 “실시간 스케줄러(혹은 이벤트)”로 바뀐 형태.  

3. **주문 체결 시뮬레이션**  
   - 페이퍼 트레이딩에서, 거래소 API를 통해 ‘가상 주문’만 넣고, 체결 여부를 mock(모의) 처리.  
   - 이 과정을 통해, **“전략이 실제 시장의 체결 지연, 가격 변동을 어느 정도 감안 가능한지”** 점검 가능.

---

## 6. 정리 (추천 순서)

1. **가장 단순 버전**의 백테스트 엔진부터 만든다.  
   - 단일 타임프레임, 단일 심볼, 고정 파라미터  
   - 시그널 + 포지션 관리 + 매매 기록 + 성과 지표 계산

2. **실제 잘 동작하는지**(논리검증) → 차트로 시각화하여 “여기서 매수, 여기서 매도”가 맞는지 확인.  
   - 이렇게 작은 단위라도 실질적으로 ‘완성’된 상태를 먼저 얻어야 합니다.

3. **다중 타임프레임** → 하나씩 확장  
   - 데이터 병합/인덱스 동기화  
   - 백테스트 루프에서 “(고차원) 일봉 지표”와 “(저차원) 4시간봉 시그널” 함께 활용

4. **파라미터 튜닝 / 동적 파라미터**  
   - 처음엔 정적 튜닝부터 → 나중에 동적 로직으로 발전  
   - 워크포워드/Out-of-Sample을 통해 과적합 방지

5. **페이퍼 트레이딩**  
   - 실시간 시장 데이터를 받아 모의체결  
   - 슬리피지, 수수료 등을 좀 더 현실적으로 반영해보고, 결과를 확인

6. (최종) **실거래**  
   - 소액으로 시도 → 점차 확대

---

## 결론

- **단계별로 확장**하면 충분히 할 수 있습니다.  
- 처음부터 모든 기능(다중 타임프레임, 동적 파라미터, 과적합 방지 등)을 한 번에 구현하려고 하면 **복잡도가 기하급수적으로 상승**해서 혼란에 빠지게 됩니다.  
- **“단순한 버전”**을 일단 **빈틈없이 동작**시키고 → **하나씩** 확장하는 방식이,  
  - 학습 효율도 높고,  
  - 디버깅/유지보수도 용이하며,  
  - 결국엔 더 빨리 완성할 수 있는 지름길입니다.  

이런 순서대로 진행해보시면, 중간 중간에 “내가 어떤 부분을 해야 하지?”라는 막막함이 훨씬 줄어드실 거예요.  


















[지시사항]
"참고사항1"은 "참고사항2"의 "## 2. 다중 타임프레임(MTF)로 확장" 까지 진행한 코드야.
진행이 잘이뤄지고 있는지 확인해줘.
이제 "참고사항2"의 "3. 과적합 방지" 를 진행해야될 차례야.
그런데 어떻게 해야될지 감이 안와서 너가 단계별로 도와줬으면해.