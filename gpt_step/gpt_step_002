[상황]
코인 시장에 **systrader79**와 **김대현 저자**의 저서 *“돌파매매 전략”* 을 적용해서 자동매매 하는 프로그램을 만들고 있어.
연 10~20% 수익을 목표로 약 200~500만원의 시드머니를 투자할 생각이야.











[참고사항1]
아래 코드에 대해 비전문가도 이해할 수 있게 달아줘.
그리고 보기 좋게 주석 정리해줘.
---
# data_collection/fetch_binance_data.py
# 이 파일은 바이낸스(Binance) 거래소에서 시세 데이터를 수집하는 데 사용됩니다.

import ccxt  # 다양한 거래소 API를 쉽게 사용할 수 있게 해주는 라이브러리
import pandas as pd  # 데이터 분석을 위한 라이브러리
import time  # 시간 관련 작업을 처리하기 위한 모듈
from datetime import datetime  # 날짜 및 시간을 처리하기 위한 모듈


def fetch_binance_historical_ohlcv(
    symbol: str,
    timeframe: str = '4h',
    start_date: str = '2021-01-01 00:00:00',
    limit_per_request: int = 1000,
    pause_sec: float = 1.0
) -> pd.DataFrame:
    """
    바이낸스에서 과거 데이터를 대량으로 수집하는 함수입니다.

    주요 기능:
    - 특정 시작 날짜부터 현재까지 데이터를 가져옵니다.
    - 데이터를 한 번에 'limit_per_request'만큼 가져오며,
      반복 호출로 더 많은 데이터를 수집합니다.
    - API 호출 제한을 피하기 위해 요청 사이에 대기 시간을 추가합니다.

    매개변수:
    - symbol: str
        거래 쌍을 나타냅니다. 예: 'BTC/USDT'
    - timeframe: str
        데이터 간격을 설정합니다. 예: '1m'(1분), '4h'(4시간), '1d'(1일)
    - start_date: str
        데이터 수집을 시작할 시점입니다. 예: '2021-01-01 00:00:00'
    - limit_per_request: int
        한 번 호출 시 가져올 데이터 개수입니다. 기본값은 1000입니다.
    - pause_sec: float
        연속 호출 사이에 대기할 시간(초)입니다. 기본값은 1.0초입니다.

    반환값:
    - pd.DataFrame
        날짜와 시세 데이터(open, high, low, close, volume)가 포함된 데이터프레임
    """
    # 바이낸스 거래소 객체 생성
    exchange = ccxt.binance()

    # 시작 날짜를 타임스탬프(ms 단위)로 변환
    since_ms = exchange.parse8601(start_date)

    # 수집한 데이터를 저장할 빈 리스트 생성
    all_ohlcv = []

    # 데이터 수집 반복문
    while True:
        # 바이낸스 API를 사용해 OHLCV(시세 데이터) 수집
        ohlcv = exchange.fetch_ohlcv(
            symbol=symbol,
            timeframe=timeframe,
            since=since_ms,
            limit=limit_per_request
        )

        # 불러온 데이터가 없으면 종료
        if not ohlcv:
            break

        # 가져온 데이터를 리스트에 추가
        all_ohlcv += ohlcv

        # 가장 최근 데이터의 타임스탬프를 가져와 다음 요청의 시작점으로 설정
        last_ts = ohlcv[-1][0]
        since_ms = last_ts + 1

        # API 호출 제한을 피하기 위해 대기
        time.sleep(pause_sec)

        # 마지막으로 가져온 데이터 개수가 한 번 호출의 최대 개수보다 적으면 종료
        if len(ohlcv) < limit_per_request:
            break

    # 수집된 데이터를 데이터프레임으로 변환
    df = pd.DataFrame(all_ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # 타임스탬프를 datetime 형식으로 변환
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

    # 타임스탬프를 데이터프레임의 인덱스로 설정
    df.set_index('timestamp', inplace=True)

    # 시세 데이터 컬럼들을 실수(float)형으로 변환
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)

    # 중복된 인덱스와 결측치 제거
    df = df[~df.index.duplicated()]
    df.dropna(inplace=True)

    # 최종 데이터프레임 반환
    return df


def fetch_binance_latest_ohlcv(symbol: str, timeframe: str = '4h', limit: int = 500) -> pd.DataFrame:
    """
    바이낸스에서 가장 최근 시세 데이터를 가져오는 함수입니다.

    주요 기능:
    - 지정된 개수의 최신 데이터를 가져옵니다.
    - 실시간 분석이나 단기 데이터가 필요한 경우 유용합니다.

    매개변수:
    - symbol: str
        거래 쌍을 나타냅니다. 예: 'BTC/USDT'
    - timeframe: str
        데이터 간격을 설정합니다. 예: '1m'(1분), '4h'(4시간), '1d'(1일)
    - limit: int
        가져올 데이터의 최대 개수입니다. 기본값은 500입니다.

    반환값:
    - pd.DataFrame
        날짜와 시세 데이터(open, high, low, close, volume)가 포함된 데이터프레임
    """
    # 바이낸스 거래소 객체 생성
    exchange = ccxt.binance()

    # 최신 데이터를 요청
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)

    # 데이터를 데이터프레임으로 변환
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # 타임스탬프를 datetime 형식으로 변환
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

    # 타임스탬프를 데이터프레임의 인덱스로 설정
    df.set_index('timestamp', inplace=True)

    # 시세 데이터 컬럼들을 실수(float)형으로 변환
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    df[numeric_cols] = df[numeric_cols].astype(float)

    # 중복된 인덱스와 결측치 제거
    df = df[~df.index.duplicated()]
    df.dropna(inplace=True)

    # 최종 데이터프레임 반환
    return df
---
# config/db_config.py
# 이 파일은 데이터베이스에 연결하기 위한 설정 정보를 저장합니다.

DATABASE = {
    # 데이터베이스 사용자 계정 정보
    'user': 'postgres',         # 데이터베이스 사용자 이름
    'password': '1234',         # 데이터베이스 사용자 비밀번호

    # 데이터베이스 서버 정보
    'host': 'localhost',        # 서버 주소 (localhost는 현재 컴퓨터를 의미)
    'port': 5432,               # 서버 포트 번호 (PostgreSQL의 기본 포트)

    # 데이터베이스 이름
    'dbname': 'my_trading_db'   # 연결할 데이터베이스의 이름
}
---
# data_collection/save_to_postgres.py

from sqlalchemy import create_engine # SQL 작업을 쉽고 직관적으로 처리하는 라이브러리
import psycopg2 # PostgreSQL 데이터베이스와 직접 통신할 때 사용.
import pandas as pd # 데이터 분석 및 조작을 위한 라이브러리.
from typing import Optional # 함수 매개변수의 타입을 명시하기 위한 라이브러리.
from config.db_config import DATABASE # 데이터베이스 연결 정보를 포함한 설정 파일에서 DATABASE 정보를 가져옵니다.

# OHLCV 데이터를 PostgreSQL에 저장하는 함수입니다.
def save_ohlcv_to_postgres(df: pd.DataFrame, table_name: str = 'ohlcv_data') -> None:
    """
    OHLCV 데이터를 PostgreSQL 데이터베이스에 저장합니다.
    
    Parameters
    ----------
    df : pd.DataFrame
        OHLCV 데이터를 담고 있는 pandas DataFrame입니다.
        필요한 컬럼: timestamp(인덱스), open, high, low, close, volume.
    table_name : str
        데이터를 저장할 데이터베이스 테이블 이름. 기본값은 'ohlcv_data'입니다.
    """
    
    # 1) 데이터베이스 연결 생성
    # 데이터베이스 접속 정보를 사용하여 PostgreSQL에 연결합니다.
    conn = psycopg2.connect(
        user=DATABASE['user'],          # 사용자 이름
        password=DATABASE['password'],  # 비밀번호
        host=DATABASE['host'],          # 데이터베이스 호스트 주소
        port=DATABASE['port'],          # 데이터베이스 포트 번호
        dbname=DATABASE['dbname']       # 데이터베이스 이름
    )
    cur = conn.cursor()  # SQL 작업을 수행할 커서 생성

    # 2) 테이블 생성
    # 테이블이 존재하지 않으면 새로 생성합니다.
    create_table_query = f"""
    CREATE TABLE IF NOT EXISTS {table_name} (
        timestamp TIMESTAMP NOT NULL,       -- 데이터의 시간 정보
        open DOUBLE PRECISION,             -- 시가
        high DOUBLE PRECISION,             -- 고가
        low DOUBLE PRECISION,              -- 저가
        close DOUBLE PRECISION,            -- 종가
        volume DOUBLE PRECISION,           -- 거래량
        PRIMARY KEY (timestamp)            -- 기본 키로 timestamp를 사용
    );
    """
    cur.execute(create_table_query)  # SQL 쿼리 실행
    conn.commit()  # 변경사항 저장

    # 3) DataFrame 데이터를 테이블에 삽입
    # DataFrame의 각 행(row)을 데이터베이스에 추가합니다.
    for index, row in df.iterrows():
        insert_query = f"""
        INSERT INTO {table_name} (timestamp, open, high, low, close, volume)
        VALUES (%s, %s, %s, %s, %s, %s)
        ON CONFLICT (timestamp)
        DO NOTHING;  -- 중복된 timestamp 데이터는 무시
        """
        cur.execute(insert_query, (
            index.to_pydatetime(),  # 인덱스를 datetime 형식으로 변환
            float(row['open']),    # 시가
            float(row['high']),    # 고가
            float(row['low']),     # 저가
            float(row['close']),   # 종가
            float(row['volume'])   # 거래량
        ))
    conn.commit()  # 변경사항 저장

    # 4) 데이터베이스 연결 종료
    cur.close()  # 커서 닫기
    conn.close()  # 연결 종료

# PostgreSQL에서 OHLCV 데이터를 읽어오는 함수입니다.
def load_ohlcv_from_postgres(table_name: str = 'ohlcv_data', limit: Optional[int] = None) -> pd.DataFrame:
    """
    PostgreSQL 데이터베이스에서 OHLCV 데이터를 가져옵니다.
    
    Parameters
    ----------
    table_name : str
        데이터를 가져올 테이블 이름. 기본값은 'ohlcv_data'입니다.
    limit : Optional[int]
        가져올 데이터의 최대 개수. 기본값은 제한 없음(None)입니다.
        
    Returns
    -------
    pd.DataFrame
        OHLCV 데이터를 담고 있는 pandas DataFrame을 반환합니다.
    """
    
    # 1) SQLAlchemy 엔진 생성
    # 데이터베이스 연결 정보를 이용하여 엔진을 생성합니다.
    engine = create_engine(f"postgresql://{DATABASE['user']}:{DATABASE['password']}@{DATABASE['host']}:{DATABASE['port']}/{DATABASE['dbname']}")

    # 2) SQL 쿼리 생성
    query = f"SELECT * FROM {table_name} ORDER BY timestamp"  # 데이터를 timestamp 기준으로 정렬
    if limit:  # limit 값이 있으면 최대 limit 개수만 가져옴
        query += f" LIMIT {limit}"

    # 3) SQL 결과를 DataFrame으로 변환
    # pandas의 read_sql()을 사용하여 SQL 결과를 읽어옵니다.
    df = pd.read_sql(query, engine, parse_dates=['timestamp'])  # timestamp를 datetime 형식으로 변환

    # 4) DataFrame 인덱스 설정
    df.set_index('timestamp', inplace=True)  # timestamp를 인덱스로 설정

    # 5) DataFrame 반환
    return df
---
# data_collection/ohlcv_data_pipeline.py

# 시간 관리 및 데이터 타입을 위한 모듈
import time
from datetime import datetime
from typing import List, Optional

# 외부 파일에서 데이터 수집 및 저장 함수 가져오기
from data_collection.fetch_binance_data import (
    fetch_binance_historical_ohlcv,  # 바이낸스에서 역사적 OHLCV 데이터 수집 함수
    fetch_binance_latest_ohlcv       # 바이낸스에서 최신 OHLCV 데이터 수집 함수
)
from data_collection.save_to_postgres import save_ohlcv_to_postgres  # 데이터 저장 함수

def collect_data_for_backtest(
    symbols: List[str],
    timeframes: List[str],
    use_historical: bool = True,
    start_date: Optional[str] = '2018-01-01 00:00:00',
    limit_per_request: int = 1000,
    latest_limit: int = 500,
    pause_sec: float = 1.0
) -> None:
    """
    Binance에서 OHLCV 데이터를 수집 후 PostgreSQL 데이터베이스에 저장하는 함수입니다.

    Parameters:
        symbols (List[str]): 데이터 수집을 원하는 암호화폐 심볼 리스트. 예: ["BTC/USDT", "ETH/USDT"]
        timeframes (List[str]): 데이터 수집을 원하는 타임프레임 리스트. 예: ["1h", "4h", "1d"]
        use_historical (bool): True면 start_date부터 모든 데이터를 수집, False면 최신 데이터만 수집.
        start_date (str, optional): 역사적 데이터 수집 시작 날짜 (UTC 기준). 기본값: '2018-01-01 00:00:00'
        limit_per_request (int): 한 번의 요청에서 가져올 데이터 수. 기본값: 1000
        latest_limit (int): 최신 데이터 수집 시 가져올 데이터 수. 기본값: 500
        pause_sec (float): 각 요청 사이의 대기 시간(초). 기본값: 1.0

    Returns:
        None
    """
    # (1) 각 암호화폐 심볼에 대해 작업 시작
    for symbol in symbols:
        # (2) 각 타임프레임에 대해 작업 시작
        for tf in timeframes:
            print(f"\n[*] Fetching {symbol} - {tf} data...")

            # 데이터 수집 단계
            if use_historical:
                # (a) 역사적 데이터 수집
                if not start_date:
                    raise ValueError("start_date는 역사적 데이터 수집에 필수입니다.")
                df = fetch_binance_historical_ohlcv(
                    symbol=symbol,
                    timeframe=tf,
                    start_date=start_date,
                    limit_per_request=limit_per_request,
                    pause_sec=pause_sec
                )
            else:
                # (b) 최신 데이터 수집
                df = fetch_binance_latest_ohlcv(
                    symbol=symbol,
                    timeframe=tf,
                    limit=latest_limit
                )

            # 테이블 이름 생성
            table_name = f"ohlcv_{symbol.replace('/', '').lower()}_{tf}"
            print(f"    -> Total Rows Fetched: {len(df)}")

            # 수집한 데이터를 PostgreSQL 데이터베이스에 저장
            save_ohlcv_to_postgres(df, table_name=table_name)
            print(f"    -> Saved to table: {table_name}")

            # 다음 요청 전 잠시 대기 (API 부하 방지)
            time.sleep(pause_sec)
---
# strategies/signal_generator.py

import pandas as pd # Pandas 라이브러리: 데이터 분석 및 처리 도구

def calculate_breakout_signals(
    df: pd.DataFrame,
    window: int = 20,
    vol_factor: float = 1.5,
    confirm_bars: int = 2,
    use_high: bool = False,
    breakout_buffer: float = 0.0
) -> pd.DataFrame:
    """
    데이터에서 전고점 돌파, 거래량 조건, 확정 돌파 신호를 계산하는 함수입니다.

    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 데이터를 포함한 DataFrame (열: 시가, 고가, 저가, 종가, 거래량 등)
    - window (int): 전고점과 평균 거래량 계산 기준이 되는 과거 데이터 기간 (기본값: 20)
    - vol_factor (float): 거래량이 과거 평균 대비 얼마나 높은지를 결정하는 배수 (기본값: 1.5)
    - confirm_bars (int): 돌파 신호가 몇 개의 연속 봉에서 발생해야 확정 돌파로 간주할지 (기본값: 2)
    - use_high (bool): True이면 고가 기준, False이면 종가 기준으로 돌파 여부 판단 (기본값: False)
    - breakout_buffer (float): 돌파 기준에 추가 여유값 (비율) (기본값: 0.0)
    ------------------------------------------------------------------------
    반환 (Return):
    - 추가 컬럼들이 포함된 DataFrame:
      - highest_xx: window 기간 동안의 전고점
      - breakout_signal: 돌파 신호(True/False)
      - volume_condition: 거래량 조건 만족 여부(True/False)
      - confirmed_breakout: 확정 돌파 신호(True/False)
    """

    # 1. 전고점(highest_xx) 계산
    # - window 기간 동안 고가(high)의 최댓값(전고점)을 구합니다.
    # - shift(1)를 통해 현재 봉 데이터를 제외하고 계산.
    df[f'highest_{window}'] = (
        df['high'].shift(1)  # 현재 봉 제외
        .rolling(window)    # 지정한 window 기간 동안 계산
        .max()              # 해당 기간 내 최대값(전고점)
    )

    # 2. 돌파 신호(breakout_signal) 계산
    # - 주가가 (전고점 + breakout_buffer)보다 높은 경우 돌파로 간주.
    # - use_high가 True일 경우 고가(high), False일 경우 종가(close)를 기준으로 계산.
    if use_high:
        df['breakout_signal'] = df['high'] > (
            df[f'highest_{window}'] * (1 + breakout_buffer)
        )
    else:
        df['breakout_signal'] = df['close'] > (
            df[f'highest_{window}'] * (1 + breakout_buffer)
        )

    # 3. 거래량 조건(volume_condition) 계산
    # - window 기간 동안 평균 거래량(vol_ma_xx)을 계산.
    # - 현재 거래량이 평균 거래량 * vol_factor보다 큰 경우 조건 만족(True).
    df[f'vol_ma_{window}'] = (
        df['volume'].shift(1)  # 현재 봉 제외
        .rolling(window)      # 지정된 window 기간 동안 평균값 계산
        .mean()               # 평균 거래량
    )
    df['volume_condition'] = df['volume'] > (vol_factor * df[f'vol_ma_{window}'])

    # 4. 확정 돌파(confirmed_breakout) 계산
    # - 돌파 신호가 confirm_bars 기간 동안 연속 발생하면 확정 돌파(True).
    # - rolling(confirm_bars)을 사용해 연속 신호 수를 합산.
    df['confirmed_breakout'] = (
        df['breakout_signal'].rolling(confirm_bars).sum() == confirm_bars
    )

    # NaN(초기 값 없음) 처리: False로 채움
    df['confirmed_breakout'] = df['confirmed_breakout'].fillna(False)

    return df
---
# strategies/stop_loss_take_profit.py

# 데이터 분석 및 수치 연산 라이브러리
import pandas as pd
import numpy as np
import ta  # 'ta'는 ATR, RSI 등 다양한 기술적 지표를 제공하는 라이브러리

def apply_stop_loss_atr(
    df: pd.DataFrame,
    atr_window: int = 14,
    atr_multiplier: float = 2.0,
    sl_colname: str = 'stop_loss_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    ATR(평균진폭)을 기반으로 손절가(stop_loss_price)를 계산하여 DataFrame에 추가합니다.
    
    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 매수 신호(long_entry)와 가격 정보(시가, 고가, 저가, 종가 등)가 포함된 데이터.
    - atr_window (int): ATR 계산에 사용할 과거 캔들 수. 기본값: 14
    - atr_multiplier (float): 손절가 계산 시 ATR에 곱할 배수. 기본값: 2.0
    - sl_colname (str): 계산된 손절가를 저장할 컬럼명. 기본값: 'stop_loss_price'
    - entry_price_col (str): 진입가(매수가)를 저장할 컬럼명. 기본값: 'entry_price'

    반환값 (Return):
    - DataFrame: 'atr', 'entry_price', 'stop_loss_price' 컬럼이 추가된 데이터프레임.
    """

    # 1) ATR(평균진폭) 계산
    # - AverageTrueRange: 고가(high), 저가(low), 종가(close)를 사용해 변동성을 계산.
    # - window: 계산 기준이 되는 캔들 수
    atr_indicator = ta.volatility.AverageTrueRange(
        high=df['high'],
        low=df['low'],
        close=df['close'],
        window=atr_window,
        fillna=True  # 결측값 발생 방지
    )
    df['atr'] = atr_indicator.average_true_range()

    # 2) 매수 시점의 종가(entry_price) 기록
    # - 매수 신호(long_entry=True) 발생 시 종가(close)를 진입가로 설정.
    df[entry_price_col] = np.where(df['long_entry'], df['close'], np.nan)

    # 3) 진입가 유지 (forward fill)
    # - 진입 이후 익절/손절까지 동일한 진입가 유지.
    df[entry_price_col] = df[entry_price_col].ffill()

    # 4) 손절가(stop_loss_price) 계산
    # - 손절가 = 진입가 - (ATR × ATR 배수)
    df[sl_colname] = df[entry_price_col] - (df['atr'] * atr_multiplier)

    return df


def apply_take_profit_ratio(
    df: pd.DataFrame,
    profit_ratio: float = 0.05,
    tp_colname: str = 'take_profit_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    """
    고정된 목표 수익률을 사용하여 익절가(take_profit_price)를 계산합니다.
    
    ------------------------------------------------------------------------
    매개변수 (Parameters):
    - df (DataFrame): 매수 신호와 진입가가 포함된 데이터프레임.
    - profit_ratio (float): 목표 수익률 (기본값: 0.05, 즉 5% 수익에 익절).
    - tp_colname (str): 계산된 익절가를 저장할 컬럼명.
    - entry_price_col (str): 진입가가 기록된 컬럼명.

    반환값 (Return):
    - DataFrame: 익절가(take_profit_price)가 추가된 데이터프레임.
    """

    # 익절가 계산: 진입가 × (1 + 목표 수익률)
    df[tp_colname] = df[entry_price_col] * (1 + profit_ratio)
    return df
---
# strategies/risk_management.py

import math # 수학 함수 사용을 위한 math 모듈

def calculate_position_size(
    account_balance: float,
    risk_per_trade: float,
    entry_price: float,
    stop_loss_price: float,
    fee_rate: float = 0.001
) -> float:
    """
    한 번의 매매에서 최대 손실을 제한하도록 포지션 크기를 계산하는 함수입니다.

    매개변수:
    ----------
    - account_balance (float): 계좌 잔고 (예: 10,000 USDT)
    - risk_per_trade (float): 허용 가능한 손실 비율 (예: 0.01 = 1%)
    - entry_price (float): 매수 가격
    - stop_loss_price (float): 손절 가격
    - fee_rate (float): 매수 수수료 비율 (기본값: 0.001 = 0.1%)

    반환값:
    ----------
    - float: 계산된 매수 가능 코인(또는 계약) 수량

    계산 절차:
    1. 코인 1개당 손실 금액 계산:
       `price_diff = abs(entry_price - stop_loss_price)`
    2. 최대 감당 가능 손실 금액 계산:
       `max_risk_amount = account_balance * risk_per_trade`
    3. 수수료 계산:
       `fee_amount = entry_price * fee_rate`
    4. 코인 1개당 총 손실:
       `per_unit_loss = price_diff + fee_amount`
    5. 허용 손실 금액 내에서 매수 가능한 최대 코인 수 계산:
       `position_size = max_risk_amount / per_unit_loss`
    """

    # 코인 1개당 손실 계산 (진입가와 손절가의 차이)
    price_diff = abs(entry_price - stop_loss_price)

    # 감당 가능한 최대 손실 금액
    max_risk_amount = account_balance * risk_per_trade

    # 매수 시 발생할 수수료
    fee_amount = entry_price * fee_rate

    # 코인 1개당 총 손실 계산
    per_unit_loss = price_diff + fee_amount

    # 최대 매수 가능 코인 수 계산
    if per_unit_loss > 0:
        position_size = max_risk_amount / per_unit_loss
    else:
        position_size = 0.0

    return position_size


def split_position_sizes(
    total_position_size: float,
    split_count: int = 3,
    scale_mode: str = 'equal'
) -> list:
    """
    전체 매수 물량을 여러 단계로 나누는 분할 매매 함수입니다.

    매개변수:
    ----------
    - total_position_size (float): 매수할 총 코인 수량
    - split_count (int): 매수 단계를 몇 번으로 나눌지 (기본값: 3)
    - scale_mode (str): 분할 비율 설정
        * 'equal': 균등 분할
        * 'pyramid_up': 뒤로 갈수록 매수 물량 증가
        * 'pyramid_down': 앞으로 갈수록 매수 물량 감소

    반환값:
    ----------
    - list: 각 단계별 매수 물량

    예시:
    ------
    >>> split_position_sizes(9, split_count=3, scale_mode='equal')
    [3.0, 3.0, 3.0]

    >>> split_position_sizes(9, split_count=3, scale_mode='pyramid_up')
    [1.5, 3.0, 4.5]
    """

    # 최소 1회 이상 매수를 나눌 수 있어야 함
    if split_count < 1:
        raise ValueError("split_count는 최소 1 이상이어야 합니다.")

    # 지원하지 않는 모드는 예외 처리
    if scale_mode not in ['equal', 'pyramid_up', 'pyramid_down']:
        raise ValueError("scale_mode는 'equal', 'pyramid_up', 'pyramid_down' 중 하나여야 합니다.")

    if scale_mode == 'equal':
        # 균등 분할
        split_size = total_position_size / split_count
        return [split_size] * split_count

    elif scale_mode == 'pyramid_up':
        # 피라미드 업: 뒤로 갈수록 더 많은 매수 비중
        ratio_sum = split_count * (split_count + 1) / 2  # 합계 계산 (1+2+3...)
        return [(i / ratio_sum) * total_position_size for i in range(1, split_count + 1)]

    elif scale_mode == 'pyramid_down':
        # 피라미드 다운: 앞으로 갈수록 더 많은 매수 비중
        ratio_sum = split_count * (split_count + 1) / 2
        return [(i / ratio_sum) * total_position_size for i in range(split_count, 0, -1)]
---
# backtesting/verify_signals.py

import matplotlib.pyplot as plt # 시각화를 위한 matplotlib
import pandas as pd

# 데이터베이스 및 시그널 계산 함수
from data_collection.save_to_postgres import load_ohlcv_from_postgres
from strategies.signal_generator import calculate_breakout_signals

def verify_breakout_signals(
    symbol: str,
    timeframe: str,
    table_name: str,
    window: int = 20,
    vol_factor: float = 1.5,
    confirm_bars: int = 2,
    use_high: bool = False,
    breakout_buffer: float = 0.0,
    plot_chart: bool = False
):
    """
    돌파 시그널 검증 및 시각화 함수.

    주요 기능:
    ----------
    1. PostgreSQL에서 (symbol, timeframe)에 해당하는 데이터를 로드.
    2. 돌파 시그널(전고점, 거래량, 확정 돌파)을 계산.
    3. 시그널이 의도대로 생성되었는지 수치적으로 검증.
    4. (선택적) 차트를 통해 시그널을 시각적으로 확인.

    매개변수:
    ----------
    - symbol (str): 자산 심볼 (예: "BTC/USDT")
    - timeframe (str): 데이터의 시간 간격 (예: "4h")
    - table_name (str): 데이터베이스 테이블명
    - window (int): 전고점 계산 기간
    - vol_factor (float): 거래량 필터 배수
    - confirm_bars (int): 확정 돌파를 위한 봉 개수
    - use_high (bool): True면 고가 기준 돌파, False면 종가 기준 돌파
    - breakout_buffer (float): 돌파 기준에 추가할 버퍼 비율
    - plot_chart (bool): True면 차트로 결과 시각화

    반환값:
    ----------
    None
    """

    print(f"\n[Verification] symbol={symbol}, timeframe={timeframe}, table={table_name}")

    # 1. 데이터 로드
    df = load_ohlcv_from_postgres(table_name=table_name)
    if df.empty:
        print(f"  -> No data loaded from table: {table_name}")
        return

    # 2. 돌파 시그널 계산
    df = calculate_breakout_signals(
        df=df,
        window=window,
        vol_factor=vol_factor,
        confirm_bars=confirm_bars,
        use_high=use_high,
        breakout_buffer=breakout_buffer
    )

    # -------------------------------
    # 3. 수치적 검증
    # -------------------------------

    # (A) breakout_signal 검증
    condition_breakout_true = (df['breakout_signal'] == True)
    error_rows = df[condition_breakout_true & 
                    (df['close'] <= df[f'highest_{window}'] * (1 + breakout_buffer))]
    if not error_rows.empty:
        print("[Warning] breakout_signal=True 이지만 실제로 돌파되지 않은 봉이 발견됨!")
        print(error_rows[['close', f'highest_{window}', 'breakout_signal']].head(10))
    else:
        print(" -> breakout_signal과 실제 가격 돌파가 일치합니다. (수치상 오차 없음)")

    # (B) volume_condition 검증
    cond_vol_true = (df['volume_condition'] == True)
    error_vol = df[cond_vol_true & (df['volume'] <= df[f'vol_ma_{window}'] * vol_factor)]
    if not error_vol.empty:
        print("[Warning] volume_condition=True 이지만 실제 거래량 조건이 만족되지 않은 봉 발견!")
        print(error_vol[['volume', f'vol_ma_{window}', 'volume_condition']].head(10))
    else:
        print(" -> volume_condition과 실제 거래량 조건이 일치합니다. (수치상 오차 없음)")

    # -------------------------------
    # 4. 차트 시각화 (선택 사항)
    # -------------------------------
    if plot_chart:
        # 최근 300개 봉만 시각화 (데이터가 많을 경우 복잡해짐)
        df_plot = df.tail(300)

        plt.figure(figsize=(12, 6))
        plt.plot(df_plot.index, df_plot['close'], label='Close', color='blue')

        # 전고점(highest_xx) 표시
        plt.plot(df_plot.index, df_plot[f'highest_{window}'], label=f"Highest({window})", linestyle='--', color='orange')

        # breakout_signal이 True인 지점에 빨간 마커
        breakout_points = df_plot[df_plot['breakout_signal'] == True]
        plt.scatter(breakout_points.index, breakout_points['close'], color='red', marker='^', label='Breakout Signal')

        # confirmed_breakout이 True인 지점에 녹색 마커
        confirmed_points = df_plot[df_plot['confirmed_breakout'] == True]
        plt.scatter(confirmed_points.index, confirmed_points['close'], color='green', marker='o', label='Confirmed Breakout')

        plt.title(f"{symbol} {timeframe} - Breakout Signal Verification")
        plt.xlabel("Time")
        plt.ylabel("Price")
        plt.legend()
        plt.show()
   ---
   # backtesting/performance_metrics.py

# 데이터 분석과 수치 연산을 위한 라이브러리
import pandas as pd
import numpy as np

def calculate_monthly_performance(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    월별 손익(PnL), 매매 횟수, 승률을 계산하는 함수.

    주요 기능:
    ----------
    - 월(YYYY-MM) 단위로 매매 데이터를 그룹화.
    - 각 월별 총 손익, 매매 횟수, 승률을 계산.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).

    반환값:
    ----------
    - DataFrame: 월별 성과를 요약한 데이터프레임.
    """
    # 연월(YYYY-MM) 기준으로 그룹화
    trades_df['year_month'] = trades_df['exit_time'].dt.to_period('M')

    # 그룹별 성과 계산
    grouped = trades_df.groupby('year_month')
    results = []

    for ym, grp in grouped:
        total_pnl = grp['pnl'].sum()  # 총 손익
        num_trades = len(grp)        # 매매 횟수
        win_trades = (grp['pnl'] > 0).sum()  # 이긴 매매 수
        win_rate = win_trades / num_trades * 100.0 if num_trades > 0 else 0.0  # 승률 계산

        results.append({
            'year_month': str(ym),
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })

    return pd.DataFrame(results)


def calculate_yearly_performance(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    연도별 손익(PnL), 매매 횟수, 승률을 계산하는 함수.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).

    반환값:
    ----------
    - DataFrame: 연도별 성과를 요약한 데이터프레임.
    """
    # 연도별 그룹화
    trades_df['year'] = trades_df['exit_time'].dt.year
    grouped = trades_df.groupby('year')

    results = []
    for y, grp in grouped:
        total_pnl = grp['pnl'].sum()
        num_trades = len(grp)
        win_trades = (grp['pnl'] > 0).sum()
        win_rate = win_trades / num_trades * 100.0 if num_trades > 0 else 0.0

        results.append({
            'year': y,
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })

    return pd.DataFrame(results)


def calculate_mdd(trades_df: pd.DataFrame, initial_balance: float) -> float:
    """
    최대낙폭(MDD)을 계산하는 함수.

    주요 기능:
    ----------
    - 매매 기록을 순서대로 처리하여 최대낙폭(MDD)을 계산.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
      필요한 컬럼: exit_time(datetime), pnl(float).
    - initial_balance (float): 초기 계좌 잔고.

    반환값:
    ----------
    - float: 최대낙폭(MDD) 값(음수, % 단위).
    """
    # 시간 순 정렬
    trades_df = trades_df.sort_values(by='exit_time')

    # 잔고 추적
    equity_list = []
    current_balance = initial_balance

    for _, row in trades_df.iterrows():
        current_balance += row['pnl']
        equity_list.append(current_balance)

    # MDD 계산
    equity_arr = np.array(equity_list)
    peak_arr = np.maximum.accumulate(equity_arr)  # 최고점 추적
    drawdown_arr = (equity_arr - peak_arr) / peak_arr  # 낙폭 계산
    mdd = drawdown_arr.min() * 100.0  # %로 변환
    return mdd


def print_performance_report(trades_df: pd.DataFrame, initial_balance: float) -> None:
    """
    전체 성과를 요약 출력하는 함수.

    주요 기능:
    ----------
    - 월별, 연도별 성과와 MDD(최대낙폭), ROI, 승률 등을 출력.

    매개변수:
    ----------
    - trades_df (DataFrame): 매매 기록 데이터프레임.
    - initial_balance (float): 초기 계좌 잔고.

    반환값:
    ----------
    - None
    """
    if trades_df.empty:
        print("No trades to report.")
        return

    # 성과 계산
    monthly_df = calculate_monthly_performance(trades_df)
    yearly_df = calculate_yearly_performance(trades_df)
    total_pnl = trades_df['pnl'].sum()
    final_balance = initial_balance + total_pnl
    mdd = calculate_mdd(trades_df, initial_balance=initial_balance)

    # 출력
    print("=== (A) 월별 성과 ===")
    print(monthly_df)

    print("\n=== (B) 연도별 성과 ===")
    print(yearly_df)

    print("\n=== (C) 전체 성과 ===")
    print(f"  - 초기 잔고       : {initial_balance:.2f}")
    print(f"  - 최종 잔고       : {final_balance:.2f}")
    print(f"  - 총 손익         : {total_pnl:.2f}")
    print(f"  - ROI(%)          : {(final_balance - initial_balance) / initial_balance * 100:.2f}%")
    print(f"  - 최대낙폭(MDD)   : {mdd:.2f}%")

    # 매매 통계
    num_trades = len(trades_df)
    wins = (trades_df['pnl'] > 0).sum()
    win_rate = wins / num_trades * 100.0 if num_trades > 0 else 0.0
    print(f"  - 총 매매 횟수    : {num_trades}")
    print(f"  - 승률(%)         : {win_rate:.2f}%")
---
# backtesting/backtest_simple.py

# 데이터 분석 및 수치 계산을 위한 라이브러리
import pandas as pd
import numpy as np

# 필요한 함수와 모듈 불러오기
from data_collection.save_to_postgres import load_ohlcv_from_postgres
from strategies.signal_generator import calculate_breakout_signals
from strategies.stop_loss_take_profit import apply_stop_loss_atr, apply_take_profit_ratio
from strategies.risk_management import calculate_position_size
from backtesting.performance_metrics import print_performance_report

def run_simple_backtest(
    symbol="BTC/USDT",
    timeframe="4h",
    window=20,
    volume_factor=1.5,
    confirm_bars=2,
    breakout_buffer=0.0,
    atr_window=14,
    atr_multiplier=2.0,
    profit_ratio=0.05,
    account_size=10_000.0,
    risk_per_trade=0.01,
    fee_rate=0.001
):
    """
    간단한 백테스트를 실행하는 함수입니다.

    주요 기능:
    ----------
    1. 과거 데이터를 로드하여 백테스트를 실행합니다.
    2. 돌파 신호와 거래량 조건을 통해 매수 시점을 결정합니다.
    3. ATR 기반 손절 및 고정 익절 전략을 적용합니다.
    4. 백테스트 결과를 계산하고, 성과를 출력합니다.

    매개변수:
    ----------
    - symbol (str): 테스트할 자산의 심볼 (예: "BTC/USDT")
    - timeframe (str): 데이터의 시간 간격 (예: "4h")
    - window (int): 전고점을 계산하는 기간
    - volume_factor (float): 거래량 필터 배수
    - confirm_bars (int): 돌파 확정을 위한 봉 개수
    - breakout_buffer (float): 돌파 기준에 추가할 버퍼
    - atr_window (int): ATR 계산 기간
    - atr_multiplier (float): ATR 기반 손절 배수
    - profit_ratio (float): 고정 익절 비율
    - account_size (float): 초기 계좌 자산
    - risk_per_trade (float): 매매당 최대 손실 비율
    - fee_rate (float): 매수 수수료 비율

    반환값:
    ----------
    - DataFrame: 각 매매에 대한 세부 정보가 담긴 DataFrame
    """

    # -------------------------------
    # 1) 과거 데이터 불러오기
    # -------------------------------
    table_name = f"ohlcv_{symbol.replace('/', '').lower()}_{timeframe}"
    df = load_ohlcv_from_postgres(table_name=table_name)
    df = df.sort_index()  # 시간순 정렬

    if df.empty:
        print("DataFrame is empty! 데이터가 없습니다.")
        return None

    print(f"Loaded data from {table_name}: {df.shape[0]} rows")

    # -------------------------------
    # 2) 돌파 시그널 계산
    # -------------------------------
    df = calculate_breakout_signals(
        df=df,
        window=window,
        vol_factor=volume_factor,
        confirm_bars=confirm_bars,
        use_high=False,
        breakout_buffer=breakout_buffer
    )

    # 돌파 신호와 관련된 통계를 출력
    print("\nSignal Stats:")
    print(f"Breakout signals: {df['breakout_signal'].sum()}")
    print(f"Confirmed breakouts: {df['confirmed_breakout'].sum()}")

    # -------------------------------
    # 3) ATR 손절 및 고정 익절
    # -------------------------------
    df['long_entry'] = df['confirmed_breakout'] & df['volume_condition']

    df = apply_stop_loss_atr(
        df=df,
        atr_window=atr_window,
        atr_multiplier=atr_multiplier,
        sl_colname='stop_loss_price',
        entry_price_col='entry_price'
    )

    df = apply_take_profit_ratio(
        df=df,
        profit_ratio=profit_ratio,
        tp_colname='take_profit_price',
        entry_price_col='entry_price'
    )

    # -------------------------------
    # 4) 백테스트 루프 실행
    # -------------------------------
    in_position = False
    trades = []

    for i in range(len(df)):
        row = df.iloc[i]
        if not in_position and row['long_entry']:
            # 포지션 진입
            entry_price = row['entry_price']
            stop_loss = row['stop_loss_price']
            take_profit = row['take_profit_price']
            size = calculate_position_size(
                account_balance=account_size,
                risk_per_trade=risk_per_trade,
                entry_price=entry_price,
                stop_loss_price=stop_loss,
                fee_rate=fee_rate
            )
            in_position = True
            trades.append({
                'entry_time': row.name,
                'entry_price': entry_price,
                'size': size,
                'exit_time': None,
                'exit_price': None,
                'pnl': None,
                'exit_reason': None
            })
        elif in_position:
            # 포지션 청산 조건
            if row['close'] <= stop_loss:
                in_position = False
                trades[-1].update({
                    'exit_time': row.name,
                    'exit_price': row['close'],
                    'pnl': (row['close'] - trades[-1]['entry_price']) * trades[-1]['size'],
                    'exit_reason': 'stop_loss'
                })
            elif row['close'] >= take_profit:
                in_position = False
                trades[-1].update({
                    'exit_time': row.name,
                    'exit_price': row['close'],
                    'pnl': (row['close'] - trades[-1]['entry_price']) * trades[-1]['size'],
                    'exit_reason': 'take_profit'
                })

    # -------------------------------
    # 5) 결과 정리 및 성과 출력
    # -------------------------------
    trades_df = pd.DataFrame(trades)
    trades_df.dropna(subset=['exit_time'], inplace=True)

    if trades_df.empty:
        print("No trades were completed.")
        return None

    total_pnl = trades_df['pnl'].sum()
    final_balance = account_size + total_pnl
    roi_percent = (final_balance - account_size) / account_size * 100.0

    print(f"Total Trades: {len(trades_df)}")
    print(f"Total PnL: {total_pnl:.2f} USDT")
    print(f"Final Balance: {final_balance:.2f} USDT")
    print(f"ROI: {roi_percent:.2f}%")

    print_performance_report(trades_df, initial_balance=account_size)

    return trades_df
---
# backtesting/param_tuning.py

import itertools
import pandas as pd

from backtesting.backtest_simple import run_simple_backtest
# performance_metrics 모듈에서 필요한 계산 함수를 임포트
from backtesting.performance_metrics import (
    calculate_mdd,
    calculate_monthly_performance,
    calculate_yearly_performance
)

def param_sweep_test():
    """
    여러 파라미터(window, atr_multiplier, profit_ratio)의 조합을 테스트하고,
    각 조합별 성과 지표를 데이터프레임으로 만들어 반환합니다.
    (CSV 저장이나 상위 결과 출력 등은 이 함수를 호출하는 쪽에서 처리)
    """

    # (A) 테스트할 파라미터 후보 정의
    window_list = [10, 20, 30]
    atr_list = [1.5, 2.0]
    profit_ratio_list = [0.03, 0.05]

    results = []

    for window, atr_mult, pr in itertools.product(window_list, atr_list, profit_ratio_list):
        print(f"\n[Running] window={window}, atr_multiplier={atr_mult}, profit_ratio={pr}")

        # (B) 백테스트 실행
        trades_df = run_simple_backtest(
            symbol="BTC/USDT",
            timeframe="4h",
            window=window,
            volume_factor=1.5,
            confirm_bars=2,
            breakout_buffer=0.0,
            atr_window=14,
            atr_multiplier=atr_mult,
            profit_ratio=pr,
            account_size=10_000.0,
            risk_per_trade=0.01,
            fee_rate=0.001
        )

        if trades_df is None or trades_df.empty:
            # 트레이드가 없거나 비정상 -> 기록X
            continue

        # (C) 성과 지표 추가 계산
        initial_balance = 10_000.0

        # 총 손익 (pnl)
        total_pnl = trades_df['pnl'].sum()
        final_balance = initial_balance + total_pnl
        roi_percent = (final_balance - initial_balance) / initial_balance * 100.0

        # MDD 계산
        mdd_percent = calculate_mdd(trades_df, initial_balance=initial_balance)

        # 승률
        num_trades = len(trades_df)
        wins = (trades_df['pnl'] > 0).sum()
        win_rate = wins / num_trades * 100.0 if num_trades > 0 else 0.0

        # (D) 필요한 항목만 모아서 results에 저장
        results.append({
            'window'        : window,
            'atr_multiplier': atr_mult,
            'profit_ratio'  : pr,
            'num_trades'    : num_trades,
            'win_rate(%)'   : round(win_rate, 2),
            'final_balance' : round(final_balance, 2),
            'ROI(%)'        : round(roi_percent, 2),
            'MDD(%)'        : round(mdd_percent, 2),  # 보통 음수
        })

        # (E) (옵션) 월별·연도별 DF CSV 출력은 호출부에서 처리할 수도 있음
        # monthly_df = calculate_monthly_performance(trades_df)
        # yearly_df = calculate_yearly_performance(trades_df)
        # ...
        # (호출부에서 필요 시 저장)

    # (F) 결과 취합
    results_df = pd.DataFrame(results)
    return results_df  # ===> 호출부에서 이 결과를 받아 처리
---
# test.py

import pandas as pd
from backtesting.param_tuning import param_sweep_test


def main():
    # 함수 호출하여 결과 DataFrame 가져옴
    results_df = param_sweep_test()

    if results_df.empty:
        print("\nNo valid results returned.")
        return

    # CSV로 저장
    csv_filename = "param_sweep_results_with_metrics.csv"
    results_df.to_csv(csv_filename, index=False, encoding='utf-8-sig')
    print(f"CSV saved: {csv_filename}")

    # ROI(%)로 정렬 후 상위 5개 출력
    sorted_df = results_df.sort_values(by='ROI(%)', ascending=False)
    print("\n=== Top 5 by ROI ===")
    print(sorted_df.head(5))


if __name__ == "__main__":
    main()
---
window,atr_multiplier,profit_ratio,num_trades,win_rate(%),final_balance,ROI(%),MDD(%)
10,1.5,0.03,141,56.74,15010.82,50.11,-7.3
10,1.5,0.05,127,48.82,16613.92,66.14,-7.19
10,2.0,0.03,139,61.15,13525.7,35.26,-8.64
10,2.0,0.05,121,52.89,14282.44,42.82,-8.54
20,1.5,0.03,111,57.66,15032.73,50.33,-5.0
20,1.5,0.05,102,49.02,15663.4,56.63,-5.23
20,2.0,0.03,111,63.06,14047.43,40.47,-5.24
20,2.0,0.05,100,54.0,14504.64,45.05,-5.05
30,1.5,0.03,99,56.57,14721.39,47.21,-4.11
30,1.5,0.05,92,47.83,15293.15,52.93,-5.39
30,2.0,0.03,99,62.63,13729.85,37.3,-4.6
30,2.0,0.05,90,53.33,14025.04,40.25,-5.92












[참고사항2]
아래는 **복잡한 백테스트 로직**을 **단계별**로 구축해나갈 때 유용한 **가이드라인**입니다.  
(실무 경험상, 이런 과정을 밟으면 “큰 그림이 어지럽지 않게” 조금씩 확장해나갈 수 있습니다.)

---

## 1. 가장 ‘단순한’ 버전부터 시작

1. **단순 로직(예: 단일 타임프레임, 단일 심볼, 고정 파라미터)** 으로 먼저 백테스트 시스템을 ‘완성’해보세요.  
   - 예) “BTC/USDT, 4시간봉”에서 “전고점 돌파 & 거래량 필터” + “ATR 손절 & 5% 익절” 정도의 **아주 단순한** 전략.  
   - 여기서도 “시그널 계산 → 포지션 진입 → (손절/익절) → 청산”이 최소한으로 동작하면 됩니다.  

2. **백테스트 엔진(루프) 골격** 잡기  
   - 캔들(OHLCV)을 한 봉씩 순회하며,  
     - (a) 포지션 보유 중이면 손절·익절 체크,  
     - (b) 보유 중이 아니면 시그널 체크, → 진입  
     - (c) 거래 내역(진입·청산 로그) 및 잔고 변동 기록  
   - 한 번 이 기본 틀만 돌아가도, `최종 수익률`, `승률`, `손익비` 등 지표를 계산할 수 있게 됩니다.  

3. **단순 버전도 ‘완성’**이 중요  
   - 흔히 “이것도 넣어야지, 저것도 넣어야지” 하다가 정작 “동작하는 코드”를 못 만드는 경우가 많습니다.  
   - 일단 **단일 타임프레임 + 단일 심볼 + 고정 파라미터**로,  
     - **(a) 백테스트 결과가 정상적으로 나오는지**,  
     - **(b) 매수·매도 시점이 엑셀·차트로 검증했을 때 맞는지**  
   - 를 먼저 확인하면, 자신감도 생기고 전반적인 구조도 파악이 쉬워집니다.

####################################################################################################
## 1 단계와 2 단계 사이의 추가적인 점검/보완 
단순 버전(backtest_simple.py)까지 일단 “제대로 돌아가는 코드”를 완성하셨다면, **큰 흐름상 바로 ‘다중 타임프레임(MTF) 확장’으로 넘어가도 무방**합니다.  
다만, **실무 경험상** 다음과 같은 **중간 점검/보완**을 거친 뒤에 넘어가면, 이후 단계에서 훨씬 수월해집니다.

---

## 1) 현재 단순 버전의 **정상 동작** 여부를 더 꼼꼼하게 검증

1. **매수·매도 시점(시그널) 점검**  
   - 예: 2019~2020년 특정 상승장 구간을 구체적으로 골라,  
     - **차트**(TradingView 등)로 실제 BTC 가격 움직임을 확인하고,  
     - 백테스트 결과 매수·매도가 발생한 구간이 과연 “전고점 돌파”와 맞아떨어지는지 **핸드체크**  
   - 이렇게 눈으로 여러 구간을 대조해보면, 돌파 계산(rolling/shift)이나 익절·손절(ATR / 5%) 로직이 **의도대로** 동작하는지 확신을 가질 수 있습니다.

-> 결론:
자동 검증(verify_signals.py) 결과, “돌파 시그널이 실제 데이터와 오차 없이 일치한다”는 메시지가 나왔고, 차트에서도 신호가 의도한 대로 찍혀 있음을 확인할 수 있습니다.
이는 (상황1)에서 원하는 **‘시그널 로직이 정말 의도대로 동작하는지 검증’**이 제대로 수행되었다는 의미이므로, 다음 단계(월별·연도별 성과, 파라미터 튜닝 등)로 넘어가시면 됩니다.

2. **추가적인 지표(월별/연도별 손익, MDD 등) 계산**  
   - “최종 잔고가 얼마다”만 보고 넘어가기보다는,  
   - **연도별 혹은 월별 성과**, 최대낙폭(MDD), 승률, 손익비(RR) 등도 함께 봐야 합니다.  
   - 예를 들어, 특정 해(또는 특정 구간)에 큰 손실이 난다면, 그 원인이 무엇인지 파악할 필요가 있습니다.

-> 결론:
큰 추세(2019~2020 상승장 등)에는 수익을 크게 내고, 일부 구간(예: 2018, 2022)에는 손실이 발생하며,
전반적으로 약 **45%**의 최종 수익률, 낮은 MDD(-5.05%)로, 안정적이나 폭발적이지는 않은 성장을 달성한 결과로 보입니다.
세부 지표(연도별·월별 성과, 승률, MDD) 역시 크게 이질적인 구간이 없으므로, “월별·연간 성과 및 MDD 확인”은 정상적으로 마무리되었다고 볼 수 있습니다.
---

## 2) (옵션) 파라미터 튜닝(Param Sweep) 간단 시도

현재 단일 파라미터로 `window=20`, `atr_multiplier=2.0`, `profit_ratio=0.05` 등이 고정되어 있을 텐데,  
- `window`를 10/20/30, `atr_multiplier`를 1.5/2.0/2.5 식으로 몇 가지만 바꿔가며,  
- **“여러 후보 파라미터” → 백테스트 결과를 비교**해보는 작업을 해도 좋습니다.

이 과정을 통해서
- “단순버전에서 내 전략이 어떤 파라미터 조합에서 가장 나은가?”  
- “극단적 파라미터로 넣었을 때 이상한 결과가 나오지 않는가?”  

등을 확인할 수 있습니다.  
물론 **과최적화**를 피하려면, 이 튜닝 작업도 어디까지 할지 적절한 선에서 마무리해야겠지만,  
**MTF 확장 전에** 한 번쯤 해보면 코드 안정성/유연성을 더 잘 느낄 수 있습니다.

-> 결론:
가장 높은 ROI: (window=10, atr_multiplier=1.5, profit_ratio=0.05) → 66.14%
공격적 매매(잦은 진입/청산 + 짧은 손절 + 큰 익절폭)
MDD -7.19%, 승률 48.82%

전반적 트렌드:
ATR 배수 1.5가 대체로 ROI를 높임 (적극적 손절)
**익절(0.05)**가 0.03보다 큰 수익을 냄 (추세 이어갈 때 더 많은 이익)
window=10이 가장 공격적, window=30은 좀 더 보수적

주의:
과최적화(Overfitting) 가능성을 반드시 염두에 두어야 함
“높은 ROI” 조합이 실전에서 좋은 성과를 낸다는 보장은 없음 (슬리피지, 수수료 증가, 시장 변동성 변화 등)
워크포워드(Out-of-Sample) 검증, 실시간 모의매매 등을 통해 추가 확인이 필요

추가 지표
연속 손실 횟수, 손익비(R:R), 최대 승률 / 최소 손익률 구간 등도 검토
실제 투자 성향(고승률 vs 고수익 vs 안정성)에 따라 최적 조합이 달라질 수 있음

단순 ROI만 보면 (10, 1.5, 0.05)가 가장 강력.
그러나 안정성 면에서 window=20 or 30 + atr_multiplier=1.5도 충분히 매력적 (ROI 50% 전후, MDD -5% 내외).
최종 선택 전 추가 검증 & 개인 성향 고려가 필수.
####################################################################################################

---

## 2. 다중 타임프레임(MTF)로 확장

1. **데이터 수집 측면**  
   - 이미 4시간봉(예)만 있던 것을, “1일봉, 1시간봉” 등 원하는 타임프레임을 추가로 DB에 쌓거나, CSV로 준비.  

2. **시그널 계산 측면**  
   - “하이타임프레임(예: 1일봉) 추세 확인 → 로우타임프레임(예: 4시간봉) 돌파 시그널만 매매” 같은 로직이 많습니다.  
   - 구현 방식은 크게 두 가지:
     - (A) **단일 DataFrame**에 여러 타임프레임 데이터를 병합(merge)하여, “일봉 지표 컬럼”, “4시간봉 지표 컬럼”을 같이 가지고 있음.  
     - (B) **각 타임프레임별로 별도 DataFrame**을 유지하고, 백테스트 중에 시간 축을 맞춰가며(동기화) 참조.  

3. **백테스트 루프에서의 처리**  
   - “이번 4시간봉 시점에, 일봉에서의 (MA, MACD 등) 최근 값은 무엇인가?”를 찾아 반영.  
   - 데이터 인덱스/타임스탬프를 맞춰서 다룰 수 있어야 하므로, **리샘플링**이나 **정렬**이 필요할 수 있습니다.  

4. **차근차근**  
   - 처음부터 여러 타임프레임 다 쓰려면 복잡도가 확 올라가니,  
   - **(1일봉 시그널) + (4시간봉 매매 타이밍)** 같은 2개 TF 조합부터 시도해보면 좋습니다.

---

## 3. 동적 파라미터 조정(Adaptive Parameter)

1. **정적 파라미터** 예  
   - (예) 돌파기간 `window=20`, ATR배수 `atr_multiplier=2.0`, 거래량 배수 `vol_factor=1.5` …  
   - 백테스트 시, 하나씩 바꿔가며 실험(브루트포스) → 최적값 찾기(파라메트릭 스윕).  
   - 이 단계까지만 해도 충분히 할 일이 많습니다.

2. **동적(Adaptive) 파라미터**  
   - 시간 경과나 시장 상황에 따라 파라미터를 실시간으로 변경하는 기법. (예: 변동성이 높아지면 window를 줄이고, 낮아지면 늘린다 등)  
   - 구현 방식:  
     - 백테스트 루프 속에서, 일정 주기(예: 매 N 봉)마다 시장 상태를 판단 → 파라미터 재설정.  
     - 또는, 일봉 지표나 VIX(파생상품) 등으로 변동성 지표를 측정해, “ATR 높으면 돌파기간 단축” 같은 규칙을 세움.

3. **단계적 접근**  
   - 먼저 “정적 파라미터 전략”을 충분히 시험해보고, 그 이후 “어떤 기준으로 파라미터를 동적으로 바꿀지” 규칙을 구체화.  
   - 동적 파라미터는 구현 복잡도 + 과적합 가능성도 올라가기 때문에, 주의 깊게 진행해야 합니다.

---

## 4. 과적합 방지

1. **과적합(Overfitting)**이란?  
   - 백테스트 결과는 ‘과거 데이터’에서 최적화되었지만, 실제 미래 시장에서는 성과가 기대에 미치지 못하는 현상.  
   - 파라미터를 너무 많이 혹은 너무 세밀하게 튜닝하면 발생 확률이 커짐.

2. **대표적 방법**  
   1) **Out-of-Sample(검증 구간) 분리**  
      - 과거 5년치 데이터 중 3년은 훈련(파라미터 최적화), 나머지 2년은 검증(테스트) 구간으로 나누어, 최적 파라미터를 검증 구간에 적용해보는 방식.  
   2) **Walk-Forward Analysis(워크포워드)**  
      - 일정 기간(예: 1년) 간 데이터를 학습해 파라미터를 정하고, 그 파라미터로 다음 3개월(실전)에 적용 → 성과 기록. → 다음 구간으로 넘어가 반복.  
   3) **Cross Validation**  
      - 여러 시계열 구간을 겹치지 않게 나누어 각각 성능을 평가.  
   4) **복잡도 줄이기**  
      - 파라미터 개수를 너무 많이 두지 않고(단순화), “기초적 로직” 위주로 전략을 설계.

3. **테스트 자동화**  
   - 백테스트 스크립트를 짜놓고, 파라미터 여러 후보(예: window=10,20,30 / atr_multiplier=1.5,2.0,2.5 …)에 대해 일괄 실행시키면서,  
   - Out-of-Sample 구간 성능이 가장 좋은 쪽을 찾거나, 여러 지표(승률, MDD, Profit Factor 등)를 비교해서 최종 선택.

---

## 5. 페이퍼 트레이딩(실전 모의)

1. **백테스트 → 실전 적용 전**  
   - 한두 달 정도 “실시간 모의매매(페이퍼 트레이딩)”를 운영해보면,  
   - 백테스트와 실제 시장 흐름의 차이(슬리피지, 재정거래, API 지연 등)를 체감할 수 있음.

2. **실시간 데이터 처리**  
   - 백테스트는 과거 데이터 일괄처리지만, 페이퍼 트레이딩은 **실시간으로 들어오는 시세**를 받으며, 매 봉이 끝날 때마다 전략을 수행.  
   - 구조적으로는 “백테스트의 루프”가 “실시간 스케줄러(혹은 이벤트)”로 바뀐 형태.  

3. **주문 체결 시뮬레이션**  
   - 페이퍼 트레이딩에서, 거래소 API를 통해 ‘가상 주문’만 넣고, 체결 여부를 mock(모의) 처리.  
   - 이 과정을 통해, **“전략이 실제 시장의 체결 지연, 가격 변동을 어느 정도 감안 가능한지”** 점검 가능.

---

## 6. 정리 (추천 순서)

1. **가장 단순 버전**의 백테스트 엔진부터 만든다.  
   - 단일 타임프레임, 단일 심볼, 고정 파라미터  
   - 시그널 + 포지션 관리 + 매매 기록 + 성과 지표 계산

2. **실제 잘 동작하는지**(논리검증) → 차트로 시각화하여 “여기서 매수, 여기서 매도”가 맞는지 확인.  
   - 이렇게 작은 단위라도 실질적으로 ‘완성’된 상태를 먼저 얻어야 합니다.

3. **다중 타임프레임** → 하나씩 확장  
   - 데이터 병합/인덱스 동기화  
   - 백테스트 루프에서 “(고차원) 일봉 지표”와 “(저차원) 4시간봉 시그널” 함께 활용

4. **파라미터 튜닝 / 동적 파라미터**  
   - 처음엔 정적 튜닝부터 → 나중에 동적 로직으로 발전  
   - 워크포워드/Out-of-Sample을 통해 과적합 방지

5. **페이퍼 트레이딩**  
   - 실시간 시장 데이터를 받아 모의체결  
   - 슬리피지, 수수료 등을 좀 더 현실적으로 반영해보고, 결과를 확인

6. (최종) **실거래**  
   - 소액으로 시도 → 점차 확대

---

## 결론

- **단계별로 확장**하면 충분히 할 수 있습니다.  
- 처음부터 모든 기능(다중 타임프레임, 동적 파라미터, 과적합 방지 등)을 한 번에 구현하려고 하면 **복잡도가 기하급수적으로 상승**해서 혼란에 빠지게 됩니다.  
- **“단순한 버전”**을 일단 **빈틈없이 동작**시키고 → **하나씩** 확장하는 방식이,  
  - 학습 효율도 높고,  
  - 디버깅/유지보수도 용이하며,  
  - 결국엔 더 빨리 완성할 수 있는 지름길입니다.  

이런 순서대로 진행해보시면, 중간 중간에 “내가 어떤 부분을 해야 하지?”라는 막막함이 훨씬 줄어드실 거예요.  

[지시사항]
