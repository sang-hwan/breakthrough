[trading 모듈]
# trading/backtester.py

# pandas 라이브러리: 데이터프레임 조작 및 시간 관련 처리를 위해 사용
import pandas as pd

# 로그 설정을 위한 모듈 (로깅 설정 및 유틸리티 제공)
from logging.logger_config import setup_logger
# 리스크 관리 관련 모듈: 포지션 사이즈 계산, 리스크 제어 기능 제공
from trading.risk_manager import RiskManager 
# 거래 실행 관련 모듈: 거래 체결, 슬리피지 및 수수료 적용 기능 제공
from trading.trade_executor import TradeExecutor
# 계좌 관리 관련 모듈: 초기 자본, 잔액 업데이트 등 관리
from asset_position.account import Account
# 포지션(거래 단위) 관련 모듈
from asset_position.position import Position
# 자산 배분 및 관리 모듈
from asset_position.asset_manager import AssetManager
# 앙상블 전략 관련 모듈 (여러 전략 결합 시 사용)
from signal_calculation.ensemble import Ensemble
# 환경설정 관리 모듈
from parameters_sensitivity.config_manager import ConfigManager
# 추가 로깅 유틸리티
from logging.logging_util import LoggingUtil

# 전역 로깅 유틸 객체: 현재 모듈의 이름으로 로그 기록
log_util = LoggingUtil(__name__)

class Backtester:
    """
    백테스터 클래스
    -----------------
    여러 거래 전략 및 리스크 관리, 데이터 로딩, 인디케이터 적용, 거래 신호 처리 등을 포함하는 
    백테스팅 전체 파이프라인을 관리하는 클래스입니다.
    
    전역 변수 및 객체:
      - symbol: 거래할 종목 심볼 (예: "BTC/USDT")
      - fee_rate: 거래 수수료 비율
      - slippage_rate: 슬리피지 비율
      - final_exit_slippage: 최종 청산 시 적용할 슬리피지
      - positions: 현재 보유한 포지션 리스트
      - trades: 실행된 거래 내역 리스트
      - trade_logs: 상세 거래 로그 리스트
      - logger: 모듈 전용 로깅 객체
      - config_manager: 설정 및 파라미터 관리 객체
      - account: 거래 계좌 관리 객체
      - asset_manager: 자산 배분 관리 객체
      - ensemble_manager: 앙상블 전략 관리 객체
      - risk_manager: 리스크 관리 객체
      - clock: 현재 시간을 반환하는 람다 함수 (기본: pd.Timestamp.now)
      - state: 상태 정보를 저장하는 딕셔너리
      - 그 외 데이터프레임 및 시간 관련 변수들
    """
    def __init__(self, symbol="BTC/USDT", account_size=10000.0, fee_rate=0.001, 
                 slippage_rate=0.0005, final_exit_slippage=0.0):
        # 거래할 종목과 관련 파라미터 설정
        self.symbol = symbol
        self.fee_rate = fee_rate
        self.slippage_rate = slippage_rate
        self.final_exit_slippage = final_exit_slippage
        # 포지션, 거래, 거래 로그를 저장할 리스트 초기화
        self.positions = []
        self.trades = []
        self.trade_logs = []
        # 모듈 전용 로거 객체 초기화
        self.logger = setup_logger(__name__)
        # 설정 관리 객체 초기화 (동적 파라미터, 환경설정 관리)
        self.config_manager = ConfigManager()
        # 거래 계좌 객체 생성 (초기 잔액, 수수료 적용)
        self.account = Account(initial_balance=account_size, fee_rate=fee_rate)
        # 자산 배분 관리자 초기화
        self.asset_manager = AssetManager(self.account)
        # 앙상블 전략 관리자 초기화 (여러 전략 결합 시 활용)
        self.ensemble_manager = Ensemble()
        # 리스크 관리 객체 초기화
        self.risk_manager = RiskManager()
        # 마지막 신호 발생 시각 초기화
        self.last_signal_time = None
        # 상승 진입 이벤트 로그 저장 리스트
        self.bullish_entry_events = []
        # HMM(은닉 마르코프 모델) 관련 변수 초기화
        self.hmm_model = None
        self.last_hmm_training_datetime = None
        # 추가 데이터프레임 변수: 추가 데이터, 주간 데이터 등
        self.df_extra = None
        self.df_weekly = None
        # 리밸런싱 관련 시각 변수 초기화
        self.last_rebalance_time = None
        self.last_weekly_close_date = None
        # 현재 시간을 반환하는 함수 (pandas Timestamp)
        self.clock = lambda: pd.Timestamp.now()
        # 임의 상태 정보를 저장할 딕셔너리
        self.state = {}

    def get_current_time(self):
        """
        현재 시각 반환 함수
        --------------------
        현재 백테스트에서 사용 중인 시간(타임스탬프)을 반환합니다.
        
        Returns:
          pd.Timestamp: 현재 시각
        """
        return self.clock()

    def load_data(self, short_table_format, long_table_format, short_tf, long_tf, 
                  start_date=None, end_date=None, extra_tf=None, use_weekly=False):
        """
        데이터 로딩 함수
        ----------------
        지정한 포맷과 타임프레임에 따라 백테스트용 데이터 로딩을 수행합니다.
        
        Parameters:
          short_table_format (str): 짧은 데이터 테이블 포맷
          long_table_format (str): 긴 데이터 테이블 포맷
          short_tf (str): 짧은 타임프레임 (예: '1m', '5m')
          long_tf (str): 긴 타임프레임 (예: '1h', '1d')
          start_date (str, optional): 시작 날짜 (YYYY-MM-DD 등)
          end_date (str, optional): 종료 날짜
          extra_tf (str, optional): 추가 타임프레임 데이터
          use_weekly (bool): 주간 데이터 사용 여부
        
        Returns:
          None
        """
        # 데이터 로딩 모듈을 임포트하고 호출
        from backtesting.steps.data_loader import load_data
        load_data(self, short_table_format, long_table_format, short_tf, long_tf, start_date, end_date, extra_tf, use_weekly)

    def apply_indicators(self):
        """
        인디케이터 적용 함수
        ---------------------
        데이터프레임에 기술적 인디케이터(예: SMA, RSI 등)를 적용합니다.
        
        Returns:
          None
          
        Raises:
          Exception: 인디케이터 적용 중 오류 발생 시 예외 전달
        """
        from backtesting.steps.indicator_applier import apply_indicators
        try:
            apply_indicators(self)
        except Exception as e:
            # 인디케이터 적용 중 오류 발생 시 로그 기록 및 예외 재발생
            self.logger.error("Error applying indicators: " + str(e), exc_info=True)
            raise

    def update_hmm_regime(self, dynamic_params):
        """
        HMM 시장 상태 업데이트 함수
        -----------------------------
        HMM(은닉 마르코프 모델)을 사용해 시장 상태(예: bullish, bearish, sideways)를 예측 및 업데이트합니다.
        또한 장기 SMA와 현재 가격을 비교해 상태를 조정합니다.
        
        Parameters:
          dynamic_params (dict): HMM 관련 재학습 주기, 샘플 개수, 피처 변화 임계치 등 동적 파라미터
        
        Returns:
          pd.Series: 시장 상태 레이블 시리즈 (인덱스: 날짜, 값: 상태 문자열)
        """
        try:
            # HMM 학습에 사용할 피처 목록 정의
            hmm_features = ['returns', 'volatility', 'sma', 'rsi', 'macd_macd', 'macd_signal', 'macd_diff']
            # 데이터프레임의 마지막 인덱스를 현재 시각으로 사용
            current_dt = self.df_long.index.max()
            # 재학습 간격 및 샘플 수 관련 파라미터 추출
            retrain_interval_minutes = dynamic_params.get('hmm_retrain_interval_minutes', 60)
            retrain_interval = pd.Timedelta(minutes=retrain_interval_minutes)
            max_samples = dynamic_params.get('max_hmm_train_samples', 1000)
            min_samples = dynamic_params.get('min_hmm_train_samples', 50)
            feature_change_threshold = dynamic_params.get('hmm_feature_change_threshold', 0.01)

            # 최소 샘플 수 부족 시 에러 로그 후 'sideways' 상태 반환
            if len(self.df_long) < min_samples:
                self.logger.error(f"Not enough samples for HMM training (min required: {min_samples}).", exc_info=True)
                return pd.Series(["sideways"] * len(self.df_long), index=self.df_long.index)

            # HMM 모델이 없거나 최초 학습인 경우 초기화 및 학습 수행
            if self.hmm_model is None or self.last_hmm_training_datetime is None:
                from market_analysis.regime_model import MarketRegimeHMM
                self.hmm_model = MarketRegimeHMM(n_components=3, retrain_interval_minutes=retrain_interval_minutes)
                training_data = self.df_long if len(self.df_long) <= max_samples else self.df_long.tail(max_samples)
                self.hmm_model.train(training_data, feature_columns=hmm_features)
                self.last_hmm_training_datetime = current_dt
                log_util.log_event("HMM updated", state_key="hmm_update")
            else:
                # 기존 HMM 모델이 존재하는 경우 현재 데이터의 피처 평균과 이전 통계 비교
                training_data = self.df_long if len(self.df_long) <= max_samples else self.df_long.tail(max_samples)
                current_means = training_data[hmm_features].mean()
                diff = (abs(current_means - self.hmm_model.last_feature_stats).mean() 
                        if self.hmm_model.last_feature_stats is not None else float('inf'))
                # 재학습 주기 경과 또는 피처 변화가 임계치를 초과하면 재학습 수행
                if (current_dt - self.last_hmm_training_datetime) >= retrain_interval or diff >= feature_change_threshold:
                    self.hmm_model.train(training_data, feature_columns=hmm_features)
                    self.last_hmm_training_datetime = current_dt
                    self.logger.debug(f"HMM 재학습 완료 (피처 변화 diff: {diff:.6f})")
                else:
                    self.logger.debug(f"HMM 재학습 스킵 (피처 변화 diff: {diff:.6f})")

            # HMM 모델을 이용해 시장 상태 예측
            predicted_regimes = self.hmm_model.predict_regime_labels(self.df_long, feature_columns=hmm_features)
            # 장기 SMA 계산 (예: 200일 이동평균)
            sma_period = dynamic_params.get('sma_period', 200)
            self.df_long['long_term_sma'] = self.df_long['close'].rolling(window=sma_period, min_periods=1).mean()
            adjusted_regimes = []
            # 각 시점별로 현재 가격과 SMA 비교 후 상태 조정
            for idx, predicted in enumerate(predicted_regimes):
                close_price = self.df_long['close'].iloc[idx]
                sma_price = self.df_long['long_term_sma'].iloc[idx]
                threshold = 0.01 * sma_price
                if close_price < sma_price - threshold:
                    adjusted_regime = "bearish"
                elif close_price > sma_price + threshold:
                    adjusted_regime = "bullish"
                else:
                    adjusted_regime = predicted
                adjusted_regimes.append(adjusted_regime)
            return pd.Series(adjusted_regimes, index=self.df_long.index)
        except Exception as e:
            self.logger.error("Error updating HMM regime: " + str(e), exc_info=True)
            return pd.Series(["sideways"] * len(self.df_long), index=self.df_long.index)

    def update_short_dataframe(self, regime_series, dynamic_params):
        """
        짧은 타임프레임 데이터프레임 업데이트 함수
        -------------------------------------------
        장기 데이터(df_long)의 기술적 인디케이터와 시장 상태를 짧은 타임프레임 데이터(df_short)에 병합하고,
        ATR(평균 진폭 범위) 기반의 스톱로스 가격을 계산합니다.
        
        Parameters:
          regime_series (pd.Series): 시장 상태 시리즈 (인덱스: 날짜, 값: 상태 문자열)
          dynamic_params (dict): 동적 파라미터 (ATR 기간 등 포함)
        
        Returns:
          None
        """
        try:
            # df_long에서 sma, rsi, volatility 컬럼을 df_short에 결합 (좌측 조인 후 결측값 전파)
            self.df_short = self.df_short.join(self.df_long[['sma', 'rsi', 'volatility']], how='left').ffill()
            # 시장 상태 정보를 df_short에 추가 (인덱스 기준 재배열 및 전파)
            self.df_short['market_regime'] = regime_series.reindex(self.df_short.index).ffill()
            # ATR 계산 함수 호출: 주어진 기간 내 변동성을 반영해 ATR 산출
            self.df_short = TradeExecutor.compute_atr(self.df_short, period=dynamic_params.get("atr_period", 14))
            # 스톱로스 가격 계산: 현재 가격에서 ATR에 배수를 곱한 값 차감
            default_atr_multiplier = dynamic_params.get("default_atr_multiplier", 2.0)
            self.df_short["stop_loss_price"] = self.df_short["close"] - (self.df_short["atr"] * default_atr_multiplier)
        except Exception as e:
            self.logger.error("Error updating short dataframe: " + str(e), exc_info=True)
            raise

    def handle_walk_forward_window(self, current_time, row):
        """
        워크포워드 윈도우 처리 함수
        ----------------------------
        워크포워드 기간 종료 시 모든 미체결 포지션에 대해 청산 처리를 수행합니다.
        
        Parameters:
          current_time (pd.Timestamp): 현재 시각
          row (pd.Series): 현재 데이터 행 (예: 가격 정보 포함)
        
        Returns:
          None
        """
        try:
            # 보유 포지션 각각에 대해 실행 기록을 확인하며 청산 처리
            for pos in self.positions:
                for exec_record in pos.executions:
                    # 아직 청산되지 않은 실행 기록에 대해 처리
                    if not exec_record.get("closed", False):
                        final_close = row["close"]
                        # 최종 슬리피지 적용 (없으면 그대로 사용)
                        adjusted_final_close = final_close * (1 - self.final_exit_slippage) if self.final_exit_slippage else final_close
                        # 슬리피지 비율 적용하여 최종 청산 가격 계산
                        exit_price = adjusted_final_close * (1 - self.slippage_rate)
                        size_value = exec_record["size"]
                        if isinstance(size_value, list):
                            size_value = sum(size_value)
                        # 거래 수수료 계산
                        fee = exit_price * size_value * self.fee_rate
                        # 손익 계산: (청산 가격 - 진입 가격) * 사이즈 - 수수료
                        pnl = (exit_price - exec_record["entry_price"]) * size_value - fee
                        exec_record["closed"] = True
                        # 거래 상세 내역 구성
                        trade_detail = {
                            "entry_time": exec_record["entry_time"],
                            "entry_price": exec_record["entry_price"],
                            "exit_time": current_time,
                            "exit_price": exit_price,
                            "size": size_value,
                            "pnl": pnl,
                            "reason": "walk_forward_window_close",
                            "trade_type": exec_record.get("trade_type", "unknown"),
                            "position_id": pos.position_id
                        }
                        # 로그 및 거래 내역 업데이트
                        self.trade_logs.append(trade_detail)
                        self.trades.append(trade_detail)
                        self.account.update_after_trade(trade_detail)
            # 모든 포지션을 청산 후 초기화
            self.positions = []
        except Exception as e:
            self.logger.error("Error during walk-forward window handling: " + str(e), exc_info=True)
            raise

    def handle_weekly_end(self, current_time, row):
        """
        주간 종료 처리 함수
        --------------------
        주간 종료 시 모든 미체결 포지션에 대해 청산 처리를 수행하여 주간 거래를 마감합니다.
        
        Parameters:
          current_time (pd.Timestamp): 현재 시각
          row (pd.Series): 현재 데이터 행 (종가 등 포함)
        
        Returns:
          None
        """
        try:
            final_close = row["close"]
            adjusted_final_close = final_close * (1 - self.final_exit_slippage) if self.final_exit_slippage else final_close
            for pos in self.positions:
                for exec_record in pos.executions:
                    if not exec_record.get("closed", False):
                        exit_price = adjusted_final_close * (1 - self.slippage_rate)
                        size_value = exec_record["size"]
                        if isinstance(size_value, list):
                            size_value = sum(size_value)
                        fee = exit_price * size_value * self.fee_rate
                        pnl = (exit_price - exec_record["entry_price"]) * size_value - fee
                        exec_record["closed"] = True
                        trade_detail = {
                            "entry_time": exec_record["entry_time"],
                            "entry_price": exec_record["entry_price"],
                            "exit_time": current_time,
                            "exit_price": exit_price,
                            "size": size_value,
                            "pnl": pnl,
                            "reason": "weekly_end_close",
                            "trade_type": exec_record.get("trade_type", "unknown"),
                            "position_id": pos.position_id
                        }
                        self.trade_logs.append(trade_detail)
                        self.trades.append(trade_detail)
                        self.account.update_after_trade(trade_detail)
            self.positions = []
        except Exception as e:
            self.logger.error("Error during weekly end handling: " + str(e), exc_info=True)
            raise

    def process_bullish_entry(self, current_time, row, risk_params, dynamic_params):
        """
        강세 진입(롱) 신호 처리 함수
        ----------------------------
        주어진 조건 하에서 강세 신호가 발생하면 기존 포지션에 추가 진입(scale-in)하거나 신규 포지션을 생성합니다.
        
        Parameters:
          current_time (pd.Timestamp): 현재 시각
          row (pd.Series): 현재 데이터 행 (가격, 스톱로스 등 정보 포함)
          risk_params (dict): 리스크 관리 관련 파라미터 (예: 리스크 비율 등)
          dynamic_params (dict): 동적 파라미터 (예: 신호 쿨다운, 분할 매수 기준 등)
        
        Returns:
          None
        """
        try:
            close_price = row["close"]
            # 신호 재발생 방지를 위해 일정 시간 동안 추가 신호를 무시
            signal_cooldown = pd.Timedelta(minutes=dynamic_params.get("signal_cooldown_minutes", 5))
            if self.last_signal_time is not None and (current_time - self.last_signal_time) < signal_cooldown:
                return

            # 스톱로스 가격이 없으면 기본값(현재 가격의 95%) 사용
            stop_loss_price = row.get("stop_loss_price")
            if stop_loss_price is None:
                stop_loss_price = close_price * 0.95
                self.logger.error(
                    f"Missing stop_loss_price for bullish entry. 기본값 사용: {stop_loss_price:.2f}.", exc_info=True
                )

            # 이미 롱 포지션이 존재하는 경우 추가 진입(scale in) 시도
            for pos in self.positions:
                if pos.side == "LONG":
                    additional_size = self.risk_manager.compute_position_size(
                        available_balance=self.account.get_available_balance(),
                        risk_percentage=risk_params.get("risk_per_trade"),
                        entry_price=close_price,
                        stop_loss=stop_loss_price,
                        fee_rate=self.fee_rate,
                        volatility=row.get("volatility", 0)
                    )
                    required_amount = close_price * additional_size * (1 + self.fee_rate)
                    if self.account.get_available_balance() >= required_amount:
                        threshold = dynamic_params.get("scale_in_threshold", 0.02)
                        # 가격이 낮은 종목의 경우 threshold 절반 적용
                        effective_threshold = threshold * (0.5 if close_price < 10 else 1)
                        self.risk_manager.attempt_scale_in_position(
                            position=pos,
                            current_price=close_price,
                            scale_in_threshold=effective_threshold,
                            slippage_rate=self.slippage_rate,
                            stop_loss=stop_loss_price,
                            take_profit=row.get("take_profit_price"),
                            entry_time=current_time,
                            trade_type="scale_in"
                        )
                        self.last_signal_time = current_time
                        return
            # 신규 포지션 진입 계산
            total_size = self.risk_manager.compute_position_size(
                available_balance=self.account.get_available_balance(),
                risk_percentage=risk_params.get("risk_per_trade"),
                entry_price=close_price,
                stop_loss=stop_loss_price,
                fee_rate=self.fee_rate,
                volatility=row.get("volatility", 0)
            )
            required_amount = close_price * total_size * (1 + self.fee_rate)
            if self.account.get_available_balance() >= required_amount:
                # 신규 포지션 생성 (롱)
                new_position = Position(
                    side="LONG",
                    initial_price=close_price,
                    maximum_size=total_size,
                    total_splits=dynamic_params.get("total_splits", 3),
                    allocation_plan=self.risk_manager.allocate_position_splits(
                        total_size=1.0,
                        splits_count=dynamic_params.get("total_splits", 3),
                        allocation_mode=dynamic_params.get("allocation_mode", "equal")
                    )
                )
                try:
                    # 단기 데이터에서 ATR 값을 가져옴 (없으면 0)
                    atr_value = self.df_short.loc[current_time, "atr"]
                except KeyError:
                    atr_value = 0
                # 동적 스톱로스 및 테이크 프로핏 가격 계산
                stop_loss_price_new, take_profit_price = TradeExecutor.calculate_dynamic_stop_and_take(
                    entry_price=close_price,
                    atr=atr_value,
                    risk_params=risk_params
                )
                new_position.add_execution(
                    entry_price=close_price * (1 + self.slippage_rate),
                    size=total_size * new_position.allocation_plan[0],
                    stop_loss=stop_loss_price_new,
                    take_profit=take_profit_price,
                    entry_time=current_time,
                    exit_targets=TradeExecutor.calculate_partial_exit_targets(
                        entry_price=close_price,
                        partial_exit_ratio=dynamic_params.get("partial_exit_ratio", 0.5),
                        partial_profit_ratio=dynamic_params.get("partial_profit_ratio", 0.03),
                        final_profit_ratio=dynamic_params.get("final_profit_ratio", 0.06)
                    ),
                    trade_type="new_entry"
                )
                new_position.executed_splits = 1
                # 신규 포지션을 보유 포지션 및 계좌에 추가
                self.positions.append(new_position)
                self.account.add_position(new_position)
                self.last_signal_time = current_time
        except Exception as e:
            self.logger.error("Error processing bullish entry: " + str(e), exc_info=True)
            raise

    def process_bearish_exit(self, current_time, row):
        """
        약세 청산 신호 처리 함수
        --------------------------
        모든 미체결 롱 포지션에 대해 약세 신호가 발생하면 청산을 진행합니다.
        
        Parameters:
          current_time (pd.Timestamp): 현재 시각
          row (pd.Series): 현재 데이터 행 (가격 정보 포함)
        
        Returns:
          None
        """
        try:
            close_price = row["close"]
            for pos in self.positions:
                for exec_record in pos.executions:
                    if not exec_record.get("closed", False):
                        # 슬리피지 적용하여 청산 가격 산출
                        exit_price = close_price * (1 - self.slippage_rate)
                        size_value = exec_record["size"]
                        if isinstance(size_value, list):
                            size_value = sum(size_value)
                        fee = exit_price * size_value * self.fee_rate
                        pnl = (exit_price - exec_record["entry_price"]) * size_value - fee
                        exec_record["closed"] = True
                        trade_detail = {
                            "entry_time": exec_record["entry_time"],
                            "entry_price": exec_record["entry_price"],
                            "exit_time": current_time,
                            "exit_price": exit_price,
                            "size": size_value,
                            "pnl": pnl,
                            "reason": "exit_regime_change",
                            "trade_type": exec_record.get("trade_type", "unknown"),
                            "position_id": pos.position_id
                        }
                        self.trade_logs.append(trade_detail)
                        self.trades.append(trade_detail)
                        self.account.update_after_trade(trade_detail)
            # 약세 청산 후 마지막 신호 시각 업데이트
            self.last_signal_time = current_time
        except Exception as e:
            self.logger.error("Error processing bearish exit: " + str(e), exc_info=True)
            raise

    def process_sideways_trade(self, current_time, row, risk_params, dynamic_params):
        """
        횡보장(사이드웨이) 거래 처리 함수
        ----------------------------------
        횡보장일 경우 유동성 정보에 따라 조건에 맞으면 강세 진입 또는 약세 청산을 호출합니다.
        
        Parameters:
          current_time (pd.Timestamp): 현재 시각
          row (pd.Series): 현재 데이터 행 (가격 등 포함)
          risk_params (dict): 리스크 관리 관련 파라미터
          dynamic_params (dict): 동적 파라미터 (유동성 정보 등)
        
        Returns:
          None
        """
        try:
            close_price = row["close"]
            # 동적 파라미터에서 유동성 정보 확인 (기본값 'high')
            liquidity = dynamic_params.get('liquidity_info', 'high').lower()
            if liquidity == "high":
                # 고유동성 시장: 최근 20개 행의 최저가 기준 비교
                lower_bound = self.df_short['low'].rolling(window=20, min_periods=1).min().iloc[-1]
                if close_price <= lower_bound:
                    self.process_bullish_entry(current_time, row, risk_params, dynamic_params)
            else:
                # 저유동성 시장: 평균 및 표준편차 기반 비교
                mean_price = self.df_short['close'].rolling(window=20, min_periods=1).mean().iloc[-1]
                std_price = self.df_short['close'].rolling(window=20, min_periods=1).std().iloc[-1]
                if close_price < mean_price - std_price:
                    self.process_bullish_entry(current_time, row, risk_params, dynamic_params)
                elif close_price > mean_price + std_price:
                    self.process_bearish_exit(current_time, row)
        except Exception as e:
            self.logger.error("Error processing sideways trade: " + str(e), exc_info=True)
            raise

    def update_positions(self, current_time, row):
        """
        포지션 업데이트 함수
        ---------------------
        보유 포지션의 최고 가격을 갱신하고, 이에 따라 트레일링 스톱을 조정합니다.
        
        Parameters:
          current_time (pd.Timestamp): 현재 시각
          row (pd.Series): 현재 데이터 행 (종가 포함)
        
        Returns:
          None
        """
        try:
            close_price = row["close"]
            for pos in self.positions:
                for exec_record in pos.executions:
                    if not exec_record.get("closed", False):
                        # 현재 가격과 기존 최고 가격 비교 후 갱신
                        pos.highest_price = max(pos.highest_price, close_price)
                        new_stop = TradeExecutor.adjust_trailing_stop(
                            current_stop=row.get("stop_loss_price", 0),
                            current_price=close_price,
                            highest_price=pos.highest_price,
                            trailing_percentage=self.config_manager.get_defaults().get("trailing_percent", 0.045)
                        )
                        exec_record["stop_loss"] = new_stop
        except Exception as e:
            self.logger.error("Error updating positions: " + str(e), exc_info=True)
            raise

    def finalize_all_positions(self):
        """
        모든 포지션 최종 청산 함수
        ---------------------------
        백테스트 종료 시점에서 남은 미체결 포지션을 모두 청산하고 거래 내역을 업데이트합니다.
        
        Returns:
          None
        """
        try:
            final_time = self.df_short.index[-1]
            final_close = self.df_short.iloc[-1]["close"]
            adjusted_final_close = final_close * (1 - self.final_exit_slippage) if self.final_exit_slippage else final_close
            for pos in self.positions:
                for exec_record in pos.executions:
                    if not exec_record.get("closed", False):
                        exit_price = adjusted_final_close * (1 - self.slippage_rate)
                        size_value = exec_record["size"]
                        if isinstance(size_value, list):
                            size_value = sum(size_value)
                        fee = exit_price * size_value * self.fee_rate
                        pnl = (exit_price - exec_record["entry_price"]) * size_value - fee
                        exec_record["closed"] = True
                        trade_detail = {
                            "entry_time": exec_record["entry_time"],
                            "entry_price": exec_record["entry_price"],
                            "exit_time": final_time,
                            "exit_price": exit_price,
                            "size": size_value,
                            "pnl": pnl,
                            "reason": "final_exit",
                            "trade_type": exec_record.get("trade_type", "unknown"),
                            "position_id": pos.position_id
                        }
                        self.trade_logs.append(trade_detail)
                        self.trades.append(trade_detail)
                        self.account.update_after_trade(trade_detail)
            self.positions = []
        except Exception as e:
            self.logger.error("Error finalizing positions: " + str(e), exc_info=True)
            raise

    def monitor_orders(self, current_time, row):
        """
        주문 모니터링 함수
        ------------------
        포지션별로 미체결 주문이 존재하는 경우, 가격 급변동 등을 모니터링하여 로그를 기록합니다.
        
        Parameters:
          current_time (pd.Timestamp): 현재 시각
          row (pd.Series): 현재 데이터 행 (가격 정보 포함)
        
        Returns:
          None
        """
        try:
            for pos in self.positions:
                for exec_record in pos.executions:
                    if not exec_record.get("closed", False):
                        self.logger.debug(f"Significant price move for position {pos.position_id}.")
        except Exception as e:
            self.logger.error("Error monitoring orders: " + str(e), exc_info=True)
            raise

    def run_backtest(self, dynamic_params=None, walk_forward_days: int = None, holdout_period: tuple = None):
        """
        백테스트 실행 함수
        ------------------
        백테스트 파이프라인 전체를 실행하며, 데이터 준비, 인디케이터 적용, HMM 업데이트, 주문 처리 등을 순차적으로 진행합니다.
        
        Parameters:
          dynamic_params (dict, optional): 동적 파라미터 (없으면 기본값 사용)
          walk_forward_days (int, optional): 워크포워드 기간 (일 단위)
          holdout_period (tuple, optional): (시작, 종료) 기간을 포함하는 holdout 기간
        
        Returns:
          tuple: (trades, trade_logs) - 거래 내역 및 로그 리스트
        
        Raises:
          Exception: 백테스트 실행 중 발생한 예외 전달
        """
        from logging.logging_util import LoggingUtil
        log_util = LoggingUtil(__name__)
        try:
            # 동적 파라미터 설정: 인자가 없으면 ConfigManager에서 기본값 로드
            if dynamic_params is None:
                dynamic_params = self.config_manager.get_dynamic_params()
            else:
                dynamic_params = self.config_manager.validate_params(dynamic_params)
            try:
                # 수익률 및 변동성 계산 (종가의 변화율 및 이동 표준편차)
                self.df_long['returns'] = self.df_long['close'].pct_change().fillna(0)
                self.df_long['volatility'] = self.df_long['returns'].rolling(window=20).std().fillna(0)
            except Exception as e:
                self.logger.error("Error computing returns/volatility: " + str(e), exc_info=True)
                raise

            try:
                # 기술적 인디케이터 적용 (예: SMA, RSI 등)
                self.apply_indicators()
                log_util.log_event("Indicators applied", state_key="indicator_applied")
            except Exception as e:
                self.logger.error("Error during indicator application: " + str(e), exc_info=True)
                raise

            try:
                # HMM 업데이트 모듈 호출: 시장 상태 예측 수행
                from backtesting.steps.hmm_manager import update_hmm
                regime_series = update_hmm(self, dynamic_params)
                log_util.log_event("HMM updated", state_key="hmm_update")
            except Exception as e:
                self.logger.error("Error updating HMM: " + str(e), exc_info=True)
                regime_series = pd.Series(["sideways"] * len(self.df_long), index=self.df_long.index)

            try:
                # 짧은 타임프레임 데이터 업데이트: 인디케이터 및 시장 상태 적용
                self.update_short_dataframe(regime_series, dynamic_params)
                log_util.log_event("Data loaded successfully", state_key="data_load")
            except Exception as e:
                self.logger.error("Error updating short dataframe: " + str(e), exc_info=True)
                raise

            # Holdout 기간이 지정된 경우, 학습용 데이터와 holdout 데이터 분리
            if holdout_period:
                holdout_start, holdout_end = pd.to_datetime(holdout_period[0]), pd.to_datetime(holdout_period[1])
                df_train = self.df_short[self.df_short.index < holdout_start]
                df_holdout = self.df_short[(self.df_short.index >= holdout_start) & (self.df_short.index <= holdout_end)]
            else:
                df_train = self.df_short
                df_holdout = None

            # 워크포워드 기간이 지정된 경우, 초기 시간과 기간 설정
            if walk_forward_days is not None:
                self.window_start = df_train.index[0]
                self.walk_forward_td = pd.Timedelta(days=walk_forward_days)
                self.walk_forward_days = walk_forward_days
            else:
                self.window_start = None
                self.walk_forward_days = None

            # 신호 쿨다운 및 리밸런싱 주기 설정
            signal_cooldown = pd.Timedelta(minutes=dynamic_params.get("signal_cooldown_minutes", 5))
            rebalance_interval = pd.Timedelta(minutes=dynamic_params.get("rebalance_interval_minutes", 60))

            self.df_train = df_train
            try:
                # 주문 처리 관련 모듈 호출: 학습, 추가, holdout, 최종 주문 처리
                from backtesting.steps.order_manager import process_training_orders, process_extra_orders, process_holdout_orders, finalize_orders
                process_training_orders(self, dynamic_params, signal_cooldown, rebalance_interval)
                process_extra_orders(self, dynamic_params)
                process_holdout_orders(self, dynamic_params, df_holdout)
                finalize_orders(self)
            except Exception as e:
                self.logger.error("Error during order processing: " + str(e), exc_info=True)
                raise

            # 최종 성과 계산 (계좌 잔액, 총 수익률 등)
            available_balance = self.account.get_available_balance()
            total_pnl = sum(trade.get("pnl", 0) if not isinstance(trade.get("pnl", 0), list) 
                            else sum(trade.get("pnl", 0)) for trade in self.trades)
            roi = total_pnl / self.account.initial_balance * 100
            log_util.log_event("Backtest complete", state_key="final_performance")
            return self.trades, self.trade_logs

        except Exception as e:
            self.logger.error("Fatal error in run_backtest: " + str(e), exc_info=True)
            raise

    def run_backtest_pipeline(self, dynamic_params=None, walk_forward_days: int = None, holdout_period: tuple = None):
        """
        백테스트 파이프라인 실행 함수
        -----------------------------
        백테스트를 실행한 후, 최종 계좌 잔액 및 포지션 청산 여부를 로깅하고 결과를 반환합니다.
        
        Parameters:
          dynamic_params (dict, optional): 동적 파라미터
          walk_forward_days (int, optional): 워크포워드 기간 (일 단위)
          holdout_period (tuple, optional): holdout 기간 (시작, 종료)
        
        Returns:
          tuple: (trades, trade_logs) - 전체 거래 내역 및 상세 로그 리스트
        """
        trades, trade_logs = self.run_backtest(dynamic_params, walk_forward_days, holdout_period)
        available_balance = self.account.get_available_balance()
        self.logger.debug(f"최종 계좌 잔액: {available_balance:.2f}")
        if self.positions:
            self.logger.error("백테스트 종료 후에도 미체결 포지션이 남아있습니다.", exc_info=True)
        else:
            self.logger.debug("모든 포지션이 정상적으로 종료되었습니다.")
        return trades, trade_logs

# 모듈별 로깅 설정 및 데이터 관련 모듈 임포트
from logging.logger_config import setup_logger                   # 로깅 설정 함수
from data.db.db_manager import fetch_ohlcv_records              # OHLCV 데이터베이스 조회 함수
from data.ohlcv.ohlcv_aggregator import aggregate_to_weekly       # 주간 데이터 집계 함수
from signal_calculation.indicators import compute_bollinger_bands          # 볼린저 밴드 계산 함수
import threading                                                # 멀티스레드 동기화를 위한 모듈
import pandas as pd                                             # 데이터 프레임 처리를 위한 pandas
from logging.logging_util import LoggingUtil                       # 추가 로깅 유틸리티

# --- 전역 변수 및 객체 정의 ---
# 모듈 단위 로깅 인스턴스 설정: 로그를 남길 때 모듈명(__name__)을 이용
logger = setup_logger(__name__)
log_util = LoggingUtil(__name__)

# 멀티스레드 환경에서의 데이터 캐싱을 위한 전역 변수
_cache_lock = threading.Lock()    # 캐시 접근시 동기화를 위한 Lock 객체
_data_cache = {}                  # OHLCV 데이터 프레임을 메모리에 캐싱하기 위한 딕셔너리

# --- 내부 캐시 함수 정의 ---
def _get_cached_ohlcv(table_name, start_date, end_date):
    """
    캐시에서 특정 테이블과 날짜 범위에 해당하는 OHLCV 데이터를 조회합니다.
    
    Parameters:
        table_name (str): OHLCV 데이터가 저장된 테이블의 이름.
        start_date (str 또는 datetime): 데이터 조회의 시작 날짜.
        end_date (str 또는 datetime): 데이터 조회의 종료 날짜.
    
    Returns:
        pandas.DataFrame 또는 None: 캐시에 존재하는 경우 해당 DataFrame, 없으면 None.
    """
    # 캐시 키는 테이블 이름과 날짜 범위를 튜플로 결합하여 생성합니다.
    key = (table_name, start_date, end_date)
    # 멀티스레드 환경에서 동시 접근을 방지하기 위해 락을 사용합니다.
    with _cache_lock:
        return _data_cache.get(key)

def _set_cached_ohlcv(table_name, start_date, end_date, df):
    """
    주어진 OHLCV 데이터 프레임을 캐시에 저장합니다.
    
    Parameters:
        table_name (str): 데이터가 속한 테이블 이름.
        start_date (str 또는 datetime): 데이터 조회의 시작 날짜.
        end_date (str 또는 datetime): 데이터 조회의 종료 날짜.
        df (pandas.DataFrame): 저장할 OHLCV 데이터 프레임.
    
    Returns:
        None
    """
    # 캐시 키 생성
    key = (table_name, start_date, end_date)
    # 동기화를 위해 락 사용 후 캐시에 저장
    with _cache_lock:
        _data_cache[key] = df

def _validate_and_prepare_df(df, table_name):
    """
    불러온 OHLCV 데이터 프레임의 유효성을 검사하고, 필요한 전처리(시간 인덱스 변환, 정렬, 중복 제거 등)를 수행합니다.
    
    Parameters:
        df (pandas.DataFrame): 검증 및 전처리할 데이터 프레임.
        table_name (str): 데이터 프레임이 속한 테이블 이름(로그 메시지 용도).
    
    Returns:
        pandas.DataFrame: 전처리가 완료된 데이터 프레임.
    """
    # 데이터 프레임이 비어있는지 확인 후 에러 로그 출력
    if df.empty:
        logger.error(f"DataFrame for {table_name} is empty.", exc_info=True)
        return df

    # 인덱스가 datetime 형식인지 확인하고, 아니라면 변환 시도
    if not pd.api.types.is_datetime64_any_dtype(df.index):
        try:
            df.index = pd.to_datetime(df.index, errors='coerce')
            # 변환 후 NaT (Not a Time)가 포함된 경우 해당 행 제거
            if df.index.isnull().any():
                logger.warning(f"Some index values in {table_name} could not be converted to datetime and will be dropped.")
                df = df[~df.index.isnull()]
        except Exception as e:
            logger.error(f"Error converting index to datetime for {table_name}: {e}", exc_info=True)
            raise

    # 인덱스를 오름차순으로 정렬 (시간 순 정렬)
    df.sort_index(inplace=True)

    # 중복된 인덱스가 존재하면 경고 로그 출력 후 중복 제거
    if df.index.duplicated().any():
        logger.warning(f"Duplicate datetime indices found in {table_name}; removing duplicates.")
        df = df[~df.index.duplicated(keep='first')]

    # 데이터 열이 존재할 경우, 고가(high), 저가(low), 종가(close)를 활용하여 평균 변동폭 계산
    if 'high' in df.columns and 'low' in df.columns and 'close' in df.columns:
        avg_range = (df['high'] - df['low']).mean()
        avg_close = df['close'].mean()
        # 변동성이 비정상적으로 낮은 경우 경고 로그 출력 (정상 데이터 여부 점검)
        if avg_range < avg_close * 0.001:
            logger.warning(f"Data for {table_name} shows low volatility: avg_range={avg_range:.6f}, avg_close={avg_close:.6f}.")
    return df

def load_data(backtester, short_table_format, long_table_format, short_tf, long_tf, 
              start_date=None, end_date=None, extra_tf=None, use_weekly=False):
    """
    백테스터(backtester) 객체에 필요한 OHLCV 데이터와 인디케이터 데이터를 로드 및 전처리합니다.
    
    주요 기능:
      - 단기(short) 및 장기(long) 데이터 테이블 이름 생성 후 캐시에서 검색
      - 캐시에 없으면 데이터베이스에서 조회하고 캐시에 저장
      - 데이터 프레임의 유효성을 검사하고 전처리 수행
      - 추가 시간 프레임(extra_tf)이 제공되면 볼린저 밴드를 계산하여 추가 데이터 구성
      - use_weekly가 True면 단기 데이터를 주간 데이터로 집계하여 저장
    
    Parameters:
        backtester (object): 백테스트 실행 객체로, 로드된 데이터를 저장할 속성을 포함.
        short_table_format (str): 단기 데이터 테이블 이름 형식 (문자열 포맷).
        long_table_format (str): 장기 데이터 테이블 이름 형식 (문자열 포맷).
        short_tf (str): 단기 데이터의 시간 프레임 (예: '1m', '5m').
        long_tf (str): 장기 데이터의 시간 프레임 (예: '1h', '1d').
        start_date (str 또는 datetime, optional): 데이터 조회 시작 날짜.
        end_date (str 또는 datetime, optional): 데이터 조회 종료 날짜.
        extra_tf (str, optional): 추가 데이터 시간 프레임 (예: '15m'); 기본값은 None.
        use_weekly (bool, optional): 주간 데이터 집계를 사용할지 여부.
    
    Returns:
        None
    """
    try:
        # 심볼(symbol)을 포맷에 맞게 소문자 및 '/' 제거 처리
        symbol_for_table = backtester.symbol.replace('/', '').lower()
        # 단기 및 장기 테이블 이름 생성 (문자열 포맷 사용)
        short_table = short_table_format.format(symbol=symbol_for_table, timeframe=short_tf)
        long_table = long_table_format.format(symbol=symbol_for_table, timeframe=long_tf)
        
        # 단기 데이터 로드: 캐시에서 검색 후 없으면 DB에서 조회
        df_short = _get_cached_ohlcv(short_table, start_date, end_date)
        if df_short is None:
            df_short = fetch_ohlcv_records(short_table, start_date, end_date)
            _set_cached_ohlcv(short_table, start_date, end_date, df_short)
        # 데이터 프레임 유효성 검사 및 전처리 수행
        df_short = _validate_and_prepare_df(df_short, short_table)
        
        # 장기 데이터 로드: 캐시 검색 후 없으면 DB에서 조회
        df_long = _get_cached_ohlcv(long_table, start_date, end_date)
        if df_long is None:
            df_long = fetch_ohlcv_records(long_table, start_date, end_date)
            _set_cached_ohlcv(long_table, start_date, end_date, df_long)
        df_long = _validate_and_prepare_df(df_long, long_table)
        
        # 백테스터 객체에 로드된 데이터를 할당 (후속 전략 로직에서 사용)
        backtester.df_short = df_short
        backtester.df_long = df_long
        
        # 단기 또는 장기 데이터가 비어있으면 에러 로그 출력 후 예외 발생
        if backtester.df_short.empty or backtester.df_long.empty:
            logger.error("데이터 로드 실패: short 또는 long 데이터가 비어있습니다.", exc_info=True)
            raise ValueError("No data loaded")
        
        # 데이터 로드 성공 이벤트 로깅
        log_util.log_event("Data loaded successfully", state_key="data_load")
    except Exception as e:
        logger.error(f"데이터 로드 중 에러 발생: {e}", exc_info=True)
        raise

    # 추가 시간 프레임(extra_tf)이 지정된 경우 추가 데이터 로드 및 볼린저 밴드 계산 수행
    if extra_tf:
        try:
            extra_table = short_table_format.format(symbol=symbol_for_table, timeframe=extra_tf)
            df_extra = _get_cached_ohlcv(extra_table, start_date, end_date)
            if df_extra is None:
                df_extra = fetch_ohlcv_records(extra_table, start_date, end_date)
                _set_cached_ohlcv(extra_table, start_date, end_date, df_extra)
            df_extra = _validate_and_prepare_df(df_extra, extra_table)
            backtester.df_extra = df_extra
            if not backtester.df_extra.empty:
                # 볼린저 밴드를 계산하여 보조 지표 추가 (가격 열은 'close')
                backtester.df_extra = compute_bollinger_bands(
                    backtester.df_extra,
                    price_column='close',
                    period=20,
                    std_multiplier=2.0,
                    fillna=True
                )
                log_util.log_event("Extra data loaded", state_key="extra_load")
        except Exception as e:
            logger.error(f"Extra 데이터 로드 에러: {e}", exc_info=True)
    # 주간 데이터 집계 옵션이 True인 경우, 단기 데이터를 주간 단위로 집계하여 백테스터에 추가
    if use_weekly:
        try:
            backtester.df_weekly = aggregate_to_weekly(backtester.df_short, compute_indicators=True)
            if backtester.df_weekly.empty:
                logger.warning("주간 데이터 집계 결과가 비어있습니다.")
            else:
                log_util.log_event("Weekly data aggregated", state_key="weekly_load")
        except Exception as e:
            logger.error(f"주간 데이터 집계 에러: {e}", exc_info=True)

from logging.logger_config import setup_logger

# 모듈 로깅 인스턴스 설정
logger = setup_logger(__name__)

def update_hmm(backtester, dynamic_params):
    """
    백테스터 객체의 HMM(은닉 마르코프 모델) 상태를 업데이트하고, 업데이트된 regime(시장 체제)의 분포를 로그로 출력합니다.
    
    Parameters:
        backtester (object): HMM 업데이트 메서드를 가진 백테스터 객체.
        dynamic_params (dict): 동적 파라미터(예: 시장 환경, 유동성 정보 등)를 포함하는 딕셔너리.
    
    Returns:
        pandas.Series: 업데이트된 HMM regime 시리즈.
    """
    # 백테스터 내부의 HMM 업데이트 함수 호출 (예: 시장 체제 분류 업데이트)
    regime_series = backtester.update_hmm_regime(dynamic_params)
    try:
        # 각 regime 값의 빈도수를 계산하여 딕셔너리 형태로 변환 후 디버그 로그 출력
        counts = regime_series.value_counts().to_dict()
        logger.debug(f"HMM 업데이트 완료: 총 {len(regime_series)} 샘플, regime 분포: {counts}")
    except Exception:
        logger.error("HMM 업데이트 완료: regime 분포 정보 산출 실패")
    return regime_series

from logging.logger_config import setup_logger
from signal_calculation.indicators import compute_sma, compute_rsi, compute_macd

# 모듈 로깅 인스턴스 설정
logger = setup_logger(__name__)

def apply_indicators(backtester):
    """
    백테스터 객체의 장기 데이터(df_long)에 SMA, RSI, MACD 등 다양한 트레이딩 인디케이터를 적용합니다.
    
    주요 동작:
      - 단순 이동평균(SMA) 계산 후 'sma' 열에 저장
      - 상대 강도 지수(RSI) 계산 후 'rsi' 열에 저장
      - MACD 및 시그널, 차이값 계산 후 'macd_' 접두사로 열 추가
      - 적용된 인디케이터 값들의 최소/최대 범위를 로그에 출력
    
    Parameters:
        backtester (object): 인디케이터를 적용할 데이터 프레임(df_long)을 포함하는 백테스터 객체.
    
    Returns:
        None
    """
    # SMA 계산: 종가('close') 기준, 200 기간, 결측값 채움 옵션 활성화, 결과는 'sma' 열에 저장
    backtester.df_long = compute_sma(backtester.df_long, price_column='close', period=200, fillna=True, output_col='sma')
    # RSI 계산: 종가('close') 기준, 14 기간, 결측값 채움, 결과는 'rsi' 열에 저장
    backtester.df_long = compute_rsi(backtester.df_long, price_column='close', period=14, fillna=True, output_col='rsi')
    # MACD 계산: 종가('close') 기준, 느린 기간=26, 빠른 기간=12, 시그널 기간=9, 결측값 채움, 결과 열은 'macd_' 접두사를 사용
    backtester.df_long = compute_macd(backtester.df_long, price_column='close', slow_period=26, fast_period=12, signal_period=9, fillna=True, prefix='macd_')
    
    # 인디케이터가 적용된 데이터의 값 범위를 계산하여 로그에 출력 (모든 값의 최소 및 최대값)
    sma_min = backtester.df_long['sma'].min()
    sma_max = backtester.df_long['sma'].max()
    rsi_min = backtester.df_long['rsi'].min()
    rsi_max = backtester.df_long['rsi'].max()
    macd_diff_min = backtester.df_long['macd_diff'].min()
    macd_diff_max = backtester.df_long['macd_diff'].max()
    
    logger.debug(
        f"인디케이터 적용 완료: SMA 범위=({sma_min:.2f}, {sma_max:.2f}), "
        f"RSI 범위=({rsi_min:.2f}, {rsi_max:.2f}), MACD diff 범위=({macd_diff_min:.2f}, {macd_diff_max:.2f})"
    )

from logging.logger_config import setup_logger
from logging.logging_util import LoggingUtil  # 동적 상태 변화 로깅 유틸리티

# 모듈 로깅 인스턴스 및 추가 로깅 유틸리티 설정
logger = setup_logger(__name__)
log_util = LoggingUtil(__name__)

def get_signal_with_weekly_override(backtester, row, current_time, dynamic_params):
    """
    주간 데이터(weekly data)가 존재할 경우, 주간 저점/고점 근접 여부에 따라 주문 신호(enter_long 또는 exit_all)를 우선 적용합니다.
    만약 주간 데이터 조건이 충족되지 않으면, ensemble_manager를 이용해 최종 신호를 반환합니다.
    
    Parameters:
        backtester (object): 주문 신호 생성을 위한 백테스터 객체.
        row (pandas.Series): 현재 시점의 데이터 행 (OHLCV 및 기타 지표 포함).
        current_time (datetime): 현재 시점의 시간.
        dynamic_params (dict): 동적 파라미터 (예: 유동성 정보 등).
    
    Returns:
        str: 주문 신호 (예: "enter_long", "exit_all", 또는 ensemble_manager의 반환 값).
    """
    try:
        # 주간 데이터가 존재하며, 비어있지 않은 경우
        if hasattr(backtester, 'df_weekly') and backtester.df_weekly is not None and not backtester.df_weekly.empty:
            # 현재 시간보다 작거나 같은 주간 데이터 중 가장 최근 데이터(주간 바)를 선택
            weekly_bar = backtester.df_weekly.loc[backtester.df_weekly.index <= current_time].iloc[-1]
            # 주간 데이터에 'weekly_low' 및 'weekly_high' 값이 존재하는지 확인
            if "weekly_low" in weekly_bar and "weekly_high" in weekly_bar:
                tolerance = 0.002  # 주간 저점/고점에 대한 허용 오차 비율
                # 현재 종가가 주간 저점에 근접하면 'enter_long' 신호 반환
                if abs(row["close"] - weekly_bar["weekly_low"]) / weekly_bar["weekly_low"] <= tolerance:
                    log_util.log_event("Weekly override: enter_long", state_key="order_signal")
                    return "enter_long"
                # 현재 종가가 주간 고점에 근접하면 'exit_all' 신호 반환
                elif abs(row["close"] - weekly_bar["weekly_high"]) / weekly_bar["weekly_high"] <= tolerance:
                    log_util.log_event("Weekly override: exit_all", state_key="order_signal")
                    return "exit_all"
            else:
                # 주간 데이터에 필요한 키가 없으면 경고 로그 출력
                backtester.logger.warning("Weekly override skipped: weekly_bar missing 'weekly_low' or 'weekly_high' keys.")
        # 주간 override 조건이 충족되지 않으면 ensemble_manager를 통해 최종 신호 계산
        return backtester.ensemble_manager.get_final_signal(
            row.get('market_regime', 'unknown'),
            dynamic_params.get('liquidity_info', 'high'),
            backtester.df_short,
            current_time,
            data_weekly=getattr(backtester, 'df_weekly', None)
        )
    except Exception as e:
        # 오류 발생 시 에러 로그 기록 후 ensemble_manager의 최종 신호 반환
        backtester.logger.error(f"Error in weekly override signal generation: {e}", exc_info=True)
        return backtester.ensemble_manager.get_final_signal(
            row.get('market_regime', 'unknown'),
            dynamic_params.get('liquidity_info', 'high'),
            backtester.df_short,
            current_time,
            data_weekly=getattr(backtester, 'df_weekly', None)
        )

def process_training_orders(backtester, dynamic_params, signal_cooldown, rebalance_interval):
    """
    학습 데이터(df_train)를 순회하며 각 시점에 대해 주문 신호를 생성하고 주문을 실행합니다.
    또한, 주간 종료, walk-forward window, 포지션 업데이트 및 자산 리밸런싱 등을 처리합니다.
    
    Parameters:
        backtester (object): 주문 처리 로직을 포함하는 백테스터 객체.
        dynamic_params (dict): 주문 실행 시 필요한 동적 파라미터들.
        signal_cooldown (timedelta): 신호 간 최소 시간 간격.
        rebalance_interval (timedelta): 리밸런싱 간 최소 시간 간격.
    
    Returns:
        None
    """
    # 학습 데이터의 각 시간별 행을 순회하며 주문 처리 수행
    for current_time, row in backtester.df_train.iterrows():
        try:
            # 주간 종료 처리: 매주 금요일(weekday()==4)이며, 이전에 처리되지 않은 날짜이면 주간 종료 처리 실행
            try:
                if current_time.weekday() == 4 and (
                    backtester.last_weekly_close_date is None or 
                    backtester.last_weekly_close_date != current_time.date()
                ):
                    try:
                        backtester.handle_weekly_end(current_time, row)
                    except Exception as e:
                        logger.error(f"Weekly end handling error {e}", exc_info=True)
                    backtester.last_weekly_close_date = current_time.date()
                    continue  # 주간 종료 후 나머지 주문 로직 생략
            except Exception as e:
                logger.error(f"Error during weekly end check {e}", exc_info=True)
            
            # walk-forward window 처리: 정해진 기간이 경과하면 walk-forward 처리를 실행
            try:
                if backtester.walk_forward_days is not None and (current_time - backtester.window_start) >= backtester.walk_forward_td:
                    try:
                        backtester.handle_walk_forward_window(current_time, row)
                    except Exception as e:
                        logger.error(f"Walk-forward window handling error {e}", exc_info=True)
                    backtester.window_start = current_time
            except Exception as e:
                logger.error(f"Error during walk-forward window check {e}", exc_info=True)
            
            # 신호 쿨다운을 고려하여 일정 시간 간격 이후에만 신호 생성 (즉, 너무 짧은 간격은 무시)
            if backtester.last_signal_time is None or (current_time - backtester.last_signal_time) >= signal_cooldown:
                action = get_signal_with_weekly_override(backtester, row, current_time, dynamic_params)
            else:
                action = "hold"
                
            # 기본 위험 파라미터 설정 (거래당 위험, ATR 곱수, 수익 비율, 현재 변동성)
            base_risk_params = {
                "risk_per_trade": dynamic_params.get("risk_per_trade", 0.01),
                "atr_multiplier": dynamic_params.get("atr_multiplier", 2.0),
                "profit_ratio": dynamic_params.get("profit_ratio", 0.05),
                "current_volatility": row.get("volatility", 0)
            }
            risk_params = base_risk_params
            try:
                # 시장 체제 및 유동성 정보에 따른 위험 파라미터 보정
                risk_params = backtester.risk_manager.compute_risk_parameters_by_regime(
                    base_risk_params,
                    row.get('market_regime', 'unknown'),
                    dynamic_params.get('liquidity_info', 'high')
                )
            except Exception as e:
                logger.error(f"Risk parameter computation error {e}", exc_info=True)
                risk_params = base_risk_params
            try:
                # 주문 실행: 신호(action)에 따라 bullish entry, bearish exit 또는 sideways trade 처리
                if action == "enter_long":
                    backtester.process_bullish_entry(current_time, row, risk_params, dynamic_params)
                    log_util.log_event("Order executed: enter_long", state_key="order_execution")
                elif action == "exit_all":
                    backtester.process_bearish_exit(current_time, row)
                    log_util.log_event("Order executed: exit_all", state_key="order_execution")
                elif row.get('market_regime', 'unknown') == "sideways":
                    backtester.process_sideways_trade(current_time, row, risk_params, dynamic_params)
                    log_util.log_event("Order executed: sideways", state_key="order_execution")
            except Exception as e:
                logger.error(f"Error processing order with action '{action}': {e}", exc_info=True)
            # 마지막 신호 발생 시각 갱신
            backtester.last_signal_time = current_time

            # 포지션 업데이트: 각 시점에서 보유 포지션의 상태 갱신
            try:
                backtester.update_positions(current_time, row)
            except Exception as e:
                logger.error(f"Error updating positions {e}", exc_info=True)

            # 리밸런싱 처리: 정해진 간격이 경과하면 자산 리밸런싱 실행
            try:
                if backtester.last_rebalance_time is None or (current_time - backtester.last_rebalance_time) >= rebalance_interval:
                    try:
                        backtester.asset_manager.rebalance(row.get('market_regime', 'unknown'))
                    except Exception as e:
                        logger.error(f"Error during rebalance {e}", exc_info=True)
                    backtester.last_rebalance_time = current_time
                log_util.log_event("Rebalance executed", state_key="rebalance")
            except Exception as e:
                logger.error(f"Error in rebalance check {e}", exc_info=True)

        except Exception as e:
            logger.error(f"Unexpected error during processing training orders {e}", exc_info=True)
            continue

def process_extra_orders(backtester, dynamic_params):
    """
    추가 데이터(df_extra)가 있을 경우, 각 시점에 대해 주문 신호를 생성하고 주문을 실행합니다.
    단, 시장 체제(realm)를 재조회하여 위험 파라미터를 재계산하고, 주문 모니터링도 수행합니다.
    
    Parameters:
        backtester (object): 주문 처리 로직을 포함하는 백테스터 객체.
        dynamic_params (dict): 주문 실행 시 필요한 동적 파라미터들.
    
    Returns:
        None
    """
    if backtester.df_extra is not None and not backtester.df_extra.empty:
        for current_time, row in backtester.df_extra.iterrows():
            try:
                # 주간 override 신호를 포함한 주문 신호 생성
                hf_signal = get_signal_with_weekly_override(backtester, row, current_time, dynamic_params)
                # 현재 시장 체제 정보를 가져오기 위해 장기 데이터(df_long)에서 최신 값을 조회
                regime = "sideways"
                try:
                    regime = backtester.df_long.loc[backtester.df_long.index <= current_time].iloc[-1].get('market_regime', 'sideways')
                except Exception as e:
                    logger.error(f"Retrieving regime failed {e}", exc_info=True)
                    regime = "sideways"
                # 기본 위험 파라미터 설정
                base_risk_params = {
                    "risk_per_trade": dynamic_params.get("risk_per_trade", 0.01),
                    "atr_multiplier": dynamic_params.get("atr_multiplier", 2.0),
                    "profit_ratio": dynamic_params.get("profit_ratio", 0.05),
                    "current_volatility": row.get("volatility", 0)
                }
                risk_params = base_risk_params
                try:
                    # 위험 파라미터를 시장 체제와 유동성 정보에 따라 조정
                    risk_params = backtester.risk_manager.compute_risk_parameters_by_regime(
                        base_risk_params,
                        regime,
                        dynamic_params.get('liquidity_info', 'high')
                    )
                except Exception as e:
                    logger.error(f"Risk params error (extra data) {e}", exc_info=True)
                    risk_params = base_risk_params
                try:
                    # 주문 실행: 신호에 따라 bullish entry 또는 bearish exit 처리
                    if hf_signal == "enter_long":
                        backtester.process_bullish_entry(current_time, row, risk_params, dynamic_params)
                        log_util.log_event("Extra: Order executed: enter_long", state_key="order_execution")
                    elif hf_signal == "exit_all":
                        backtester.process_bearish_exit(current_time, row)
                        log_util.log_event("Extra: Order executed: exit_all", state_key="order_execution")
                except Exception as e:
                    logger.error(f"Error processing extra order with hf_signal '{hf_signal}': {e}", exc_info=True)
                # 주문 모니터링: 주문 상태 및 포지션 관리
                try:
                    backtester.monitor_orders(current_time, row)
                except Exception as e:
                    logger.error(f"Error monitoring orders {e}", exc_info=True)
            except Exception as e:
                logger.error(f"Unexpected error in process_extra_orders {e}", exc_info=True)
                continue

def process_holdout_orders(backtester, dynamic_params, df_holdout):
    """
    보류(holdout) 데이터(df_holdout)에 대해 각 시점마다 주문 신호를 생성하고 주문을 실행합니다.
    위험 파라미터 재계산, 포지션 업데이트 등 일반 주문 처리 로직과 유사하게 진행합니다.
    
    Parameters:
        backtester (object): 주문 처리 로직을 포함하는 백테스터 객체.
        dynamic_params (dict): 주문 실행 시 필요한 동적 파라미터들.
        df_holdout (pandas.DataFrame): 보류 데이터 (테스트 또는 검증용 데이터).
    
    Returns:
        None
    """
    if df_holdout is not None:
        for current_time, row in df_holdout.iterrows():
            try:
                # 주간 override를 고려한 주문 신호 생성
                action = get_signal_with_weekly_override(backtester, row, current_time, dynamic_params)
                # 기본 위험 파라미터 설정
                base_risk_params = {
                    "risk_per_trade": dynamic_params.get("risk_per_trade", 0.01),
                    "atr_multiplier": dynamic_params.get("atr_multiplier", 2.0),
                    "profit_ratio": dynamic_params.get("profit_ratio", 0.05),
                    "current_volatility": row.get("volatility", 0)
                }
                risk_params = base_risk_params
                try:
                    # 위험 파라미터 보정: 시장 체제 및 유동성 정보에 기반
                    risk_params = backtester.risk_manager.compute_risk_parameters_by_regime(
                        base_risk_params,
                        row.get('market_regime', 'unknown'),
                        dynamic_params.get('liquidity_info', 'high')
                    )
                except Exception as e:
                    logger.error(f"Risk params error (holdout) {e}", exc_info=True)
                    risk_params = base_risk_params
                try:
                    # 주문 실행: 신호에 따라 bullish entry, bearish exit, 또는 sideways trade 처리
                    if action == "enter_long":
                        backtester.process_bullish_entry(current_time, row, risk_params, dynamic_params)
                        log_util.log_event("Holdout: Order executed: enter_long", state_key="order_execution")
                    elif action == "exit_all":
                        backtester.process_bearish_exit(current_time, row)
                        log_util.log_event("Holdout: Order executed: exit_all", state_key="order_execution")
                    elif row.get('market_regime', 'unknown') == "sideways":
                        backtester.process_sideways_trade(current_time, row, risk_params, dynamic_params)
                        log_util.log_event("Holdout: Order executed: sideways", state_key="order_execution")
                except Exception as e:
                    logger.error(f"Error processing holdout order with action '{action}': {e}", exc_info=True)
                try:
                    # 보류 데이터에 대해 포지션 상태 업데이트 실행
                    backtester.update_positions(current_time, row)
                except Exception as e:
                    logger.error(f"Error updating positions in holdout {e}", exc_info=True)
            except Exception as e:
                logger.error(f"Unexpected error in process_holdout_orders {e}", exc_info=True)
                continue

def finalize_orders(backtester):
    """
    백테스터 객체 내에서 모든 포지션을 마감(finalize) 처리합니다.
    
    Parameters:
        backtester (object): 최종 포지션 마감을 실행할 백테스터 객체.
    
    Returns:
        None
    """
    try:
        backtester.finalize_all_positions()
    except Exception as e:
        logger.error(f"Error finalizing orders: {e}", exc_info=True)
        raise

---

# trading/position_management.py

# 로그 설정 함수 임포트: 로그 설정을 위한 모듈에서 setup_logger 함수를 가져옴
from logging.logger_config import setup_logger

# 모듈 이름(__name__)을 사용하여 현재 파일에 대한 로거 인스턴스 생성
logger = setup_logger(__name__)  # 전역 로거: 계좌 관련 이벤트 로깅에 사용됨


class Account:
    """
    Account 클래스는 트레이딩 계좌의 잔고 및 포지션을 관리하는 역할을 합니다.
    
    Attributes:
        initial_balance (float): 계좌 초기 잔고.
        spot_balance (float): 현재 사용 가능한 현물(Spot) 잔고.
        stablecoin_balance (float): 스테이블 코인으로 변환된 잔고.
        fee_rate (float): 거래 수수료율 (기본값 0.001, 즉 0.1%).
        positions (list): 계좌에 등록된 거래 포지션 목록.
    """
    
    def __init__(self, initial_balance: float, fee_rate: float = 0.001) -> None:
        """
        계좌를 초기화합니다.
        
        Parameters:
            initial_balance (float): 계좌 시작 금액 (음수가 아니어야 함).
            fee_rate (float): 거래 시 적용할 수수료율 (기본값 0.1%).
            
        Raises:
            ValueError: 초기 잔고가 음수일 경우.
        """
        if initial_balance < 0:
            raise ValueError("Initial balance must be non-negative.")
        # 초기 잔고와 수수료율을 객체 속성으로 설정
        self.initial_balance: float = initial_balance  # 계좌 생성 시 초기 잔고 기록
        self.spot_balance: float = initial_balance  # 현물 잔고: 거래에 즉시 사용 가능한 자금
        self.stablecoin_balance: float = 0.0  # 스테이블 코인 잔고 (초기에는 0)
        self.fee_rate: float = fee_rate  # 거래 시 적용되는 수수료율
        self.positions: list = []  # 현재 열려있는 포지션들을 저장하는 리스트
        logger.debug(f"Account initialized with balance: {initial_balance:.2f}")

    def add_position(self, position) -> None:
        """
        새로운 거래 포지션을 계좌에 추가합니다.
        
        Parameters:
            position: 포지션 객체 (반드시 position_id 속성이 있어야 함).
            
        Returns:
            None
        """
        self.positions.append(position)
        logger.debug(f"Position added: ID={position.position_id}")

    def remove_position(self, position) -> None:
        """
        계좌에서 특정 거래 포지션을 제거합니다.
        
        Parameters:
            position: 제거할 포지션 객체.
            
        Returns:
            None
        """
        if position in self.positions:
            self.positions.remove(position)
            logger.debug(f"Position removed: ID={position.position_id}")
        else:
            logger.warning(f"Failed to remove position: ID={position.position_id}")

    def get_used_balance(self) -> float:
        """
        사용 중인(잠긴) 잔고를 계산합니다.
        
        각 포지션의 미체결(미종료) 거래 기록을 순회하며, 
        '진입 가격 × 거래 수량 × (1 + fee_rate)' 값을 합산하여 사용된 자금을 산출합니다.
        
        Returns:
            float: 사용된 총 잔고.
        """
        used: float = 0.0
        # 각 포지션에 대해 열려있는(execution이 닫히지 않은) 거래의 자금을 계산
        for pos in self.positions:
            for record in pos.executions:
                if not record.get("closed", False):
                    used += record["entry_price"] * record["size"] * (1 + self.fee_rate)
        return used

    def get_available_balance(self) -> float:
        """
        새 거래를 위한 사용 가능한 잔고(실제 잔고에서 사용 중인 금액을 제외한 금액)를 계산합니다.
        
        Returns:
            float: 사용 가능한 잔고 (음수가 되지 않도록 0.0 이상).
        """
        available = self.spot_balance - self.get_used_balance()
        return available if available >= 0 else 0.0

    def update_after_trade(self, trade: dict) -> None:
        """
        거래 체결 후 계좌의 잔고를 업데이트합니다.
        
        Parameters:
            trade (dict): 거래 세부 정보를 담은 딕셔너리. 'pnl' (손익) 항목을 포함해야 함.
            
        Returns:
            None
        """
        pnl = trade.get("pnl", 0.0)
        # 거래 손익(PnL)에 따라 현물 잔고를 증가 또는 감소시킴
        self.spot_balance += pnl
        logger.debug(f"Trade executed: PnL={pnl:.2f}, Updated spot balance={self.spot_balance:.2f}")

    def convert_to_stablecoin(self, amount: float, conversion_fee: float = 0.001) -> float:
        """
        현물 잔고의 일부를 스테이블 코인으로 변환합니다.
        
        변환 시 수수료를 차감하며, 변환 요청 금액이 사용 가능한 잔고를 초과하면 사용 가능한 최대 금액으로 변환합니다.
        
        Parameters:
            amount (float): 변환할 금액.
            conversion_fee (float): 변환에 적용되는 수수료율 (기본값 0.1%).
            
        Returns:
            float: 수수료 차감 후 스테이블 코인으로 변환된 순 금액.
        """
        if amount <= 0:
            logger.error("Conversion amount must be positive.", exc_info=True)
            return 0.0
        available = self.get_available_balance()
        # 요청 금액이 사용 가능한 잔고보다 크면, 사용 가능한 최대 금액으로 대체
        if amount > available:
            amount = available
        fee = amount * conversion_fee  # 변환 수수료 계산
        net_amount = amount - fee  # 수수료 차감 후 순 금액
        # 잔고 업데이트: 현물 잔고에서 차감하고 스테이블 코인 잔고에 추가
        self.spot_balance -= amount
        self.stablecoin_balance += net_amount
        logger.debug(f"Converted {amount:.2f} from spot to stablecoin (fee {fee:.2f}, net {net_amount:.2f}).")
        return net_amount

    def convert_to_spot(self, amount: float, conversion_fee: float = 0.001) -> float:
        """
        스테이블 코인 잔고의 일부를 다시 현물 잔고로 변환합니다.
        
        변환 시 수수료를 차감하며, 요청 금액이 스테이블 코인 잔고를 초과할 경우 잔고 전체를 변환합니다.
        
        Parameters:
            amount (float): 변환할 금액.
            conversion_fee (float): 변환에 적용되는 수수료율 (기본값 0.1%).
            
        Returns:
            float: 수수료 차감 후 현물 잔고로 변환된 순 금액.
        """
        if amount <= 0:
            logger.error("Conversion amount must be positive.", exc_info=True)
            return 0.0
        # 요청 금액이 스테이블 코인 잔고보다 클 경우 잔고 전체로 조정
        if amount > self.stablecoin_balance:
            amount = self.stablecoin_balance
        fee = amount * conversion_fee  # 변환 수수료 계산
        net_amount = amount - fee  # 수수료 차감 후 순 금액
        # 잔고 업데이트: 스테이블 코인 잔고에서 차감하고 현물 잔고에 추가
        self.stablecoin_balance -= amount
        self.spot_balance += net_amount
        logger.debug(f"Converted {amount:.2f} from stablecoin to spot (fee {fee:.2f}, net {net_amount:.2f}).")
        return net_amount

    def __str__(self) -> str:
        """
        계좌 상태를 문자열로 표현합니다.
        
        Returns:
            str: 현물 잔고, 스테이블 코인 잔고, 사용 가능한 잔고 정보를 포함한 포맷 문자열.
        """
        return (
            f"Account(spot_balance={self.spot_balance:.2f}, "
            f"stablecoin_balance={self.stablecoin_balance:.2f}, "
            f"available_balance={self.get_available_balance():.2f})"
        )

# 모듈 및 라이브러리 임포트:
# - setup_logger: 로깅 설정을 위한 함수
# - timedelta: 시간 간격 계산을 위한 datetime 모듈의 클래스
# - pandas: 데이터 처리 및 시간 관련 기능 제공
# - LoggingUtil: 추가 로깅 유틸리티
from logging.logger_config import setup_logger
from datetime import timedelta
import pandas as pd
from logging.logging_util import LoggingUtil

# AssetManager 클래스는 계좌의 자산 배분(스팟 vs. 스테이블코인)을 재조정(리밸런싱)하는 역할을 합니다.
class AssetManager:
    # _instances: 특정 파라미터 조합에 대해 단일 인스턴스를 유지하기 위한 클래스 변수 (싱글톤 패턴)
    _instances = {}

    def __new__(cls, account, min_rebalance_threshold=0.05, min_rebalance_interval_minutes=60):
        """
        객체 생성 시, account와 재조정 임계치, 최소 재조정 간격에 따라 고유한 인스턴스를 반환합니다.
        
        Parameters:
            account (object): 자산 정보를 포함한 계좌 객체.
            min_rebalance_threshold (float): 재조정을 위한 최소 비율 차이.
            min_rebalance_interval_minutes (int): 재조정 간 최소 시간 간격(분).
        
        Returns:
            AssetManager 인스턴스 (싱글톤 패턴 적용).
        """
        # 계좌의 고유 id와 임계치, 간격을 기준으로 고유 키 생성
        key = (id(account), min_rebalance_threshold, min_rebalance_interval_minutes)
        if key not in cls._instances:
            # 아직 인스턴스가 없으면 새로 생성 후 저장
            instance = super(AssetManager, cls).__new__(cls)
            cls._instances[key] = instance
        return cls._instances[key]

    def __init__(self, account, min_rebalance_threshold=0.05, min_rebalance_interval_minutes=60):
        """
        AssetManager 인스턴스를 초기화합니다.
        
        Parameters:
            account (object): 거래 계좌 객체로, 스팟 및 스테이블코인 잔고와 변환 메소드를 포함.
            min_rebalance_threshold (float): 리밸런싱을 실행하기 위한 최소 잔고 차이 비율.
            min_rebalance_interval_minutes (int): 연속 리밸런싱 간 최소 시간 간격(분).
        
        Returns:
            None
        """
        # 이미 초기화된 인스턴스는 재초기화를 방지 (싱글톤 패턴)
        if hasattr(self, '_initialized') and self._initialized:
            return

        # 계좌 객체가 None이면 에러 발생
        if account is None:
            raise ValueError("Account must not be None.")
        self.account = account
        # 모듈 전반에 걸쳐 로깅을 사용하기 위한 로거 설정
        self.logger = setup_logger(__name__)
        # 추가적인 로깅 유틸리티 객체 생성
        self.log_util = LoggingUtil(__name__)
        # 재조정 임계치와 최소 재조정 간격 설정
        self.min_rebalance_threshold = min_rebalance_threshold
        self.min_rebalance_interval = timedelta(minutes=min_rebalance_interval_minutes)
        # 마지막 재조정 시간과 마지막 계좌 상태를 추적하기 위한 변수 초기화
        self.last_rebalance_time = None
        self.last_account_state = None
        # 초기화 정보 디버그 로그 기록
        self.logger.debug(
            f"AssetManager initialized with threshold {min_rebalance_threshold} and interval {min_rebalance_interval_minutes} min"
        )
        self._initialized = True

    def _get_account_state(self):
        """
        현재 계좌의 상태(스팟 잔고와 스테이블코인 잔고)를 소수점 4자리로 반올림하여 반환합니다.
        
        Returns:
            tuple: (spot_balance, stablecoin_balance)
        """
        return (round(self.account.spot_balance, 4), round(self.account.stablecoin_balance, 4))

    def rebalance(self, market_regime):
        """
        계좌의 자산 배분을 현재 시장 상황(market_regime)에 따라 재조정합니다.
        
        1. 최근 재조정 시간과 최소 재조정 간격을 비교하여 재조정 실행 여부를 결정.
        2. 총 자산(스팟+스테이블코인)과 현재 스팟 비중을 기준으로 목표 스팟 비중(desired_spot)을 산정.
        3. 목표와 실제 간의 차이가 임계치(min_rebalance_threshold)를 초과하면 자산 변환 실행.
           - 스팟 잔고가 부족하면 스테이블코인을 스팟으로 변환.
           - 과다하면 스팟을 스테이블코인으로 변환.
        4. 변환 후 계좌 상태를 업데이트하고 이벤트 로그를 남깁니다.
        
        Parameters:
            market_regime (str or numeric): 현재 시장 상태를 나타내며 "bullish", "bearish", "sideways" 중 하나를 기대.
        
        Returns:
            None
        """
        # 현재 시간을 타임스탬프로 기록
        current_time = pd.Timestamp.now()
        # 마지막 재조정 시간과의 간격이 최소 재조정 간격보다 짧으면 재조정 스킵
        if self.last_rebalance_time and (current_time - self.last_rebalance_time < self.min_rebalance_interval):
            self.logger.debug("Rebalance skipped due to interval constraint.")
            return

        # 총 자산 계산: 스팟 잔고와 스테이블코인 잔고의 합
        total_assets = self.account.spot_balance + self.account.stablecoin_balance
        if total_assets <= 0:
            self.logger.warning("Total assets <= 0. Skipping rebalance.")
            return

        # market_regime이 문자열이 아닌 경우, 숫자를 문자열로 매핑 (예: 0.0 -> "bullish")
        if not isinstance(market_regime, str):
            try:
                market_regime = {0.0: "bullish", 1.0: "bearish", 2.0: "sideways"}.get(float(market_regime), "unknown")
            except Exception:
                market_regime = "unknown"
        regime = market_regime.lower()
        if regime not in ["bullish", "bearish", "sideways"]:
            self.logger.warning(f"Market regime '{market_regime}' is unknown; treating as 'sideways'.")
            regime = "sideways"

        # 시장 상태에 따라 목표 스팟 비중 계산:
        # - bullish (또는 enter_long): 스팟 비중 90% 또는 100%
        # - bearish (또는 exit_all): 스팟 비중 10% 또는 0%
        # - sideways: 스팟 비중 60%
        if regime in ["bullish", "enter_long"]:
            desired_spot = total_assets * (1.0 if regime == "enter_long" else 0.90)
        elif regime in ["bearish", "exit_all"]:
            desired_spot = total_assets * (0.0 if regime == "exit_all" else 0.10)
        elif regime == "sideways":
            desired_spot = total_assets * 0.60

        # 현재 스팟 잔고와 목표 스팟 잔고의 차이를 계산
        current_spot = self.account.spot_balance
        diff_ratio = abs(current_spot - desired_spot) / total_assets
        # 차이가 임계치보다 작으면 재조정 불필요
        if diff_ratio < self.min_rebalance_threshold:
            self.logger.debug("No significant imbalance detected; skipping rebalance.")
            return

        try:
            if current_spot < desired_spot:
                # 스팟 잔고 부족 시: 스테이블코인을 스팟으로 변환할 금액 산정 후 변환 실행
                amount_to_convert = desired_spot - current_spot
                converted = self.account.convert_to_spot(amount_to_convert)
                self.logger.debug(f"Rebalance ({regime.capitalize()}): Converted {converted:.2f} from stablecoin to spot.")
            else:
                # 과잉 시: 스팟 잔고 일부를 스테이블코인으로 변환
                amount_to_convert = current_spot - desired_spot
                converted = self.account.convert_to_stablecoin(amount_to_convert)
                self.logger.debug(f"Rebalance ({regime.capitalize()}): Converted {converted:.2f} from spot to stablecoin.")
        except Exception as e:
            # 변환 중 예외 발생 시 에러 로그 기록
            self.logger.error(f"Rebalance conversion failed: {e}", exc_info=True)
            return

        # 재조정 완료 후 마지막 재조정 시간 업데이트
        self.last_rebalance_time = current_time
        # 계좌 상태 업데이트 후, 이전 상태와 다르면 이벤트 로그 기록
        new_state = self._get_account_state()
        if new_state != self.last_account_state:
            self.last_account_state = new_state
            self.log_util.log_event("Rebalance complete", state_key="asset_state")

import uuid  # 포지션 식별자 생성을 위한 uuid 모듈 임포트
from logging.logger_config import setup_logger  # 로그 설정 함수를 임포트하여 로깅 설정

# 모듈 이름(__name__)을 기반으로 로거 인스턴스 생성
logger = setup_logger(__name__)  # 전역 로거: 포지션 관련 이벤트 로깅에 사용됨


class Position:
    """
    Position 클래스는 개별 거래 포지션을 관리합니다.
    
    Attributes:
        position_id (str): 포지션의 고유 식별자.
        side (str): 포지션의 방향 ("LONG" 또는 "SHORT").
        executions (list): 해당 포지션에서 발생한 거래 실행 기록 목록.
        initial_price (float): 포지션이 시작될 때의 진입 가격.
        maximum_size (float): 포지션의 최대 허용 크기.
        total_splits (int): 포지션 진입 시 계획된 분할 수.
        executed_splits (int): 실제 실행된 분할 수.
        allocation_plan (list): 자금 배분 계획.
        highest_price (float) 또는 lowest_price (float): 포지션의 진행 상황에 따른 최고 또는 최저 가격.
    """
    
    def __init__(self, side: str = "LONG", initial_price: float = None, maximum_size: float = 0.0,
                 total_splits: int = 1, allocation_plan: list = None) -> None:
        """
        새로운 거래 포지션을 초기화합니다.
        
        Parameters:
            side (str): 거래 방향 ("LONG"은 매수, "SHORT"는 매도). 기본값은 "LONG".
            initial_price (float): 포지션 진입 시 가격. 반드시 양수여야 함.
            maximum_size (float): 포지션이 가질 수 있는 최대 크기.
            total_splits (int): 포지션을 분할해 진입할 총 횟수.
            allocation_plan (list): 자금 배분 전략을 담은 리스트 (선택 사항).
            
        Raises:
            ValueError: initial_price가 제공되지 않았거나 0 이하인 경우.
        """
        if initial_price is None or initial_price <= 0:
            raise ValueError("Initial price must be positive.")
        # 고유 포지션 식별자 생성 (UUID 사용)
        self.position_id: str = str(uuid.uuid4())
        # 거래 방향을 대문자로 변환하여 저장 (예: "LONG", "SHORT")
        self.side: str = side.upper()
        # 거래 실행 기록을 저장할 리스트 초기화
        self.executions: list = []
        self.initial_price: float = initial_price
        self.maximum_size: float = maximum_size
        self.total_splits: int = total_splits
        self.executed_splits: int = 0
        # 배분 계획이 제공되지 않으면 빈 리스트로 초기화
        self.allocation_plan: list = allocation_plan if allocation_plan is not None else []
        # LONG 포지션은 진입 후 최고가를, SHORT 포지션은 최저가를 추적
        if self.side == "SHORT":
            self.lowest_price: float = initial_price
        else:
            self.highest_price: float = initial_price
        logger.debug(f"New position created: ID={self.position_id}, side={self.side}, entry price={self.initial_price}")

    def add_execution(self, entry_price: float, size: float, stop_loss: float = None,
                      take_profit: float = None, entry_time=None, exit_targets: list = None,
                      trade_type: str = "unknown", min_order_size: float = 1e-8) -> None:
        """
        포지션에 새로운 거래 실행 기록을 추가합니다.
        
        각 실행은 포지션 내에서 개별 거래를 나타내며, 진입 가격, 거래 수량, 
        손절/익절 가격, 거래 유형 등 다양한 거래 정보를 포함합니다.
        
        Parameters:
            entry_price (float): 거래 실행 시의 진입 가격.
            size (float): 거래 수량.
            stop_loss (float): (선택) 손절 가격.
            take_profit (float): (선택) 익절 가격.
            entry_time: (선택) 거래 실행 시각.
            exit_targets (list): (선택) 부분 청산 목표를 나타내는 (목표 가격, 청산 비율) 튜플의 리스트.
            trade_type (str): 거래 유형을 설명하는 문자열 (기본값 "unknown").
            min_order_size (float): 최소 허용 거래 수량 (거래 실행 검증용, 기본값 매우 작은 수).
            
        Returns:
            None
        
        Notes:
            - 거래 수량이 최소 주문 크기보다 작으면 실행이 추가되지 않습니다.
            - exit_targets는 리스트 형식이어야 하며, 각 목표는 딕셔너리 형태로 변환되어 저장됩니다.
            - LONG 포지션은 진입 이후 최고가, SHORT 포지션은 최저가를 추적합니다.
        """
        # 최소 주문 수량 이하일 경우 실행 추가하지 않고 경고 로그 출력
        if size < min_order_size:
            logger.warning("Execution size below minimum order size; execution not added.")
            return
        # exit_targets가 제공되었을 때 리스트 타입이 아니면 오류 로그 출력 후 종료
        if exit_targets and not isinstance(exit_targets, list):
            logger.error("exit_targets must be a list.", exc_info=True)
            return

        targets = []
        # exit_targets가 존재하면, 각 목표 가격과 청산 비율을 포함하는 딕셔너리 생성
        if exit_targets:
            for target_price, exit_ratio in exit_targets:
                targets.append({'price': target_price, 'exit_ratio': exit_ratio, 'hit': False})
        # 실행 기록을 딕셔너리 형태로 생성하여 필요한 모든 정보를 포함
        execution = {
            'entry_price': entry_price,
            'size': size,
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'entry_time': entry_time,
            'exit_targets': targets,
            'trade_type': trade_type,
            'closed': False
        }
        # 포지션 방향에 따라 실행 후 추적할 극단값(최고가 또는 최저가) 초기화
        if self.side == "SHORT":
            execution["lowest_price_since_entry"] = entry_price
        else:
            execution["highest_price_since_entry"] = entry_price

        # 생성된 실행 기록을 포지션의 executions 리스트에 추가
        self.executions.append(execution)
        logger.debug(f"Execution added: entry_price={entry_price}, size={size}, type={trade_type}")

    def update_extremum(self, current_price: float) -> None:
        """
        모든 열려 있는 거래 실행에 대해, 현재 시장 가격을 반영하여 최고가 또는 최저가 값을 업데이트합니다.
        
        Parameters:
            current_price (float): 최신 시장 가격.
            
        Returns:
            None
        
        Notes:
            - LONG 포지션의 경우, 현재 가격이 이전 최고가보다 높으면 최고가를 갱신합니다.
            - SHORT 포지션의 경우, 현재 가격이 이전 최저가보다 낮으면 최저가를 갱신합니다.
        """
        for record in self.executions:
            if record.get("closed", False):
                continue  # 이미 종료된 실행은 건너뜁니다.
            if self.side == "LONG":
                # LONG 포지션: 이전 최고가와 비교하여 갱신
                prev = record.get("highest_price_since_entry", record["entry_price"])
                if current_price > prev:
                    record["highest_price_since_entry"] = current_price
                    logger.debug(f"Updated highest price: {prev} -> {current_price} for execution at entry {record['entry_price']}")
            elif self.side == "SHORT":
                # SHORT 포지션: 이전 최저가와 비교하여 갱신
                prev = record.get("lowest_price_since_entry", record["entry_price"])
                if current_price < prev:
                    record["lowest_price_since_entry"] = current_price
                    logger.debug(f"Updated lowest price: {prev} -> {current_price} for execution at entry {record['entry_price']}")
        logger.debug(f"Extremum values updated with current_price={current_price}")

    def get_total_size(self) -> float:
        """
        포지션 내 모든 열려 있는 실행의 총 거래 수량을 계산합니다.
        
        Returns:
            float: 미종료 실행들의 수량 합계.
        """
        return sum(record['size'] for record in self.executions if not record.get("closed", False))

    def get_average_entry_price(self) -> float:
        """
        포지션 내 모든 열려 있는 실행의 가중 평균 진입 가격을 계산합니다.
        
        가중치는 각 실행의 거래 수량에 비례합니다.
        
        Returns:
            float: 가중 평균 진입 가격. 열려 있는 실행이 없으면 0.0을 반환.
        """
        total_cost = sum(record['entry_price'] * record['size'] for record in self.executions if not record.get("closed", False))
        total_qty = self.get_total_size()
        return total_cost / total_qty if total_qty > 0 else 0.0

    def remove_execution(self, index: int) -> None:
        """
        지정한 인덱스의 실행 기록을 포지션에서 제거합니다.
        
        Parameters:
            index (int): 제거할 실행 기록의 인덱스.
            
        Returns:
            None
        
        Notes:
            - 인덱스가 유효하지 않으면 경고 로그를 남깁니다.
        """
        if 0 <= index < len(self.executions):
            self.executions.pop(index)
            logger.debug(f"Execution removed at index {index}")
        else:
            logger.warning(f"Failed to remove execution: invalid index {index}")

    def is_empty(self) -> bool:
        """
        포지션 내 모든 실행이 종료되었는지 여부를 확인합니다.
        
        Returns:
            bool: 모든 실행이 종료되었다면 True, 그렇지 않으면 False.
        """
        return all(record.get("closed", False) for record in self.executions)

    def partial_close_execution(self, index: int, close_ratio: float, min_order_size: float = 1e-8) -> float:
        """
        포지션의 특정 실행을 부분적으로 청산하여 거래 수량을 줄입니다.
        
        Parameters:
            index (int): 청산할 실행 기록의 인덱스.
            close_ratio (float): 청산할 비율 (0보다 크고 1 이하).
            min_order_size (float): 남은 거래 수량이 이 값보다 작으면 해당 실행을 종료 처리합니다.
            
        Returns:
            float: 청산된 거래 수량. 청산에 실패하면 0.0 반환.
        
        Notes:
            - close_ratio가 유효한 범위(0,1]가 아니면 오류 로그를 남깁니다.
            - 실행 후 남은 거래 수량이 최소 주문 크기보다 작으면 해당 실행을 종료 상태로 표시합니다.
        """
        if not (0 < close_ratio <= 1):
            logger.error("close_ratio must be between 0 and 1.", exc_info=True)
            return 0.0
        if 0 <= index < len(self.executions):
            record = self.executions[index]
            # 청산할 거래 수량 계산 (현재 수량의 close_ratio 비율)
            qty_to_close = record['size'] * close_ratio
            # 거래 수량 감소 처리
            record['size'] -= qty_to_close
            # exit_targets가 있다면, 청산 처리된 타겟은 제거
            if record.get('exit_targets'):
                record['exit_targets'] = [t for t in record['exit_targets'] if not t.get('hit', False)]
            # 남은 거래 수량이 최소 주문 크기보다 작으면 해당 실행을 종료로 처리
            if record['size'] < min_order_size:
                record['closed'] = True
                logger.debug(f"Execution at index {index} closed due to size below minimum order size.")
            logger.debug(f"Partial close executed: index={index}, ratio={close_ratio}, closed qty={qty_to_close}")
            return qty_to_close
        logger.warning(f"Partial close failed: invalid index {index}")
        return 0.0

---

# trading/risk_management.py

from logs.log_config import setup_logger

# 전역 변수 및 객체 정의
# logger: 이 모듈에서 발생하는 디버그 및 에러 메시지를 기록하는 로깅 객체입니다.
logger = setup_logger(__name__)


class RiskManager:
    def __init__(self):
        # 인스턴스 별로 로거 객체를 초기화합니다.
        self.logger = setup_logger(__name__)

    def compute_position_size(
        self,
        available_balance: float,
        risk_percentage: float,
        entry_price: float,
        stop_loss: float,
        fee_rate: float = 0.001,
        min_order_size: float = 1e-8,
        volatility: float = 0.0,
        weekly_volatility: float = None,
        weekly_risk_coefficient: float = 1.0
    ) -> float:
        """
        주어진 위험 관리 파라미터를 바탕으로 적절한 포지션 크기를 계산합니다.
        
        Parameters:
          - available_balance (float): 사용 가능한 총 잔고.
          - risk_percentage (float): 거래에 노출할 위험 비율 (0과 1 사이).
          - entry_price (float): 진입 가격.
          - stop_loss (float): 손절 가격.
          - fee_rate (float): 거래 수수료 비율 (예: 0.001).
          - min_order_size (float): 최소 주문 크기.
          - volatility (float): 현재 변동성 지표.
          - weekly_volatility (float): 주간 변동성 (옵션).
          - weekly_risk_coefficient (float): 주간 변동성에 적용할 위험 계수.
        
        Returns:
          - float: 계산된 포지션 사이즈. 계산 조건에 맞지 않을 경우 0.0 반환.
        
        동작 방식:
          - 사용 가능한 잔고와 위험 비율을 곱해 최대 위험 금액(max_risk)을 산출합니다.
          - 진입 가격과 손절 가격의 차이 및 수수료를 반영해 단위당 손실(loss_per_unit)을 계산합니다.
          - 변동성(현재 및 주간)이 있을 경우 추가 조정하여 최종 포지션 사이즈를 산출합니다.
          - 최종 포지션 사이즈가 최소 주문 크기를 만족하지 않으면 0.0을 반환합니다.
        """
        if available_balance <= 0:
            self.logger.error(f"Available balance is {available_balance}; no funds available for trading.", exc_info=True)
            return 0.0
        if not (0 < risk_percentage <= 1):
            self.logger.error(f"Invalid risk_percentage ({risk_percentage}). Must be between 0 and 1.", exc_info=True)
            return 0.0
        if fee_rate < 0:
            self.logger.error(f"Invalid fee_rate ({fee_rate}). Must be non-negative.", exc_info=True)
            return 0.0
        if volatility < 0 or (weekly_volatility is not None and weekly_volatility < 0):
            self.logger.error("Volatility values must be non-negative.", exc_info=True)
            return 0.0

        if entry_price <= 0 or stop_loss <= 0:
            self.logger.error(f"Invalid entry_price ({entry_price}) or stop_loss ({stop_loss}). Must be positive.", exc_info=True)
            return 0.0

        # 진입 가격과 손절 가격 간의 차이를 계산합니다.
        price_diff = abs(entry_price - stop_loss)
        if price_diff == 0:
            self.logger.error("Zero price difference between entry and stop_loss; assigning minimal epsilon to price_diff.", exc_info=True)
            price_diff = entry_price * 1e-4

        # 최대 위험 금액 계산: available_balance * risk_percentage
        max_risk = available_balance * risk_percentage
        fee_amount = entry_price * fee_rate
        loss_per_unit = price_diff + fee_amount

        if loss_per_unit <= 0:
            self.logger.error("Non-positive loss per unit computed.", exc_info=True)
            return 0.0

        # 초기 포지션 사이즈 계산
        computed_size = max_risk / loss_per_unit
        self.logger.debug(f"Initial computed size: {computed_size:.8f} (max_risk={max_risk}, loss_per_unit={loss_per_unit})")

        # 변동성이 존재하면 포지션 사이즈를 추가 조정합니다.
        if volatility > 0:
            computed_size /= ((1 + volatility) ** 2)
            self.logger.debug(f"Size adjusted for volatility {volatility} with square factor: {computed_size:.8f}")

        if weekly_volatility is not None:
            computed_size /= (1 + weekly_risk_coefficient * weekly_volatility)
            self.logger.debug(f"Size adjusted for weekly_volatility {weekly_volatility} with coefficient {weekly_risk_coefficient}: {computed_size:.8f}")

        final_size = computed_size if computed_size >= min_order_size else 0.0
        self.logger.debug(f"Final computed position size: {final_size:.8f} (min_order_size={min_order_size})")
        return final_size

    def allocate_position_splits(
        self,
        total_size: float,
        splits_count: int = 3,
        allocation_mode: str = 'equal',
        min_order_size: float = 1e-8
    ) -> list:
        """
        포지션 분할 시, 각 분할의 할당 비율을 계산합니다.
        
        Parameters:
          - total_size (float): 전체 포지션 크기 (참고용; 내부 계산에는 직접 사용하지 않음).
          - splits_count (int): 포지션을 분할할 횟수.
          - allocation_mode (str): 할당 방식 ('equal', 'pyramid_up', 'pyramid_down').
          - min_order_size (float): 최소 주문 크기.
        
        Returns:
          - list: 각 분할에 해당하는 할당 비율의 리스트.
        
        동작 방식:
          - 'equal' 모드인 경우 동일한 비율로 분할합니다.
          - 'pyramid_up' 또는 'pyramid_down' 모드인 경우, 분할 순서에 따라 비율을 점진적으로 증가(또는 감소)시킵니다.
          - 잘못된 입력 값에 대해서는 예외를 발생시킵니다.
        """
        if splits_count < 1:
            raise ValueError("splits_count must be at least 1")
        if allocation_mode not in ['equal', 'pyramid_up', 'pyramid_down']:
            raise ValueError("allocation_mode must be 'equal', 'pyramid_up', or 'pyramid_down'")
        if allocation_mode == 'equal':
            return [1.0 / splits_count] * splits_count
        ratio_sum = splits_count * (splits_count + 1) / 2
        if allocation_mode == 'pyramid_up':
            return [i / ratio_sum for i in range(1, splits_count + 1)]
        else:
            return [i / ratio_sum for i in range(splits_count, 0, -1)]

    def attempt_scale_in_position(
        self,
        position,
        current_price: float,
        scale_in_threshold: float = 0.02,
        slippage_rate: float = 0.0,
        stop_loss: float = None,
        take_profit: float = None,
        entry_time=None,
        trade_type: str = "scale_in",
        dynamic_volatility: float = 1.0
    ):
        """
        포지션에 대해 단계적으로 추가 진입(scale-in)을 시도합니다.
        
        Parameters:
          - position: 현재 포지션 객체로, 포지션의 상태와 할당 계획 정보를 포함해야 합니다.
          - current_price (float): 현재 시장 가격.
          - scale_in_threshold (float): 추가 진입을 위한 가격 변동 임계값 (예: 0.02는 2%).
          - slippage_rate (float): 슬리피지(미끄러짐) 비율.
          - stop_loss (float): 손절 가격 (옵션).
          - take_profit (float): 이익 실현 가격 (옵션).
          - entry_time: 진입 시간 (옵션).
          - trade_type (str): 거래 유형 식별자.
          - dynamic_volatility (float): 동적 변동성 조정 인자.
        
        Returns:
          - None: 포지션 객체에 직접 실행 결과를 추가합니다.
        
        동작 방식:
          - 포지션 객체가 유효하고 비어있지 않은지 확인합니다.
          - 아직 실행되지 않은 분할에 대해 목표 가격을 계산하고, 조건이 충족되면 해당 분할을 실행하여 포지션에 기록합니다.
        """
        try:
            if not position or position.is_empty():
                return

            while position.executed_splits < position.total_splits:
                next_split = position.executed_splits
                # 목표 가격은 초기 가격에 scale_in_threshold와 동적 변동성을 적용하여 계산합니다.
                target_price = position.initial_price * (1 + scale_in_threshold * (next_split + 1)) * dynamic_volatility
                if current_price < target_price:
                    break
                if next_split < len(position.allocation_plan):
                    portion = position.allocation_plan[next_split]
                else:
                    break
                # 각 분할 주문 크기는 전체 포지션 크기에 해당 비율을 곱하여 계산합니다.
                chunk_size = position.maximum_size * portion
                # 슬리피지 적용: 현재 가격에 slippage_rate 만큼 조정합니다.
                executed_price = current_price * (1 + slippage_rate)
                # 포지션 객체에 실행 결과를 추가합니다.
                position.add_execution(
                    entry_price=executed_price,
                    size=chunk_size,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    entry_time=entry_time,
                    trade_type=trade_type
                )
                position.executed_splits += 1
                self.logger.debug(f"Scaled in: split {next_split+1}, executed_price={executed_price:.2f}, chunk_size={chunk_size:.8f}")
        except Exception as e:
            self.logger.error("Error in attempt_scale_in_position: " + str(e), exc_info=True)

    def compute_risk_parameters_by_regime(
        self,
        base_params: dict,
        regime,  # 문자열이 아닐 경우 숫자형 매핑 시도
        liquidity: str = None,
        bullish_risk_multiplier: float = 1.1,
        bullish_atr_multiplier_factor: float = 0.9,
        bullish_profit_ratio_multiplier: float = 1.1,
        bearish_risk_multiplier: float = 0.8,
        bearish_atr_multiplier_factor: float = 1.1,
        bearish_profit_ratio_multiplier: float = 0.9,
        high_liquidity_risk_multiplier: float = 1.0,
        low_liquidity_risk_multiplier: float = 0.8,
        high_atr_multiplier_factor: float = 1.0,
        low_atr_multiplier_factor: float = 1.1,
        high_profit_ratio_multiplier: float = 1.0,
        low_profit_ratio_multiplier: float = 0.9
    ) -> dict:
        """
        시장 상황(레짐)에 따라 기본 위험 파라미터를 조정합니다.
        
        Parameters:
          - base_params (dict): 기본 위험 파라미터 (예: risk_per_trade, atr_multiplier, profit_ratio).
          - regime: 시장 레짐, 문자열 또는 숫자형 매핑 (예: "bullish", "bearish", "sideways").
          - liquidity (str): 유동성 상태 ("high" 또는 "low"); sideways 레짐에서 필수.
          - bullish_risk_multiplier (float): 상승장에서의 위험 배수.
          - bullish_atr_multiplier_factor (float): 상승장에서의 ATR 조정 인자.
          - bullish_profit_ratio_multiplier (float): 상승장에서의 이익 비율 배수.
          - bearish_risk_multiplier (float): 하락장에서의 위험 배수.
          - bearish_atr_multiplier_factor (float): 하락장에서의 ATR 조정 인자.
          - bearish_profit_ratio_multiplier (float): 하락장에서의 이익 비율 배수.
          - high_liquidity_risk_multiplier (float): 고유동성 조건에서의 위험 배수.
          - low_liquidity_risk_multiplier (float): 저유동성 조건에서의 위험 배수.
          - high_atr_multiplier_factor (float): 고유동성 조건에서의 ATR 조정 인자.
          - low_atr_multiplier_factor (float): 저유동성 조건에서의 ATR 조정 인자.
          - high_profit_ratio_multiplier (float): 고유동성 조건에서의 이익 비율 배수.
          - low_profit_ratio_multiplier (float): 저유동성 조건에서의 이익 비율 배수.
        
        Returns:
          - dict: 조정된 위험 파라미터 딕셔너리.
        
        동작 방식:
          - regime 값을 문자열로 변환(또는 숫자형 매핑)한 후, 각 시장 상황에 따라 기본 파라미터에 특정 배수를 적용합니다.
          - sideways 레짐인 경우 유동성 정보가 필수이며, 추가적으로 현재 변동성이 제공되면 위험 비율을 보정합니다.
        """
        if not isinstance(regime, str):
            try:
                regime = {0.0: "bullish", 1.0: "bearish", 2.0: "sideways"}.get(float(regime))
            except Exception:
                regime = "unknown"
        regime = regime.lower()
        if regime not in ["bullish", "bearish", "sideways"]:
            self.logger.error(f"Invalid market regime: {regime}")
            raise ValueError(f"Invalid market regime: {regime}")
        
        if regime == "sideways":
            if liquidity is None:
                self.logger.error("Liquidity info required for sideways regime")
                raise ValueError("Liquidity info required for sideways regime")
        
        risk_params = {}
        try:
            if regime == "bullish":
                risk_params['risk_per_trade'] = base_params['risk_per_trade'] * bullish_risk_multiplier
                risk_params['atr_multiplier'] = base_params['atr_multiplier'] * bullish_atr_multiplier_factor
                risk_params['profit_ratio'] = base_params['profit_ratio'] * bullish_profit_ratio_multiplier
            elif regime == "bearish":
                risk_params['risk_per_trade'] = base_params['risk_per_trade'] * bearish_risk_multiplier
                risk_params['atr_multiplier'] = base_params['atr_multiplier'] * bearish_atr_multiplier_factor
                risk_params['profit_ratio'] = base_params['profit_ratio'] * bearish_profit_ratio_multiplier
            elif regime == "sideways":
                if liquidity.lower() == "high":
                    risk_params['risk_per_trade'] = base_params['risk_per_trade'] * high_liquidity_risk_multiplier
                    risk_params['atr_multiplier'] = base_params['atr_multiplier'] * high_atr_multiplier_factor
                    risk_params['profit_ratio'] = base_params['profit_ratio'] * high_profit_ratio_multiplier
                else:
                    risk_params['risk_per_trade'] = base_params['risk_per_trade'] * low_liquidity_risk_multiplier
                    risk_params['atr_multiplier'] = base_params['atr_multiplier'] * low_atr_multiplier_factor
                    risk_params['profit_ratio'] = base_params['profit_ratio'] * low_profit_ratio_multiplier
            elif regime == "unknown":
                self.logger.warning("Market regime is unknown; applying conservative risk adjustments.")
                if liquidity is not None:
                    liquidity = liquidity.lower()
                    if liquidity == "high":
                        risk_params['risk_per_trade'] = base_params['risk_per_trade'] * 0.95
                        risk_params['atr_multiplier'] = base_params['atr_multiplier']
                        risk_params['profit_ratio'] = base_params['profit_ratio']
                    else:
                        risk_params['risk_per_trade'] = base_params['risk_per_trade'] * 0.90
                        risk_params['atr_multiplier'] = base_params['atr_multiplier']
                        risk_params['profit_ratio'] = base_params['profit_ratio']
                else:
                    risk_params = {
                        'risk_per_trade': base_params['risk_per_trade'] * 0.95,
                        'atr_multiplier': base_params['atr_multiplier'],
                        'profit_ratio': base_params['profit_ratio']
                    }
            else:
                self.logger.error(f"Invalid market regime: {regime}; using default risk parameters.", exc_info=True)
                return base_params

            # 현재 변동성이 제공된 경우, 위험 비율에 추가 보정을 적용합니다.
            current_volatility = base_params.get("current_volatility", None)
            if current_volatility is not None:
                if current_volatility > 0.05:
                    risk_params['risk_per_trade'] *= 0.8
                    self.logger.debug(f"Adjusted risk_per_trade for high volatility {current_volatility}")
                else:
                    risk_params['risk_per_trade'] *= 1.1
                    self.logger.debug(f"Adjusted risk_per_trade for low volatility {current_volatility}")

            self.logger.debug(f"Computed risk parameters: {risk_params}")
            return risk_params
        except Exception as e:
            self.logger.error("Error computing risk parameters: " + str(e), exc_info=True)
            raise

    def adjust_trailing_stop(
        self,
        current_stop: float,
        current_price: float,
        highest_price: float,
        trailing_percentage: float,
        volatility: float = 0.0,
        weekly_high: float = None,
        weekly_volatility: float = None
    ) -> float:
        """
        주어진 매개변수를 기반으로 trailing stop(후행 손절)을 조정합니다.
        
        Parameters:
          - current_stop (float): 현재 설정된 stop 가격.
          - current_price (float): 현재 시장 가격.
          - highest_price (float): 최근 최고 가격.
          - trailing_percentage (float): trailing stop에 적용할 백분율 (예: 0.02는 2%).
          - volatility (float): 현재 변동성 (옵션).
          - weekly_high (float): 주간 최고 가격 (옵션).
          - weekly_volatility (float): 주간 변동성 (옵션).
        
        Returns:
          - float: 조정된 trailing stop 가격.
        
        동작 방식:
          - 현재 stop, 최고 가격 및 trailing 비율을 이용해 새로운 stop 후보를 계산합니다.
          - 주간 정보가 제공된 경우 이를 고려하여 후보 값을 결정하고,
            조건에 따라 현재 stop 값을 갱신할지 결정합니다.
        """
        if current_price <= 0 or highest_price <= 0:
            self.logger.error(f"Invalid current_price ({current_price}) or highest_price ({highest_price}).", exc_info=True)
            raise ValueError("current_price and highest_price must be positive.")
        if trailing_percentage < 0:
            self.logger.error(f"Invalid trailing_percentage ({trailing_percentage}). Must be non-negative.", exc_info=True)
            raise ValueError("trailing_percentage must be non-negative.")
        try:
            if current_stop is None or current_stop <= 0:
                current_stop = highest_price * (1 - trailing_percentage * (1 + volatility))
            new_stop_intraday = highest_price * (1 - trailing_percentage * (1 + volatility))
            if weekly_high is not None:
                w_vol = weekly_volatility if weekly_volatility is not None else 0.0
                new_stop_weekly = weekly_high * (1 - trailing_percentage * (1 + w_vol))
                candidate_stop = max(new_stop_intraday, new_stop_weekly)
            else:
                candidate_stop = new_stop_intraday
            adjusted_stop = candidate_stop if candidate_stop > current_stop and candidate_stop < current_price else current_stop
            self.logger.debug(f"Adjusted trailing stop: {adjusted_stop:.2f} (current_stop={current_stop}, candidate_stop={candidate_stop}, current_price={current_price})")
            return adjusted_stop
        except Exception as e:
            self.logger.error("adjust_trailing_stop error: " + str(e), exc_info=True)
            raise

    def calculate_partial_exit_targets(
        self,
        entry_price: float,
        partial_exit_ratio: float = 0.5,
        partial_profit_ratio: float = 0.03,
        final_profit_ratio: float = 0.06,
        final_exit_ratio: float = 1.0,
        use_weekly_target: bool = False,
        weekly_momentum: float = None,
        weekly_adjustment_factor: float = 0.5
    ):
        """
        진입 가격을 기준으로 부분 청산 및 최종 청산 목표 가격을 계산합니다.
        
        Parameters:
          - entry_price (float): 진입 가격.
          - partial_exit_ratio (float): 부분 청산 시 청산 비율.
          - partial_profit_ratio (float): 부분 이익 목표 비율.
          - final_profit_ratio (float): 최종 이익 목표 비율.
          - final_exit_ratio (float): 최종 청산 시 청산 비율.
          - use_weekly_target (bool): 주간 모멘텀을 적용할지 여부.
          - weekly_momentum (float): 주간 모멘텀 값 (옵션).
          - weekly_adjustment_factor (float): 주간 모멘텀에 적용할 조정 인자.
        
        Returns:
          - list of tuples: 각 청산 단계에 대해 (목표 가격, 청산 비율)을 담은 튜플 리스트.
        
        동작 방식:
          - 주간 모멘텀이 사용되는 경우, 이를 반영하여 목표 이익 비율을 조정합니다.
          - 진입 가격에 목표 이익 비율을 적용해 부분 및 최종 청산 가격을 계산합니다.
        """
        if entry_price <= 0:
            self.logger.error(f"Invalid entry_price: {entry_price}; must be positive.", exc_info=True)
            raise ValueError(f"Invalid entry_price: {entry_price}. Must be positive.")
        try:
            if use_weekly_target and weekly_momentum is not None:
                adjusted_partial = partial_profit_ratio + weekly_adjustment_factor * weekly_momentum
                adjusted_final = final_profit_ratio + weekly_adjustment_factor * weekly_momentum
            else:
                adjusted_partial = partial_profit_ratio
                adjusted_final = final_profit_ratio
            partial_target = round(entry_price * (1 + adjusted_partial), 2)
            final_target = round(entry_price * (1 + adjusted_final), 2)
            self.logger.debug(f"Partial targets: partial={partial_target:.2f}, final={final_target:.2f} (entry_price={entry_price}, adjusted_partial={adjusted_partial}, adjusted_final={adjusted_final})")
            return [(partial_target, partial_exit_ratio), (final_target, final_exit_ratio)]
        except Exception as e:
            self.logger.error("calculate_partial_exit_targets error: " + str(e), exc_info=True)
            raise

# pandas: 데이터 처리 및 통계 관련 기능 제공
# ta: 기술적 분석(Technical Analysis) 라이브러리, ATR(평균 실제 범위) 계산 등 사용
import pandas as pd
import ta
from logs.log_config import setup_logger

# 모듈 전반에 걸쳐 디버그 및 에러 로깅을 위한 로거 객체 생성
logger = setup_logger(__name__)

class InvalidEntryPriceError(ValueError):
    """
    거래 진입 가격이 유효하지 않을 경우 발생시키는 사용자 정의 예외.
    예) 음수 혹은 0인 경우.
    """
    pass

def calculate_atr(data: pd.DataFrame, period: int = 14, min_atr: float = None) -> pd.DataFrame:
    """
    주어진 시장 데이터로부터 ATR(Average True Range)을 계산합니다.
    
    데이터 전처리 및 이상치 제거를 포함하여, TA 라이브러리의 AverageTrueRange를 활용해 ATR을 산출합니다.
    또한, ATR 값이 특정 최소치(min_atr) 이하로 떨어지지 않도록 보정합니다.
    
    Parameters:
        data (pd.DataFrame): 'high', 'low', 'close' 컬럼을 포함하는 시장 데이터.
        period (int): ATR 계산을 위한 이동 윈도우 기간 (기본값: 14).
        min_atr (float): 최소 ATR 값; 제공되지 않으면 평균 종가의 1%로 설정.
    
    Returns:
        pd.DataFrame: 원본 데이터프레임에 'atr' 컬럼이 추가된 결과.
    """
    # 필수 컬럼들이 데이터에 포함되어 있는지 확인
    required_cols = ['high', 'low', 'close']
    for col in required_cols:
        if col not in data.columns:
            raise ValueError(f"Missing required column: {col}")
    
    # 'high'가 'low'보다 작은 행은 제외하여 데이터의 신뢰성을 확보
    data = data[data['high'] >= data['low']].copy()
    
    # 'close' 값이 'low'보다 낮으면 'low'로, 'high'보다 높으면 'high'로 조정
    data.loc[data['close'] < data['low'], 'close'] = data['low']
    data.loc[data['close'] > data['high'], 'close'] = data['high']
    
    # 각 행의 가격 범위 계산 및 중앙값(typical range) 산출
    range_series = data['high'] - data['low']
    typical_range = range_series.median()
    if typical_range > 0:
        # 범위가 중앙값의 3배를 넘는 이상치 제거
        data = data[range_series <= (3 * typical_range)]
    else:
        logger.debug("Typical range is zero; skipping outlier filtering.")
    
    # 데이터 길이에 따라 효과적인 period 설정
    effective_period = period if len(data) >= period else len(data)
    
    try:
        if effective_period < 1:
            data['atr'] = 0
        elif len(data) < effective_period:
            # 데이터 포인트가 충분하지 않은 경우 단순히 (high - low) 값을 ATR로 사용
            data['atr'] = data['high'] - data['low']
        else:
            # ta 라이브러리를 사용해 Average True Range 계산
            atr_indicator = ta.volatility.AverageTrueRange(
                high=data['high'],
                low=data['low'],
                close=data['close'],
                window=effective_period,
                fillna=True
            )
            data['atr'] = atr_indicator.average_true_range()
    except Exception as e:
        # 계산 중 오류 발생 시 에러 로그 기록 후, fallback으로 (high - low) 사용
        logger.error("calculate_atr error: " + str(e), exc_info=True)
        data['atr'] = data['high'] - data['low']
    
    # 평균 종가를 기반으로 최소 ATR 값 결정 (기본: 평균 종가의 1%)
    avg_close = data['close'].mean()
    if min_atr is None:
        min_atr = avg_close * 0.01

    # 각 ATR 값이 min_atr 이상이 되도록 보정
    data['atr'] = data['atr'].apply(lambda x: max(x, min_atr))
    
    return data

def calculate_dynamic_stop_and_take(entry_price: float, atr: float, risk_params: dict):
    """
    동적 스톱로스와 테이크프로핏 가격을 계산합니다.
    
    주어진 entry_price와 ATR 값을 기반으로, risk_params에 명시된 매개변수를 활용하여
    스톱로스와 테이크프로핏 수준을 동적으로 산출합니다.
    
    Parameters:
        entry_price (float): 거래 진입 가격.
        atr (float): 시장 변동성을 나타내는 ATR 값.
        risk_params (dict): 리스크 파라미터 사전, 포함 항목:
            - "atr_multiplier": ATR에 적용되는 곱셈 인자.
            - "volatility_multiplier": 변동성 조정을 위한 추가 인자.
            - "risk_reward_ratio": 스톱로스 대비 테이크프로핏의 비율.
            - "fallback_atr": ATR 값이 유효하지 않을 때 사용할 대체 ATR.
    
    Returns:
        tuple: (stop_loss_price, take_profit_price)
    """
    # 유효한 진입 가격 확인: 0 이하이면 예외 발생
    if entry_price <= 0:
        logger.error(f"Invalid entry_price: {entry_price}. Must be positive.", exc_info=True)
        raise InvalidEntryPriceError(f"Invalid entry_price: {entry_price}. Must be positive.")
    # ATR 값이 0 이하일 경우 risk_params에 있는 fallback ATR 사용 또는 기본값 할당
    if atr <= 0:
        logger.error(f"ATR value is non-positive ({atr}). Using fallback ATR value from risk_params if available.", exc_info=True)
        fallback_atr = risk_params.get("fallback_atr", entry_price * 0.01)
        if fallback_atr <= 0:
            fallback_atr = entry_price * 0.01
        atr = fallback_atr
    try:
        # risk_params에서 각 인자들을 가져오되, 기본값 사용
        atr_multiplier = risk_params.get("atr_multiplier", 2.0)
        volatility_multiplier = risk_params.get("volatility_multiplier", 1.0)
        risk_reward_ratio = risk_params.get("risk_reward_ratio", 2.0)
        
        # 인자들의 값을 1.0~5.0 범위로 제한
        atr_multiplier = max(1.0, min(atr_multiplier, 5.0))
        risk_reward_ratio = max(1.0, min(risk_reward_ratio, 5.0))
        
        # 스톱로스 가격 계산: entry_price에서 ATR, atr_multiplier, volatility_multiplier의 곱만큼 차감
        stop_loss_price = entry_price - (atr * atr_multiplier * volatility_multiplier)
        if stop_loss_price <= 0:
            logger.error("Computed stop_loss_price is non-positive; adjusting to at least 50% of entry_price.", exc_info=True)
            stop_loss_price = entry_price * 0.5
        
        # 테이크프로핏 가격 계산: 스톱로스와의 차이를 risk_reward_ratio로 확장
        take_profit_price = entry_price + (entry_price - stop_loss_price) * risk_reward_ratio
        
        logger.debug(f"Calculated stop_loss={stop_loss_price:.2f}, take_profit={take_profit_price:.2f} "
                     f"(entry_price={entry_price}, atr={atr}, atr_multiplier={atr_multiplier}, "
                     f"volatility_multiplier={volatility_multiplier}, risk_reward_ratio={risk_reward_ratio})")
        return stop_loss_price, take_profit_price
    except Exception as e:
        logger.error("calculate_dynamic_stop_and_take error: " + str(e), exc_info=True)
        raise

def calculate_partial_exit_targets(entry_price: float, partial_exit_ratio: float = 0.5,
                                     partial_profit_ratio: float = 0.03, final_profit_ratio: float = 0.06,
                                     final_exit_ratio: float = 1.0, use_weekly_target: bool = False,
                                     weekly_momentum: float = None, weekly_adjustment_factor: float = 0.5):
    """
    부분 청산 타겟 가격들을 계산합니다.
    
    거래 진입 가격을 기반으로 부분 청산과 최종 청산 목표 가격을 산출하며,
    옵션으로 주간 모멘텀(weekly momentum)을 활용해 목표 수익률을 조정할 수 있습니다.
    
    Parameters:
        entry_price (float): 거래 진입 가격.
        partial_exit_ratio (float): 부분 청산 시 청산할 포지션 비율.
        partial_profit_ratio (float): 부분 청산 목표 수익률.
        final_profit_ratio (float): 최종 청산 목표 수익률.
        final_exit_ratio (float): 최종 청산 시 청산할 포지션 비율.
        use_weekly_target (bool): 주간 모멘텀을 적용할지 여부.
        weekly_momentum (float, optional): 주간 모멘텀 값.
        weekly_adjustment_factor (float): 주간 모멘텀에 따른 조정 인자.
    
    Returns:
        list: [(partial_target, partial_exit_ratio), (final_target, final_exit_ratio)]
              각 튜플은 목표 가격과 해당 가격에서 청산할 비율을 의미.
    """
    # 유효한 entry_price 확인
    if entry_price <= 0:
        logger.error(f"Invalid entry_price: {entry_price}. Must be positive.", exc_info=True)
        raise InvalidEntryPriceError(f"Invalid entry_price: {entry_price}. Must be positive.")
    try:
        # 주간 모멘텀이 적용되는 경우, 목표 수익률 조정
        if use_weekly_target and weekly_momentum is not None:
            adjusted_partial = partial_profit_ratio + weekly_adjustment_factor * weekly_momentum
            adjusted_final = final_profit_ratio + weekly_adjustment_factor * weekly_momentum
        else:
            adjusted_partial = partial_profit_ratio
            adjusted_final = final_profit_ratio
        # 목표 가격 계산: entry_price에 (1 + 목표 수익률)을 곱함
        partial_target = entry_price * (1 + adjusted_partial)
        final_target = entry_price * (1 + adjusted_final)
        logger.debug(f"Partial targets: partial={partial_target:.2f}, final={final_target:.2f} "
                     f"(entry_price={entry_price}, adjusted_partial={adjusted_partial}, adjusted_final={adjusted_final})")
        return [(partial_target, partial_exit_ratio), (final_target, final_exit_ratio)]
    except Exception as e:
        logger.error("calculate_partial_exit_targets error: " + str(e), exc_info=True)
        raise

def adjust_trailing_stop(current_stop: float, current_price: float, highest_price: float, trailing_percentage: float,
                           volatility: float = 0.0, weekly_high: float = None, weekly_volatility: float = None) -> float:
    """
    현재 가격 및 변동성을 고려하여 트레일링 스톱을 조정합니다.
    
    인트라데이와 주간 데이터를 모두 활용해, 현재까지의 최고 가격을 기준으로
    새로운 후보 스톱 가격을 산출하고, 이 후보가 기존 스톱보다 개선된 경우에만 업데이트합니다.
    
    Parameters:
        current_stop (float): 현재 설정된 트레일링 스톱 가격.
        current_price (float): 현재 시장 가격.
        highest_price (float): 거래 진입 이후 도달한 최고 가격.
        trailing_percentage (float): 트레일링 스톱 계산에 사용되는 기본 비율.
        volatility (float): 인트라데이 변동성 (기본값: 0.0).
        weekly_high (float, optional): 주간 최고 가격.
        weekly_volatility (float, optional): 주간 변동성.
    
    Returns:
        float: 조정된 트레일링 스톱 가격.
    """
    # current_price와 highest_price가 양수인지 확인
    if current_price <= 0 or highest_price <= 0:
        logger.error(f"Invalid current_price ({current_price}) or highest_price ({highest_price}).", exc_info=True)
        raise ValueError("current_price and highest_price must be positive.")
    # trailing_percentage가 음수이면 에러 발생
    if trailing_percentage < 0:
        logger.error(f"Invalid trailing_percentage ({trailing_percentage}). Must be non-negative.", exc_info=True)
        raise ValueError("trailing_percentage must be non-negative.")
    try:
        # current_stop이 설정되지 않았거나 음수일 경우, 최고가를 기준으로 초기화
        if current_stop is None or current_stop <= 0:
            current_stop = highest_price * (1 - trailing_percentage * (1 + volatility))
        # 인트라데이 기반 후보 스톱 계산
        new_stop_intraday = highest_price * (1 - trailing_percentage * (1 + volatility))
        if weekly_high is not None:
            # 주간 데이터가 제공되면, 주간 후보 스톱 계산 및 두 후보 중 높은 값을 선택
            w_vol = weekly_volatility if weekly_volatility is not None else 0.0
            new_stop_weekly = weekly_high * (1 - trailing_percentage * (1 + w_vol))
            candidate_stop = max(new_stop_intraday, new_stop_weekly)
        else:
            candidate_stop = new_stop_intraday
        # 후보 스톱이 개선되고 현재 가격 이하일 때만 업데이트
        adjusted_stop = candidate_stop if candidate_stop > current_stop and candidate_stop < current_price else current_stop
        logger.debug(f"Adjusted trailing stop: {adjusted_stop:.2f} (current_stop={current_stop}, candidate_stop={candidate_stop}, current_price={current_price})")
        return adjusted_stop
    except Exception as e:
        logger.error("adjust_trailing_stop error: " + str(e), exc_info=True)
        raise

from logs.log_config import setup_logger
import pandas as pd
from trading.calculators import (
    calculate_atr,
    calculate_dynamic_stop_and_take,
    adjust_trailing_stop,
    calculate_partial_exit_targets
)

# 전역 변수 및 객체 정의
# logger: 이 모듈의 거래 실행 관련 정보를 기록하는 로깅 객체입니다.
logger = setup_logger(__name__)


class TradeExecutor:
    @staticmethod
    def compute_atr(data: pd.DataFrame, period: int = 14) -> pd.DataFrame:
        """
        시장 변동성 지표인 ATR(Average True Range)을 계산합니다.
        
        Parameters:
          - data (pd.DataFrame): 시장 데이터가 포함된 데이터프레임.
          - period (int): ATR 계산에 사용될 기간.
        
        Returns:
          - pd.DataFrame: ATR 결과가 포함된 데이터프레임.
        
        동작 방식:
          - 외부의 calculate_atr 함수를 호출하여 데이터프레임에 ATR 값을 계산하고 반환합니다.
        """
        try:
            result = calculate_atr(data, period)
            logger.debug("ATR computed successfully.")
            return result
        except Exception as e:
            logger.error("Error in compute_atr: {}".format(e), exc_info=True)
            raise

    @staticmethod
    def calculate_dynamic_stop_and_take(entry_price: float, atr: float, risk_params: dict):
        """
        ATR 및 위험 파라미터를 기반으로 동적인 손절(stop loss) 및 이익 실현(take profit) 가격을 계산합니다.
        
        Parameters:
          - entry_price (float): 진입 가격.
          - atr (float): Average True Range 값.
          - risk_params (dict): 위험 관리 관련 파라미터 (예: 손절/이익 실현 배수).
        
        Returns:
          - tuple: (stop_loss, take_profit) 값.
        
        동작 방식:
          - 외부의 calculate_dynamic_stop_and_take 함수를 호출하여 계산된 stop loss와 take profit 값을 반환합니다.
        """
        try:
            stop_loss, take_profit = calculate_dynamic_stop_and_take(entry_price, atr, risk_params)
            logger.debug(f"Dynamic stop/take computed: stop_loss={stop_loss:.2f}, take_profit={take_profit:.2f} "
                         f"(entry_price={entry_price}, atr={atr})")
            return stop_loss, take_profit
        except Exception as e:
            logger.error("Error in calculate_dynamic_stop_and_take: {}".format(e), exc_info=True)
            raise

    @staticmethod
    def adjust_trailing_stop(current_stop: float, current_price: float, highest_price: float, trailing_percentage: float):
        """
        주어진 시장 데이터를 바탕으로 trailing stop(후행 손절)을 조정합니다.
        
        Parameters:
          - current_stop (float): 현재 trailing stop 값.
          - current_price (float): 현재 시장 가격.
          - highest_price (float): 최근 최고 가격.
          - trailing_percentage (float): trailing stop 조정을 위한 백분율 (예: 0.02는 2%).
        
        Returns:
          - float: 조정된 trailing stop 값.
        
        동작 방식:
          - 외부의 adjust_trailing_stop 함수를 호출하여 새 trailing stop 값을 계산한 후 반환합니다.
        """
        try:
            new_stop = adjust_trailing_stop(current_stop, current_price, highest_price, trailing_percentage)
            logger.debug(f"Trailing stop adjusted to {new_stop:.2f} (current_price={current_price}, highest_price={highest_price})")
            return new_stop
        except Exception as e:
            logger.error("Error in adjust_trailing_stop: {}".format(e), exc_info=True)
            raise

    @staticmethod
    def calculate_partial_exit_targets(entry_price: float, partial_exit_ratio: float = 0.5,
                                       partial_profit_ratio: float = 0.03, final_profit_ratio: float = 0.06):
        """
        포지션의 일부 청산을 위한 목표 가격들을 계산합니다.
        
        Parameters:
          - entry_price (float): 진입 가격.
          - partial_exit_ratio (float): 부분 청산 시 청산할 비율.
          - partial_profit_ratio (float): 부분 이익 목표 비율.
          - final_profit_ratio (float): 최종 이익 목표 비율.
        
        Returns:
          - list of tuples: 각 청산 단계에 대해 (target_price, exit_ratio)를 담은 튜플 리스트.
        
        동작 방식:
          - 외부의 calculate_partial_exit_targets 함수를 호출하여 부분 및 최종 청산 목표 가격을 계산 후 반환합니다.
        """
        try:
            targets = calculate_partial_exit_targets(entry_price, partial_exit_ratio, partial_profit_ratio, final_profit_ratio)
            logger.debug(f"Partial exit targets computed: {targets} (entry_price={entry_price})")
            return targets
        except Exception as e:
            logger.error("Error in calculate_partial_exit_targets: {}".format(e), exc_info=True)
            raise

---

# trading/trade_decision.py
