[market_analysis 모듈]
# market_analysis/analyze_market.py
from logs.log_config import setup_logger
import pandas as pd
import numpy as np

# 다른 분석 모듈에서 필요한 함수 임포트 (필요 시 실제 모듈에서 호출)
from market_analysis.technical_analysis import compute_rsi
from market_analysis.onchain_analysis import calculate_mvrv_ratio, analyze_exchange_flow
from market_analysis.sentiment_analysis import aggregate_sentiment
from market_analysis.ml_market_analysis import MarketLSTMAnalyzer

logger = setup_logger(__name__)

def get_technical_signal(price_series: pd.Series, window: int = 14) -> str:
    """
    기술적 분석 신호를 산출합니다.
    - RSI가 50 이상이면 bullish, 50 미만이면 bearish로 판단하며,
      단, 극단 값(예: RSI가 70 이상 또는 30 이하)일 경우 추가 고려할 수 있습니다.
      
    Parameters:
        price_series (pd.Series): 가격 시계열 데이터.
        window (int): RSI 계산 기간 (기본: 14).
    
    Returns:
        str: 'bullish', 'bearish' 또는 'sideways'.
    """
    try:
        rsi = compute_rsi(price_series, window)
        current_rsi = rsi.iloc[-1]
        logger.debug(f"Computed RSI: {current_rsi:.2f}")
        if current_rsi >= 50:
            return "bullish"
        elif current_rsi < 50:
            return "bearish"
        else:
            return "sideways"
    except Exception as e:
        logger.error(f"Error in technical signal computation: {e}", exc_info=True)
        return "sideways"

def get_onchain_signal(market_cap: float, realized_cap: float,
                       exchange_inflow: float, exchange_outflow: float,
                       mvrv_threshold: float = 2.0) -> str:
    """
    온체인 데이터를 바탕으로 시장 신호를 산출합니다.
    
    - MVRV 비율이 높으면(예: mvrv > threshold) bearish, 낮으면 bullish로 판단합니다.
    - 거래소 유입/유출 데이터에 따라 'accumulation'은 bullish, 'distribution'은 bearish 신호로 해석합니다.
    - 두 신호가 상반될 경우 'sideways'로 판단합니다.
    
    Parameters:
        market_cap (float): 시가총액.
        realized_cap (float): 실현 시가총액.
        exchange_inflow (float): 거래소 유입량.
        exchange_outflow (float): 거래소 유출량.
        mvrv_threshold (float): MVRV 비율 임계값 (기본: 2.0).
        
    Returns:
        str: 'bullish', 'bearish' 또는 'sideways'.
    """
    try:
        mvrv = calculate_mvrv_ratio(market_cap, realized_cap)
        flow_signal = analyze_exchange_flow(exchange_inflow, exchange_outflow)
        logger.debug(f"MVRV ratio: {mvrv:.2f}, Flow signal: {flow_signal}")

        # 단순 판단: MVRV가 임계값보다 높으면 bearish, 낮으면 bullish
        onchain_signal_mvrv = "bearish" if mvrv > mvrv_threshold else "bullish"
        
        # 거래소 흐름 신호: accumulation은 bullish, distribution은 bearish
        onchain_signal_flow = "bullish" if flow_signal == "accumulation" else "bearish"
        
        # 두 신호가 일치하면 해당 신호, 다르면 중립적 판단
        if onchain_signal_mvrv == onchain_signal_flow:
            return onchain_signal_mvrv
        else:
            return "sideways"
    except Exception as e:
        logger.error(f"Error in onchain signal computation: {e}", exc_info=True)
        return "sideways"

def get_sentiment_signal(texts: list, bullish_threshold: float = 0.1, bearish_threshold: float = -0.1) -> str:
    """
    감성 분석 결과를 기반으로 시장 신호를 산출합니다.
    
    Parameters:
        texts (list): 분석할 텍스트 문자열 리스트.
        bullish_threshold (float): 긍정적 신호 기준 (기본: 0.1).
        bearish_threshold (float): 부정적 신호 기준 (기본: -0.1).
        
    Returns:
        str: 'bullish', 'bearish' 또는 'sideways'.
    """
    try:
        sentiment = aggregate_sentiment(texts)
        logger.debug(f"Aggregated sentiment score: {sentiment:.2f}")
        if sentiment >= bullish_threshold:
            return "bullish"
        elif sentiment <= bearish_threshold:
            return "bearish"
        else:
            return "sideways"
    except Exception as e:
        logger.error(f"Error in sentiment signal computation: {e}", exc_info=True)
        return "sideways"

def get_ml_signal(ml_model: MarketLSTMAnalyzer, ml_input: pd.DataFrame, current_price: float) -> str:
    """
    머신러닝 모델의 예측 결과를 기반으로 시장 신호를 산출합니다.
    
    Parameters:
        ml_model (MarketLSTMAnalyzer): 학습된 LSTM 분석 모델.
        ml_input (pd.DataFrame): 예측에 사용할 데이터.
        current_price (float): 현재 가격.
    
    Returns:
        str: 'bullish' (예측 가격이 현재보다 높음), 'bearish' (낮음), 또는 'sideways' (변화 미미).
    """
    try:
        predictions = ml_model.predict(ml_input)
        # 예측 결과는 (n_samples, 1) 배열로 가정
        predicted_price = predictions[-1, 0]
        logger.debug(f"ML predicted price: {predicted_price:.2f}, current price: {current_price:.2f}")
        if predicted_price > current_price * 1.01:  # 1% 이상 상승 예측 시 bullish
            return "bullish"
        elif predicted_price < current_price * 0.99:  # 1% 이상 하락 예측 시 bearish
            return "bearish"
        else:
            return "sideways"
    except Exception as e:
        logger.error(f"Error in ML signal computation: {e}", exc_info=True)
        return "sideways"
      
def determine_final_market_state(technical_signal: str,
                                 onchain_signal: str,
                                 sentiment_signal: str,
                                 ml_signal: str) -> str:
    """
    개별 분석 신호(기술적, 온체인, 감성, 머신러닝)를 종합하여 최종 시장 상태를 결정합니다.
    
    단순 다수결(majority vote) 방식으로 최종 상태를 산출하며,
    신호 간 상반되는 경우 'sideways'로 판단합니다.
    
    Parameters:
        technical_signal (str): 기술적 분석 신호.
        onchain_signal (str): 온체인 분석 신호.
        sentiment_signal (str): 감성 분석 신호.
        ml_signal (str): 머신러닝 분석 신호.
    
    Returns:
        str: 최종 시장 상태 ('bullish', 'bearish', 'sideways').
    """
    signals = [technical_signal, onchain_signal, sentiment_signal, ml_signal]
    logger.info(f"Individual signals: {signals}")
    counts = {"bullish": signals.count("bullish"),
              "bearish": signals.count("bearish"),
              "sideways": signals.count("sideways")}
    
    logger.debug(f"Signal counts: {counts}")
    
    # 단순 다수결: 가장 많은 신호를 최종 상태로 결정
    final_state = max(counts, key=counts.get)
    # 만약 두 신호 이상이 동일한 경우(예: bullish와 bearish가 같으면) 보수적으로 sideways 반환
    if list(counts.values()).count(counts[final_state]) > 1:
        final_state = "sideways"
    
    logger.info(f"Final market state determined: {final_state}")
    return final_state

def aggregate_market_analysis(technical_data: dict,
                              onchain_data: dict,
                              sentiment_texts: list,
                              ml_data: dict) -> str:
    """
    개별 분석 모듈에서 산출한 데이터를 입력받아 최종 시장 상태를 판단합니다.
    
    Parameters:
        technical_data (dict): {'price_series': pd.Series, 'rsi_window': int (선택)}
        onchain_data (dict): {'market_cap': float, 'realized_cap': float,
                              'exchange_inflow': float, 'exchange_outflow': float}
        sentiment_texts (list): 감성 분석 대상 텍스트 리스트.
        ml_data (dict): {'ml_model': MarketLSTMAnalyzer, 'ml_input': pd.DataFrame,
                          'current_price': float}
    
    Returns:
        str: 최종 시장 상태 ('bullish', 'bearish', 'sideways').
    """
    try:
        # 기술적 분석 신호 산출
        technical_signal = get_technical_signal(technical_data.get("price_series"),
                                                  technical_data.get("rsi_window", 14))
        
        # 온체인 분석 신호 산출
        onchain_signal = get_onchain_signal(onchain_data.get("market_cap"),
                                            onchain_data.get("realized_cap"),
                                            onchain_data.get("exchange_inflow"),
                                            onchain_data.get("exchange_outflow"))
        
        # 감성 분석 신호 산출
        sentiment_signal = get_sentiment_signal(sentiment_texts)
        
        # 머신러닝 분석 신호 산출
        ml_signal = get_ml_signal(ml_data.get("ml_model"),
                                  ml_data.get("ml_input"),
                                  ml_data.get("current_price"))
        
        # 최종 신호 종합
        final_state = determine_final_market_state(technical_signal,
                                                   onchain_signal,
                                                   sentiment_signal,
                                                   ml_signal)
        return final_state
    except Exception as e:
        logger.error(f"Error aggregating market analysis: {e}", exc_info=True)
        return "sideways"

---

# market_analysis/ml_market_analysis.py
from logs.log_config import setup_logger
import pandas as pd
import numpy as np
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
import tensorflow as tf

logger = setup_logger(__name__)

class MarketLSTMAnalyzer:
    """
    LSTM 모델을 활용한 머신러닝 기반 시장 분석 클래스입니다.
    
    Attributes:
        model (tf.keras.Model): LSTM 모델 객체.
        input_shape (tuple): (timesteps, features) 형태의 입력 데이터.
    """
    def __init__(self, input_shape: tuple):
        """
        초기화: LSTM 모델 구성 및 컴파일.
        
        Parameters:
            input_shape (tuple): (timesteps, features) 형태의 입력 데이터.
        """
        self.input_shape = input_shape
        self.model = self.build_model()
        logger.debug("MarketLSTMAnalyzer initialized.")
        
    def build_model(self) -> tf.keras.Model:
        """
        LSTM 모델을 구성하고 컴파일합니다.
        
        Returns:
            tf.keras.Model: 구성된 LSTM 모델.
        """
        model = Sequential()
        model.add(LSTM(50, return_sequences=True, input_shape=self.input_shape))
        model.add(Dropout(0.2))
        model.add(LSTM(50))
        model.add(Dropout(0.2))
        model.add(Dense(1, activation='linear'))
        model.compile(optimizer='adam', loss='mean_squared_error')
        logger.debug("LSTM model built and compiled.")
        return model
    
    def train(self, X_train: np.ndarray, y_train: np.ndarray, epochs: int = 50, batch_size: int = 32, validation_split: float = 0.2) -> None:
        """
        LSTM 모델을 주어진 데이터로 학습합니다.
        
        Parameters:
            X_train (np.ndarray): 학습 입력 데이터.
            y_train (np.ndarray): 학습 대상 데이터.
            epochs (int): 학습 에포크 수.
            batch_size (int): 배치 크기.
            validation_split (float): 검증 데이터 비율.
        
        Returns:
            None
        """
        try:
            early_stop = EarlyStopping(monitor='val_loss', patience=5)
            self.model.fit(
                X_train, y_train,
                epochs=epochs,
                batch_size=batch_size,
                validation_split=validation_split,
                callbacks=[early_stop],
                verbose=1
            )
            logger.debug("LSTM model training completed.")
        except Exception as e:
            logger.error(f"Error during LSTM training: {e}", exc_info=True)
            raise

    def predict(self, X: np.ndarray) -> np.ndarray:
        """
        주어진 입력 데이터에 대해 LSTM 모델의 예측을 수행합니다.
        
        Parameters:
            X (np.ndarray): 예측에 사용할 입력 데이터.
            
        Returns:
            np.ndarray: 예측 결과 배열.
        """
        try:
            predictions = self.model.predict(X)
            logger.debug(f"LSTM model prediction completed for {X.shape[0]} samples.")
            return predictions
        except Exception as e:
            logger.error(f"Error during LSTM prediction: {e}", exc_info=True)
            raise

---

# market_analysis/onchain_analysis.py
from logs.log_config import setup_logger
import pandas as pd
import numpy as np

logger = setup_logger(__name__)

def calculate_mvrv_ratio(market_cap: float, realized_cap: float) -> float:
    """
    온체인 분석을 위한 MVRV (Market Value to Realized Value) 비율을 계산합니다.
    
    Parameters:
        market_cap (float): 현재 시가총액.
        realized_cap (float): 실현 시가총액.
        
    Returns:
        float: MVRV 비율.
    """
    try:
        if realized_cap == 0:
            logger.error("Realized capitalization is zero, cannot compute MVRV ratio.")
            return float('inf')
        ratio = market_cap / realized_cap
        logger.debug(f"Calculated MVRV ratio: {ratio}")
        return ratio
    except Exception as e:
        logger.error(f"Error calculating MVRV ratio: {e}", exc_info=True)
        raise

def analyze_exchange_flow(exchange_inflow: float, exchange_outflow: float) -> str:
    """
    거래소의 유입 및 유출 데이터를 기반으로 매수/매도 신호를 판단합니다.
    
    Parameters:
        exchange_inflow (float): 거래소 유입량.
        exchange_outflow (float): 거래소 유출량.
        
    Returns:
        str: 'distribution' (매도 압력) 또는 'accumulation' (매수, 축적) 신호.
    """
    try:
        if exchange_inflow > exchange_outflow:
            signal = "distribution"
        else:
            signal = "accumulation"
        logger.debug(f"Exchange flow analysis: {signal} (inflow: {exchange_inflow}, outflow: {exchange_outflow})")
        return signal
    except Exception as e:
        logger.error(f"Error analyzing exchange flow: {e}", exc_info=True)
        raise

---

# market_analysis/sentiment_analysis.py
from logs.log_config import setup_logger
import re

logger = setup_logger(__name__)


def clean_text(text: str) -> str:
    """
    감성 분석을 위한 입력 텍스트를 정제합니다.
    
    Parameters:
        text (str): 원본 텍스트.
        
    Returns:
        str: 정제된 텍스트.
    """
    try:
        cleaned = re.sub(r'\s+', ' ', text)
        logger.debug("Text cleaned for sentiment analysis.")
        return cleaned.strip()
    except Exception as e:
        logger.error(f"Error cleaning text: {e}", exc_info=True)
        raise


def simple_sentiment_score(text: str) -> float:
    """
    키워드 매칭 방식을 사용하여 간단한 감성 점수를 계산합니다.
    
    Parameters:
        text (str): 입력 텍스트.
        
    Returns:
        float: -1 (매우 부정)에서 1 (매우 긍정) 사이의 감성 점수.
    """
    try:
        text = clean_text(text).lower()
        positive_words = ['good', 'bullish', 'up', 'positive', 'gain']
        negative_words = ['bad', 'bearish', 'down', 'negative', 'loss']
        
        score = 0
        for word in positive_words:
            score += text.count(word)
        for word in negative_words:
            score -= text.count(word)
        
        # 간단한 정규화 (기본 구현)
        normalized_score = max(min(score / 5.0, 1), -1)
        logger.debug(f"Computed sentiment score: {normalized_score} for text: {text}")
        return normalized_score
    except Exception as e:
        logger.error(f"Error computing sentiment score: {e}", exc_info=True)
        raise

def aggregate_sentiment(texts: list) -> float:
    """
    여러 텍스트의 감성 점수를 집계하여 평균 감성 점수를 계산합니다.
    
    Parameters:
        texts (list): 텍스트 문자열 리스트.
        
    Returns:
        float: 평균 감성 점수.
    """
    try:
        if not texts:
            logger.warning("No texts provided for sentiment aggregation.")
            return 0.0
        scores = [simple_sentiment_score(text) for text in texts]
        avg_score = sum(scores) / len(scores)
        logger.debug(f"Aggregated sentiment score: {avg_score}")
        return avg_score
    except Exception as e:
        logger.error(f"Error aggregating sentiment: {e}", exc_info=True)
        raise

---

# market_analysis/technical_analysis.py
from logs.log_config import setup_logger
import pandas as pd
import numpy as np

logger = setup_logger(__name__)

def compute_sma(data: pd.Series, window: int = 20) -> pd.Series:
    """
    주어진 시계열 데이터에 대해 단순 이동평균(SMA)을 계산합니다.
    
    Parameters:
        data (pd.Series): 가격 데이터.
        window (int): 이동평균 기간 (기본: 20).
        
    Returns:
        pd.Series: SMA 값 시리즈.
    """
    try:
        sma = data.rolling(window=window).mean()
        logger.debug(f"Computed SMA with window={window}.")
        return sma
    except Exception as e:
        logger.error(f"Error computing SMA: {e}", exc_info=True)
        raise

def compute_bollinger_bands(data: pd.Series, window: int = 20, num_std: int = 2) -> pd.DataFrame:
    """
    주어진 시계열 데이터에 대해 Bollinger Bands를 계산합니다.
    
    Parameters:
        data (pd.Series): 가격 데이터.
        window (int): 이동평균 기간.
        num_std (int): 표준편차 배수 (기본: 2).
        
    Returns:
        pd.DataFrame: 'SMA', 'Upper Band', 'Lower Band' 컬럼 포함 데이터프레임.
    """
    try:
        sma = compute_sma(data, window)
        std = data.rolling(window=window).std()
        upper_band = sma + (std * num_std)
        lower_band = sma - (std * num_std)
        logger.debug("Computed Bollinger Bands.")
        return pd.DataFrame({
            "SMA": sma,
            "Upper Band": upper_band,
            "Lower Band": lower_band
        })
    except Exception as e:
        logger.error(f"Error computing Bollinger Bands: {e}", exc_info=True)
        raise

def compute_rsi(data: pd.Series, window: int = 14) -> pd.Series:
    """
    주어진 시계열 데이터에 대해 RSI(Relative Strength Index)를 계산합니다.
    
    Parameters:
        data (pd.Series): 가격 데이터.
        window (int): RSI 계산 기간 (기본: 14).
        
    Returns:
        pd.Series: RSI 값 시리즈.
    """
    try:
        delta = data.diff()
        gain = delta.where(delta > 0, 0).rolling(window=window).mean()
        loss = -delta.where(delta < 0, 0).rolling(window=window).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        logger.debug("Computed RSI.")
        return rsi
    except Exception as e:
        logger.error(f"Error computing RSI: {e}", exc_info=True)
        raise
