[backtesting & param]
# backtesting/backtester.py
import pandas as pd
import numpy as np
from logs.logger_config import setup_logger

from trading.risk import (
    compute_position_size, allocate_position_splits, attempt_scale_in_position, 
    compute_risk_parameters_by_regime
)
from trading.trade_management import (
    calculate_partial_exit_targets, adjust_trailing_stop, compute_atr, calculate_dynamic_stop_and_take
)
from dynamic_parameters.dynamic_param_manager import DynamicParamManager
from data_collection.db_manager import fetch_ohlcv_records
from trading.positions import TradePosition

# HMM 및 보조 지표 레짐 판단 모듈 임포트
from markets_analysis.hmm_model import MarketRegimeHMM
from markets_analysis.regime_filter import filter_by_confidence

# 전략 선택 함수 (최종 액션은 backtester에서 세부 로직 구현)
from trading.strategies import select_strategy

class Backtester:
    def __init__(self, symbol="BTC/USDT", account_size=10000.0, fee_rate=0.001, slippage_rate=0.0005, final_exit_slippage=0.0):
        self.symbol = symbol
        self.account_size = account_size
        self.fee_rate = fee_rate
        self.slippage_rate = slippage_rate
        self.final_exit_slippage = final_exit_slippage
        self.positions = []
        self.trades = []
        self.trade_logs = []
        self.logger = setup_logger("backtester")
        self.dynamic_param_manager = DynamicParamManager()

    def load_data(self, short_table_format, long_table_format, short_tf, long_tf, start_date=None, end_date=None):
        symbol_for_table = self.symbol.replace('/', '').lower()
        short_table = short_table_format.format(symbol=symbol_for_table, timeframe=short_tf)
        long_table = long_table_format.format(symbol=symbol_for_table, timeframe=long_tf)
        self.df_short = fetch_ohlcv_records(short_table, start_date, end_date)
        self.df_long = fetch_ohlcv_records(long_table, start_date, end_date)
        if self.df_short.empty or self.df_long.empty:
            self.logger.error("데이터 로드 실패: 데이터가 비어있습니다.")
            raise ValueError("No data loaded")
        self.df_short.sort_index(inplace=True)
        self.df_long.sort_index(inplace=True)
    
    def run_backtest(self, dynamic_params=None):
        if dynamic_params is None:
            dynamic_params = self.dynamic_param_manager.get_default_params()
        
        # === 시장 레짐 판단 (HMM 기반 및 보조 지표 적용) ===
        self.df_long['returns'] = self.df_long['close'].pct_change().fillna(0)
        self.df_long['volatility'] = self.df_long['returns'].rolling(window=20).std().fillna(0)
        
        hmm = MarketRegimeHMM(n_components=3)
        hmm.train(self.df_long, feature_columns=['returns', 'volatility'])
        regime_predictions = hmm.predict(self.df_long, feature_columns=['returns', 'volatility'])
        confidence_flags = filter_by_confidence(hmm, self.df_long, feature_columns=['returns', 'volatility'], 
                                                  threshold=dynamic_params.get('hmm_confidence_threshold', 0.8))
        
        sma_period = dynamic_params.get('sma_period', 200)
        self.df_long['long_term_sma'] = self.df_long['close'].rolling(window=sma_period, min_periods=1).mean()
        
        regime_map = {0: "bullish", 1: "bearish", 2: "sideways"}
        adjusted_regimes = []
        for idx, (pred, conf) in enumerate(zip(regime_predictions, confidence_flags)):
            if not conf:
                # HMM 신뢰도가 낮으면 보조 지표(SMA)를 사용하여 레짐 판단
                regime = "bullish" if self.df_long['close'].iloc[idx] > self.df_long['long_term_sma'].iloc[idx] else "bearish"
            else:
                regime = regime_map.get(pred, "unknown")
            adjusted_regimes.append(regime)
        
        regime_series = pd.Series(adjusted_regimes, index=self.df_long.index)
        self.df_short['market_regime'] = regime_series.reindex(self.df_short.index, method='ffill')
        
        # ATR 계산: short 데이터에 ATR 컬럼 추가 (atr_period는 dynamic_params에서 가져옴)
        self.df_short = compute_atr(self.df_short, period=dynamic_params.get("atr_period", 14))
        
        # === 레짐별 동적 리스크 파라미터 계산 ===
        base_risk_params = {
            "risk_per_trade": dynamic_params.get("risk_per_trade", 0.01),
            "atr_multiplier": dynamic_params.get("atr_multiplier", 2.0),
            "profit_ratio": dynamic_params.get("profit_ratio", 0.05)
        }
        
        # === 메인 백테스트 루프: 각 시점에서 레짐에 따른 전략 실행 ===
        for current_time, row in self.df_short.iterrows():
            market_regime = row['market_regime']
            risk_params = compute_risk_parameters_by_regime(
                base_risk_params,
                regime=market_regime,
                liquidity=dynamic_params.get('liquidity_info', 'high')
            )
            close_price = row["close"]
            
            # 전략 선택: 레짐 및 유동성 정보를 기반으로 결정
            action = select_strategy(
                market_regime=market_regime,
                liquidity_info=dynamic_params.get('liquidity_info', 'high'),
                data=self.df_short.loc[:current_time],
                current_time=current_time
            )
            
            if market_regime == "bullish" or action == "enter_long":
                # 롱 포지션 진입 및 스케일‑인 전략
                scaled_in = False
                for pos in self.positions:
                    if pos.side == "LONG":
                        attempt_scale_in_position(
                            position=pos,
                            current_price=close_price,
                            scale_in_threshold=dynamic_params.get("scale_in_threshold", 0.02),
                            slippage_rate=self.slippage_rate,
                            stop_loss=row.get("stop_loss_price"),
                            take_profit=row.get("take_profit_price"),
                            entry_time=current_time,
                            trade_type="scale_in"
                        )
                        scaled_in = True
                if not scaled_in:
                    new_position = TradePosition(
                        side="LONG",
                        initial_price=close_price,
                        maximum_size=0.0,
                        total_splits=dynamic_params.get("total_splits", 3),
                        allocation_plan=[]
                    )
                    new_position.highest_price = close_price
                    
                    # 동적 stop_loss, take_profit 계산
                    # 현재 진입가를 close_price로 가정하고, 해당 시점의 ATR 값을 가져옵니다.
                    entry_price = close_price
                    try:
                        atr_value = self.df_short.loc[current_time, "atr"]
                    except KeyError:
                        atr_value = 0  # 기본값 (예: 0) – 필요 시 추가 조치 가능
                    stop_loss_price, take_profit_price = calculate_dynamic_stop_and_take(entry_price, atr_value, risk_params)
                    
                    total_size = compute_position_size(
                        account_balance=self.account_size,
                        risk_percentage=risk_params["risk_per_trade"],
                        entry_price=close_price,
                        stop_loss=stop_loss_price,  # 동적 계산 값 사용
                        fee_rate=self.fee_rate
                    )
                    new_position.maximum_size = total_size
                    plan = allocate_position_splits(
                        total_size=1.0,
                        splits_count=dynamic_params.get("total_splits", 3),
                        allocation_mode=dynamic_params.get("allocation_mode", "equal")
                    )
                    new_position.allocation_plan = plan
                    exit_targets = calculate_partial_exit_targets(
                        entry_price=close_price,
                        partial_exit_ratio=dynamic_params.get("partial_exit_ratio", 0.5),
                        partial_profit_ratio=dynamic_params.get("partial_profit_ratio", 0.03),
                        final_profit_ratio=dynamic_params.get("final_profit_ratio", 0.06)
                    )
                    executed_price = close_price * (1 + self.slippage_rate)
                    new_position.add_execution(
                        entry_price=executed_price,
                        size=total_size * plan[0],
                        stop_loss=stop_loss_price,      # 동적 계산 값 사용
                        take_profit=take_profit_price,  # 동적 계산 값 사용
                        entry_time=current_time,
                        exit_targets=exit_targets,
                        trade_type="new_entry"
                    )
                    new_position.executed_splits = 1
                    self.positions.append(new_position)
            
            elif market_regime == "bearish" or action == "exit_all":
                # 베어리시 레짐: 전체 포지션 청산
                for pos in self.positions[:]:
                    for exec_record in pos.executions:
                        if not exec_record.get("closed", False):
                            exit_price = close_price * (1 - self.slippage_rate)
                            fee = exit_price * exec_record["size"] * self.fee_rate
                            pnl = (exit_price - exec_record["entry_price"]) * exec_record["size"] - fee
                            exec_record["closed"] = True
                            trade_detail = {
                                "entry_time": exec_record["entry_time"],
                                "entry_price": exec_record["entry_price"],
                                "exit_time": current_time,
                                "exit_price": exit_price,
                                "size": exec_record["size"],
                                "pnl": pnl,
                                "reason": "exit_regime_change",
                                "trade_type": exec_record.get("trade_type", "unknown"),
                                "position_id": pos.position_id
                            }
                            self.trade_logs.append(trade_detail)
                            self.trades.append(trade_detail)
                    if pos.is_empty():
                        self.positions.remove(pos)
            
            elif market_regime == "sideways":
                # 횡보장: 유동성에 따라 범위 트레이딩 또는 평균 회귀 전략 선택
                liquidity = dynamic_params.get('liquidity_info', 'high').lower()
                if liquidity == "high":
                    lower_bound = self.df_short['low'].rolling(window=20, min_periods=1).min().iloc[-1]
                    upper_bound = self.df_short['high'].rolling(window=20, min_periods=1).max().iloc[-1]
                    if close_price <= lower_bound:
                        self.logger.info(f"{current_time} - Range Trade 진입 (하단 터치): {close_price}")
                        scaled_in = False
                        for pos in self.positions:
                            if pos.side == "LONG":
                                attempt_scale_in_position(
                                    position=pos,
                                    current_price=close_price,
                                    scale_in_threshold=dynamic_params.get("scale_in_threshold", 0.02),
                                    slippage_rate=self.slippage_rate,
                                    stop_loss=row.get("stop_loss_price"),
                                    take_profit=row.get("take_profit_price"),
                                    entry_time=current_time,
                                    trade_type="range_trade_scale_in"
                                )
                                scaled_in = True
                        if not scaled_in:
                            new_position = TradePosition(
                                side="LONG",
                                initial_price=close_price,
                                maximum_size=0.0,
                                total_splits=dynamic_params.get("total_splits", 3),
                                allocation_plan=[]
                            )
                            new_position.highest_price = close_price
                            total_size = compute_position_size(
                                account_balance=self.account_size,
                                risk_percentage=risk_params["risk_per_trade"],
                                entry_price=close_price,
                                stop_loss=row.get("stop_loss_price"),
                                fee_rate=self.fee_rate
                            )
                            new_position.maximum_size = total_size
                            plan = allocate_position_splits(
                                total_size=1.0,
                                splits_count=dynamic_params.get("total_splits", 3),
                                allocation_mode=dynamic_params.get("allocation_mode", "equal")
                            )
                            new_position.allocation_plan = plan
                            exit_targets = calculate_partial_exit_targets(
                                entry_price=close_price,
                                partial_exit_ratio=dynamic_params.get("partial_exit_ratio", 0.5),
                                partial_profit_ratio=dynamic_params.get("partial_profit_ratio", 0.03),
                                final_profit_ratio=dynamic_params.get("final_profit_ratio", 0.06)
                            )
                            executed_price = close_price * (1 + self.slippage_rate)
                            new_position.add_execution(
                                entry_price=executed_price,
                                size=total_size * plan[0],
                                stop_loss=row.get("stop_loss_price"),
                                take_profit=row.get("take_profit_price"),
                                entry_time=current_time,
                                exit_targets=exit_targets,
                                trade_type="range_trade_entry"
                            )
                            new_position.executed_splits = 1
                            self.positions.append(new_position)
                    elif close_price >= upper_bound:
                        self.logger.info(f"{current_time} - Range Trade 청산 (상단 터치): {close_price}")
                        for pos in self.positions:
                            if pos.side == "LONG":
                                for i, exec_record in enumerate(pos.executions):
                                    if not exec_record.get("closed", False) and "exit_targets" in exec_record:
                                        for target in exec_record["exit_targets"]:
                                            if not target.get("hit", False) and close_price >= target["price"]:
                                                target["hit"] = True
                                                closed_qty = pos.partial_close_execution(i, target["exit_ratio"])
                                                fee = close_price * closed_qty * self.fee_rate
                                                pnl = (close_price - exec_record["entry_price"]) * closed_qty - fee
                                                trade_detail = {
                                                    "entry_time": exec_record["entry_time"],
                                                    "entry_price": exec_record["entry_price"],
                                                    "exit_time": current_time,
                                                    "exit_price": close_price,
                                                    "size": closed_qty,
                                                    "pnl": pnl,
                                                    "reason": "range_trade_partial_exit",
                                                    "trade_type": exec_record.get("trade_type", "unknown"),
                                                    "position_id": pos.position_id
                                                }
                                                self.trade_logs.append(trade_detail)
                                                self.trades.append(trade_detail)
                                                break
                else:
                    mean_price = self.df_short['close'].rolling(window=20, min_periods=1).mean().iloc[-1]
                    std_price = self.df_short['close'].rolling(window=20, min_periods=1).std().iloc[-1]
                    if close_price < mean_price - std_price:
                        self.logger.info(f"{current_time} - Mean Reversion 진입 (가격 저평가): {close_price}")
                        scaled_in = False
                        for pos in self.positions:
                            if pos.side == "LONG":
                                attempt_scale_in_position(
                                    position=pos,
                                    current_price=close_price,
                                    scale_in_threshold=dynamic_params.get("scale_in_threshold", 0.02),
                                    slippage_rate=self.slippage_rate,
                                    stop_loss=row.get("stop_loss_price"),
                                    take_profit=row.get("take_profit_price"),
                                    entry_time=current_time,
                                    trade_type="mean_reversion_scale_in"
                                )
                                scaled_in = True
                        if not scaled_in:
                            new_position = TradePosition(
                                side="LONG",
                                initial_price=close_price,
                                maximum_size=0.0,
                                total_splits=dynamic_params.get("total_splits", 3),
                                allocation_plan=[]
                            )
                            new_position.highest_price = close_price
                            total_size = compute_position_size(
                                account_balance=self.account_size,
                                risk_percentage=risk_params["risk_per_trade"],
                                entry_price=close_price,
                                stop_loss=row.get("stop_loss_price"),
                                fee_rate=self.fee_rate
                            )
                            new_position.maximum_size = total_size
                            plan = allocate_position_splits(
                                total_size=1.0,
                                splits_count=dynamic_params.get("total_splits", 3),
                                allocation_mode=dynamic_params.get("allocation_mode", "equal")
                            )
                            new_position.allocation_plan = plan
                            exit_targets = calculate_partial_exit_targets(
                                entry_price=close_price,
                                partial_exit_ratio=dynamic_params.get("partial_exit_ratio", 0.5),
                                partial_profit_ratio=dynamic_params.get("partial_profit_ratio", 0.03),
                                final_profit_ratio=dynamic_params.get("final_profit_ratio", 0.06)
                            )
                            executed_price = close_price * (1 + self.slippage_rate)
                            new_position.add_execution(
                                entry_price=executed_price,
                                size=total_size * plan[0],
                                stop_loss=row.get("stop_loss_price"),
                                take_profit=row.get("take_profit_price"),
                                entry_time=current_time,
                                exit_targets=exit_targets,
                                trade_type="mean_reversion_entry"
                            )
                            new_position.executed_splits = 1
                            self.positions.append(new_position)
                    elif close_price > mean_price + std_price:
                        self.logger.info(f"{current_time} - Mean Reversion 청산 (가격 고평가): {close_price}")
                        for pos in self.positions:
                            if pos.side == "LONG":
                                for i, exec_record in enumerate(pos.executions):
                                    if not exec_record.get("closed", False) and "exit_targets" in exec_record:
                                        for target in exec_record["exit_targets"]:
                                            if not target.get("hit", False) and close_price >= target["price"]:
                                                target["hit"] = True
                                                closed_qty = pos.partial_close_execution(i, target["exit_ratio"])
                                                fee = close_price * closed_qty * self.fee_rate
                                                pnl = (close_price - exec_record["entry_price"]) * closed_qty - fee
                                                trade_detail = {
                                                    "entry_time": exec_record["entry_time"],
                                                    "entry_price": exec_record["entry_price"],
                                                    "exit_time": current_time,
                                                    "exit_price": close_price,
                                                    "size": closed_qty,
                                                    "pnl": pnl,
                                                    "reason": "mean_reversion_partial_exit",
                                                    "trade_type": exec_record.get("trade_type", "unknown"),
                                                    "position_id": pos.position_id
                                                }
                                                self.trade_logs.append(trade_detail)
                                                self.trades.append(trade_detail)
                                                break

            # === 공통: 보유 포지션에 대해 트레일링 스탑 등 리스크 관리 업데이트 ===
            for pos in self.positions:
                for exec_record in pos.executions:
                    if not exec_record.get("closed", False):
                        pos.highest_price = max(pos.highest_price, close_price)
                        new_stop = adjust_trailing_stop(
                            current_stop=row.get("stop_loss_price", 0),
                            current_price=close_price,
                            highest_price=pos.highest_price,
                            trailing_percentage=dynamic_params.get("trailing_percent", 0.045)
                        )
                        exec_record["stop_loss"] = new_stop

        # === 최종 미청산 포지션 강제 청산 ===
        final_time = self.df_short.index[-1]
        final_close = self.df_short.iloc[-1]["close"]
        adjusted_final_close = final_close * (1 - self.final_exit_slippage) if self.final_exit_slippage else final_close
        for pos in self.positions:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    exit_price = adjusted_final_close * (1 - self.slippage_rate)
                    fee = exit_price * exec_record["size"] * self.fee_rate
                    pnl = (exit_price - exec_record["entry_price"]) * exec_record["size"] - fee
                    exec_record["closed"] = True
                    trade_detail = {
                        "entry_time": exec_record["entry_time"],
                        "entry_price": exec_record["entry_price"],
                        "exit_time": final_time,
                        "exit_price": exit_price,
                        "size": exec_record["size"],
                        "pnl": pnl,
                        "reason": "final_exit",
                        "trade_type": exec_record.get("trade_type", "unknown"),
                        "position_id": pos.position_id
                    }
                    self.trade_logs.append(trade_detail)
                    self.trades.append(trade_detail)
        return self.trades, self.trade_logs

---

# backtesting/optimizer.py
import optuna
import pandas as pd
from logs.logger_config import setup_logger
from backtesting.backtester import Backtester
from dynamic_parameters.dynamic_param_manager import DynamicParamManager

logger = setup_logger(__name__)

class DynamicParameterOptimizer:
    def __init__(self, n_trials=50):
        self.n_trials = n_trials
        self.study = None
        self.dynamic_param_manager = DynamicParamManager()
    
    def objective(self, trial):
        # 기본 파라미터 가져오기 및 최적화 대상 파라미터 제안 (불필요한 추세 관련 파라미터 제거)
        base_params = self.dynamic_param_manager.get_default_params()
        params = {
            "hmm_confidence_threshold": trial.suggest_float("hmm_confidence_threshold", 0.7, 0.95),
            "liquidity_info": trial.suggest_categorical("liquidity_info", ["high", "low"]),
            "atr_multiplier": trial.suggest_float("atr_multiplier", 1.5, 3.0),
            "profit_ratio": trial.suggest_float("profit_ratio", 0.05, 0.15),
            "risk_per_trade": trial.suggest_float("risk_per_trade", 0.005, 0.02),
            "scale_in_threshold": trial.suggest_float("scale_in_threshold", 0.01, 0.03),
            "partial_exit_ratio": trial.suggest_float("partial_exit_ratio", 0.4, 0.6),
            "partial_profit_ratio": trial.suggest_float("partial_profit_ratio", 0.02, 0.04),
            "final_profit_ratio": trial.suggest_float("final_profit_ratio", 0.05, 0.1)
        }
        # 최종 동적 파라미터
        dynamic_params = {**base_params, **params}
        
        # Walk-Forward 구간 정의
        splits = [
            {"train_start": "2018-06-01", "train_end": "2020-12-31", "test_start": "2021-01-01", "test_end": "2021-12-31"},
            {"train_start": "2019-06-01", "train_end": "2021-12-31", "test_start": "2022-01-01", "test_end": "2022-12-31"},
            {"train_start": "2020-06-01", "train_end": "2022-12-31", "test_start": "2023-01-01", "test_end": "2023-12-31"},
            {"train_start": "2021-06-01", "train_end": "2023-12-31", "test_start": "2024-01-01", "test_end": "2024-12-31"},
            {"train_start": "2022-06-01", "train_end": "2024-12-31", "test_start": "2025-01-01", "test_end": "2025-02-01"},
        ]
        
        total_score = 0.0
        for split in splits:
            # 학습 구간 백테스트
            backtester = Backtester(symbol="BTC/USDT", account_size=10000)
            backtester.load_data(
                "ohlcv_{symbol}_{timeframe}",
                "ohlcv_{symbol}_{timeframe}",
                "4h", "1d",
                split["train_start"], split["train_end"]
            )
            try:
                trades_train, _ = backtester.run_backtest(dynamic_params)
            except Exception as e:
                logger.error(f"Training backtest failed: {e}")
                return 1e6
            total_pnl_train = sum(trade["pnl"] for trade in trades_train)
            roi_train = total_pnl_train / 10000 * 100

            # 테스트 구간 백테스트
            backtester.load_data(
                "ohlcv_{symbol}_{timeframe}",
                "ohlcv_{symbol}_{timeframe}",
                "4h", "1d",
                split["test_start"], split["test_end"]
            )
            try:
                trades_test, _ = backtester.run_backtest(dynamic_params)
            except Exception as e:
                logger.error(f"Test backtest failed: {e}")
                return 1e6
            total_pnl_test = sum(trade["pnl"] for trade in trades_test)
            roi_test = total_pnl_test / 10000 * 100

            # 과적합 패널티 및 점수 산출: 테스트 ROI와 학습 ROI의 차이를 고려
            overfit_penalty = abs(roi_train - roi_test)
            score = -roi_test + 0.5 * overfit_penalty
            total_score += score

        avg_score = total_score / len(splits)
        return avg_score

    def optimize(self):
        sampler = optuna.samplers.TPESampler(seed=42)
        self.study = optuna.create_study(direction="minimize", sampler=sampler)
        self.study.optimize(self.objective, n_trials=self.n_trials)
        
        trials_df = self.study.trials_dataframe()
        logger.info("Trial 결과:\n" + trials_df.to_string())
        
        return self.study.best_trial

---

# backtesting/performance.py
import pandas as pd
import numpy as np

def calculate_monthly_performance(
    trades_df: pd.DataFrame,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl",
    period_freq: str = 'M',
    period_col: str = "year_month"
) -> pd.DataFrame:
    if exit_time_col not in trades_df.columns:
        return pd.DataFrame()
    trades_df[period_col] = trades_df[exit_time_col].dt.to_period(period_freq)
    grouped = trades_df.groupby(period_col)
    results = []
    for period_val, grp in grouped:
        total_pnl = grp[pnl_col].sum()
        num_trades = len(grp)
        win_trades = (grp[pnl_col] > 0).sum()
        win_rate = (win_trades / num_trades * 100.0) if num_trades > 0 else 0.0
        results.append({
            period_col: str(period_val),
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })
    return pd.DataFrame(results)

def calculate_yearly_performance(
    trades_df: pd.DataFrame,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl",
    year_col: str = "year"
) -> pd.DataFrame:
    if exit_time_col not in trades_df.columns:
        return pd.DataFrame()
    trades_df[year_col] = trades_df[exit_time_col].dt.year
    grouped = trades_df.groupby(year_col)
    results = []
    for yr, grp in grouped:
        total_pnl = grp[pnl_col].sum()
        num_trades = len(grp)
        win_trades = (grp[pnl_col] > 0).sum()
        win_rate = (win_trades / num_trades * 100.0) if num_trades > 0 else 0.0
        results.append({
            year_col: yr,
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })
    return pd.DataFrame(results)

def calculate_mdd(
    trades_df: pd.DataFrame,
    initial_balance: float,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl",
    mdd_factor: float = 100.0
) -> float:
    if exit_time_col not in trades_df.columns:
        return 0.0
    trades_df = trades_df.sort_values(by=exit_time_col)
    equity_list = []
    current_balance = initial_balance
    for _, row in trades_df.iterrows():
        current_balance += row[pnl_col]
        equity_list.append(current_balance)
    equity_arr = np.array(equity_list)
    peak_arr = np.maximum.accumulate(equity_arr)
    drawdown_arr = (equity_arr - peak_arr) / peak_arr
    mdd = drawdown_arr.min() * mdd_factor
    return mdd

def calculate_sharpe_ratio(
    trades_df: pd.DataFrame,
    initial_balance: float,
    risk_free_rate: float = 0.0,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl"
) -> float:
    if trades_df.empty or len(trades_df) < 2:
        return 0.0
    trades_df = trades_df.sort_values(by=exit_time_col)
    current_balance = initial_balance
    returns_list = []
    for _, row in trades_df.iterrows():
        pnl = row[pnl_col]
        ret = pnl / current_balance
        returns_list.append(ret)
        current_balance += pnl
    returns_arr = np.array(returns_list)
    if len(returns_arr) < 2:
        return 0.0
    mean_return = returns_arr.mean()
    std_return = returns_arr.std(ddof=1)
    if std_return == 0:
        return 0.0
    sharpe = (mean_return - risk_free_rate) / std_return
    return sharpe

def print_performance_report(
    trades_df: pd.DataFrame,
    initial_balance: float,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl",
    monthly_header: str = "=== (A) 월별 성과 ===",
    yearly_header: str = "=== (B) 연도별 성과 ===",
    overall_header: str = "=== (C) 전체 성과 ===",
    no_trades_message: str = "No trades to report."
) -> None:
    if trades_df.empty:
        print(no_trades_message)
        return
    monthly_df = calculate_monthly_performance(trades_df, exit_time_col, pnl_col)
    yearly_df = calculate_yearly_performance(trades_df, exit_time_col, pnl_col)
    total_pnl = trades_df[pnl_col].sum()
    final_balance = initial_balance + total_pnl
    mdd = calculate_mdd(trades_df, initial_balance=initial_balance, exit_time_col=exit_time_col, pnl_col=pnl_col)
    sharpe = calculate_sharpe_ratio(trades_df, initial_balance=initial_balance, exit_time_col=exit_time_col, pnl_col=pnl_col)
    print(monthly_header)
    print(monthly_df)
    print("\n" + yearly_header)
    print(yearly_df)
    print("\n" + overall_header)
    print(f"  - 초기 잔고       : {initial_balance:.2f}")
    print(f"  - 최종 잔고       : {final_balance:.2f}")
    print(f"  - 총 손익         : {total_pnl:.2f}")
    print(f"  - ROI(%)          : {(final_balance - initial_balance) / initial_balance * 100:.2f}%")
    print(f"  - 최대낙폭(MDD)   : {mdd:.2f}%")
    print(f"  - 샤프 지수(단순) : {sharpe:.3f}")
    num_trades = len(trades_df)
    wins = (trades_df[pnl_col] > 0).sum()
    win_rate = (wins / num_trades * 100.0) if num_trades > 0 else 0.0
    print(f"  - 총 매매 횟수    : {num_trades}")
    print(f"  - 승률(%)         : {win_rate:.2f}%")

---

# dynamic_parameters/dynamic_param_manager.py
from logs.logger_config import setup_logger

class DynamicParamManager:
    def __init__(self):
        # 기본 동적 파라미터: 불필요한 추세 관련 파라미터 제거 및 레짐 기반 파라미터 추가
        self.default_params = {
            "sma_period": 200,
            "atr_period": 14,
            "atr_multiplier": 2.07,
            "dynamic_sl_adjustment": 1.18,
            "profit_ratio": 0.098,
            "use_trailing_stop": True,
            "trailing_percent": 0.045,
            "partial_exit_ratio": 0.5,
            "partial_profit_ratio": 0.03,
            "final_profit_ratio": 0.06,
            "risk_per_trade": 0.0162,
            "total_splits": 3,
            "allocation_mode": "equal",
            "scale_in_threshold": 0.0153,
            "hmm_confidence_threshold": 0.8,
            "liquidity_info": "high"
        }

        self.logger = setup_logger(__name__)
        self.logger.info("DynamicParamManager 초기화 완료 (레짐 기반 전략 적용).")

    def get_default_params(self):
        return self.default_params.copy()
    
    def update_dynamic_params(self, market_data):
        dynamic_params = self.get_default_params()
        volatility = market_data.get("volatility", 0.0)
        
        if volatility > 0.05:
            dynamic_params["atr_multiplier"] *= 1.1
        else:
            dynamic_params["atr_multiplier"] *= 0.9
        
        # 기존 trend_strength 기반 조정 로직은 제거됨 (레짐 기반 전략 적용)
        self.logger.info(f"Market data: {market_data}")
        self.logger.info(f"Updated dynamic parameters: {dynamic_params}")
        
        return dynamic_params
