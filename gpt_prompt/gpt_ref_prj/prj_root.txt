[prj_root]
".env"
# Database 설정
DB_USER=postgres
DB_PASSWORD=1234
DB_HOST=localhost
DB_PORT=5432
DB_NAME=my_trading_db

# 로깅 관련 설정
ENVIRONMENT=development
LOG_LEVEL=INFO
LOG_DETAIL_LEVEL=DEBUG

# AggregatingHandler 임계치 설정 (전역)
AGG_THRESHOLD_GLOBAL=5000

# 모듈별 AggregatingHandler 임계치 설정
# [백테스팅 관련]
AGG_THRESHOLD_BACKTESTER=5000
AGG_THRESHOLD_PERFORMANCE=5000

# [DB 관련]
AGG_THRESHOLD_DB_MANAGER=5000

# [보고서 관련]
AGG_THRESHOLD_FINAL_REPORT=5000

# [전략 튜닝 관련]
AGG_THRESHOLD_OPTIMIZER=5000
AGG_THRESHOLD_DYNAMIC_PARAM_MANAGER=5000
AGG_THRESHOLD_PARAMETER_ANALYSIS=5000

# [전략 관련]
AGG_THRESHOLD_ACCOUNT=5000
AGG_THRESHOLD_ASSET_MANAGER=5000
AGG_THRESHOLD_ENSEMBLE_MANAGER=5000
AGG_THRESHOLD_POSITIONS=5000
AGG_THRESHOLD_RISK_MANAGER=5000
AGG_THRESHOLD_STRATEGIES=5000
AGG_THRESHOLD_TRADE_MANAGER=5000

# [데이터 수집 관련]
AGG_THRESHOLD_OHLCV_AGGREGATOR=5000
AGG_THRESHOLD_OHLCV_FETCHER=5000
AGG_THRESHOLD_OHLCV_PIPELINE=5000

# [로그 관련]
AGG_THRESHOLD_AGGREGATING_HANDLER=5000
AGG_THRESHOLD_LOGGER_CONFIG=5000
AGG_THRESHOLD_LOGGING_UTIL=5000

# [마켓 분석 관련]
AGG_THRESHOLD_HMM_MODEL=5000
AGG_THRESHOLD_REGIME_FILTER=5000

# [실행 파일 관련]
AGG_THRESHOLD_RUN_PARAMETER_ANALYSIS=5000
AGG_THRESHOLD_RUN_STRATEGY_PERFORMANCE=5000

# 민감도 분석 실행 시 상세 로그 집계를 위한 민감도 임계치
AGG_THRESHOLD_SENSITIVITY=5000

---

"requirements.txt"
pandas
numpy
SQLAlchemy
psycopg2-binary
optuna
ta
ccxt
hmmlearn
python-dotenv
pytest

---

# run_parameter_analysis.py
import argparse
import logging
import numpy as np
from logs.logger_config import setup_logger
from logs.logging_util import LoggingUtil
from strategy_tuning.parameter_analysis import run_sensitivity_analysis
from logs.final_report import generate_parameter_sensitivity_report

logger = setup_logger(__name__)

def parse_args():
    parser = argparse.ArgumentParser(
        description="Run parameter sensitivity analysis for trading strategies."
    )
    # 다중 파라미터 분석용 인자 (기본값 지정)
    parser.add_argument("--param_names", type=str, 
                        default="profit_ratio,atr_multiplier,risk_per_trade,scale_in_threshold,weekly_breakout_threshold,weekly_momentum_threshold",
                        help="Comma-separated list of parameter names to analyze. Multi-parameter mode is activated.")
    parser.add_argument("--param_steps", type=int, default=10, 
                        help="Number of steps for each parameter (default: 10)")
    parser.add_argument("--assets", type=str, default="BTC/USDT", 
                        help="Comma-separated list of assets (default: BTC/USDT)")
    parser.add_argument("--short_tf", type=str, default="4h", 
                        help="Short time frame (default: 4h)")
    parser.add_argument("--long_tf", type=str, default="1d", 
                        help="Long time frame (default: 1d)")
    parser.add_argument("--start_date", type=str, default="2018-06-01", 
                        help="Start date for data")
    parser.add_argument("--end_date", type=str, default="2020-12-31", 
                        help="End date for data")
    parser.add_argument("--periods", type=str, default="", 
                        help="Optional multiple periods in format start1:end1;start2:end2, etc.")
    # sample_rate 인자는 더 이상 사용하지 않습니다.
    return parser.parse_args()

def parse_assets(asset_str):
    return [asset.strip() for asset in asset_str.split(",") if asset.strip()]

def parse_periods(periods_str, default_start, default_end):
    if not periods_str:
        return [(default_start, default_end)]
    period_list = []
    for pair in periods_str.split(";"):
        if pair:
            try:
                s, e = pair.split(":")
                period_list.append((s.strip(), e.strip()))
            except Exception as e:
                logger.error(f"Error parsing period pair '{pair}': {e}", exc_info=True)
    if not period_list:
        period_list = [(default_start, default_end)]
    return period_list

def run_parameter_analysis():
    # 1. 기존 로그 핸들러 종료 및 로그 파일 삭제
    logging.shutdown()
    LoggingUtil.clear_log_files()

    # 2. 인자 파싱
    args = parse_args()
    logger = setup_logger(__name__)
    logger.info("Starting parameter sensitivity analysis with external configuration.")

    assets = parse_assets(args.assets)
    periods = parse_periods(args.periods, args.start_date, args.end_date)

    # 다중 파라미터 분석: --param_names 인자를 기반으로 분석할 파라미터와 그 범위를 dict로 구성합니다.
    from strategy_tuning.dynamic_param_manager import DynamicParamManager
    dpm = DynamicParamManager()
    defaults = dpm.get_default_params()
    param_names = [p.strip() for p in args.param_names.split(",") if p.strip()]
    param_settings = {}
    for pname in param_names:
        if pname not in defaults:
            logger.warning(f"Parameter {pname} not found in default parameters. Skipping.")
            continue
        try:
            default_val = float(defaults[pname])
        except Exception as e:
            logger.warning(f"Parameter {pname} is not numeric. Skipping.")
            continue
        # 기본값의 ±20% 범위로 분석 (필요에 따라 조정 가능)
        start_val = default_val * 0.8
        end_val = default_val * 1.2
        param_values = np.linspace(start_val, end_val, args.param_steps)
        logger.info(f"Analyzing parameter {pname} with range {start_val:.4f} to {end_val:.4f} in {args.param_steps} steps.")
        param_settings[pname] = param_values

    # 3. 민감도 분석 실행 (다중 파라미터 모드)
    results_all = run_sensitivity_analysis(param_settings, assets, args.short_tf, args.long_tf, args.start_date, args.end_date, periods)

    # 4. 최종 결과 리포트 생성: 다중 파라미터 분석 결과 리포트를 생성합니다.
    report_title = "Multi-Parameter Analysis: " + ", ".join(results_all.keys())
    generate_parameter_sensitivity_report(report_title, results_all)

if __name__ == "__main__":
    run_parameter_analysis()

---

# run_strategy_performance.py
import logging
from logs.logger_config import setup_logger
from logs.logging_util import LoggingUtil
from strategy_tuning.optimizer import DynamicParameterOptimizer
from backtesting.backtester import Backtester
from backtesting.performance import compute_performance
from logs.final_report import generate_final_report
from strategy_tuning.dynamic_param_manager import DynamicParamManager

def run_strategy_performance():
    # 1. 기존 로그 핸들러 종료 및 글로벌 핸들러 초기화
    logging.shutdown()

    # 2. logs 폴더의 모든 로그 파일 삭제 (LoggingUtil의 정적 메서드 사용)
    LoggingUtil.clear_log_files()

    logger = setup_logger(__name__)
    logger.info("프로젝트 전체 테스트 실행을 시작합니다.")
    
    # 3. 파라미터 최적화 (Walk-Forward 방식)
    logger.info("Walk-Forward 방식의 파라미터 최적화를 시작합니다...")
    optimizer = DynamicParameterOptimizer(n_trials=10)
    best_trial = optimizer.optimize()
    
    # 4. 기본 파라미터와 최적화된 파라미터 병합
    dynamic_manager = DynamicParamManager()
    best_params = dynamic_manager.merge_params(best_trial.params)
    logger.info("최적의 파라미터 도출 완료: %s", best_params)
    
    # 5. 각 종목별 백테스트 실행 및 성과 계산
    start_date = "2018-06-01"
    end_date = "2025-02-01"
    timeframes = {"short_tf": "4h", "long_tf": "1d"}
    symbols = ["BTC/USDT", "ETH/USDT", "XRP/USDT"]
    
    for symbol in symbols:
        logger.info("심볼 %s 백테스트 시작", symbol)
        try:
            symbol_key = symbol.replace("/", "").lower()
            # use_weekly=True로 주간 데이터도 함께 로드하여 통합 환경을 구성함.
            backtester = Backtester(symbol=symbol, account_size=10000)
            backtester.load_data(
                short_table_format=f"ohlcv_{symbol_key}_{{timeframe}}",
                long_table_format=f"ohlcv_{symbol_key}_{{timeframe}}",
                short_tf=timeframes["short_tf"],
                long_tf=timeframes["long_tf"],
                start_date=start_date,
                end_date=end_date,
                use_weekly=True
            )
        except Exception as e:
            logger.error("심볼 %s 데이터 로드 실패: %s", symbol, e)
            continue
        
        try:
            trades, trade_logs = backtester.run_backtest(dynamic_params=best_params)
            logger.info("심볼 %s 백테스트 완료: 총 거래 횟수 = %d", symbol, len(trades))
        except Exception as e:
            logger.error("심볼 %s 백테스트 실행 중 에러: %s", symbol, e)
            continue
        
        if trades:
            # 주간 전략 성과 분석 반영: 주간 데이터(backtester.df_weekly)를 함께 전달
            performance_data = compute_performance(trades, weekly_data=backtester.df_weekly)
            logger.info("심볼 %s 성과 보고 생성", symbol)
            generate_final_report(performance_data, symbol=symbol)
        else:
            logger.info("심볼 %s 백테스트 결과, 생성된 거래 내역이 없습니다.", symbol)
    
    logger.info("전체 프로젝트 테스트 실행 완료.")

if __name__ == '__main__':
    run_strategy_performance()
