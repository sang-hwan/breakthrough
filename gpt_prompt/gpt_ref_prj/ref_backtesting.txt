[backtesting]
# backtesting/backtester.py
import pandas as pd
import numpy as np
from datetime import timedelta

from logs.logger_config import setup_logger
from trading.risk_manager import RiskManager
from trading.trade_manager import TradeManager
from dynamic_parameters.dynamic_param_manager import DynamicParamManager
from data_collection.db_manager import fetch_ohlcv_records
from trading.positions import TradePosition
from markets_analysis.hmm_model import MarketRegimeHMM
from markets_analysis.regime_filter import filter_by_confidence
from trading.strategies import TradingStrategies
from trading.account import Account
from trading.indicators import compute_sma, compute_rsi, compute_macd, compute_bollinger_bands
from trading.asset_manager import AssetManager
from trading.ensemble_manager import EnsembleManager

class Backtester:
    # 집계 임계치를 5000건으로 설정
    BULLISH_ENTRY_AGGREGATION_THRESHOLD = 5000

    def __init__(self, symbol="BTC/USDT", account_size=10000.0, fee_rate=0.001, 
                 slippage_rate=0.0005, final_exit_slippage=0.0):
        self.symbol = symbol
        self.fee_rate = fee_rate
        self.slippage_rate = slippage_rate
        self.final_exit_slippage = final_exit_slippage
        self.positions = []
        self.trades = []
        self.trade_logs = []
        self.logger = setup_logger(__name__)
        self.dynamic_param_manager = DynamicParamManager()
        self.account = Account(initial_balance=account_size, fee_rate=fee_rate)
        self.asset_manager = AssetManager(self.account)
        self.ensemble_manager = EnsembleManager()
        self.strategy_manager = TradingStrategies()
        self.hmm_model = None
        self.last_hmm_training_datetime = None
        self.df_extra = None
        self.last_signal_time = None
        self.last_rebalance_time = None
        # bullish entry 이벤트 집계를 위한 리스트
        self.bullish_entry_events = []

    def load_data(self, short_table_format, long_table_format, short_tf, long_tf, 
                  start_date=None, end_date=None, extra_tf=None):
        symbol_for_table = self.symbol.replace('/', '').lower()
        short_table = short_table_format.format(symbol=symbol_for_table, timeframe=short_tf)
        long_table = long_table_format.format(symbol=symbol_for_table, timeframe=long_tf)
        self.df_short = fetch_ohlcv_records(short_table, start_date, end_date)
        self.df_long = fetch_ohlcv_records(long_table, start_date, end_date)
        if self.df_short.empty or self.df_long.empty:
            self.logger.error("데이터 로드 실패: 데이터가 비어있습니다.")
            raise ValueError("No data loaded")
        self.df_short.sort_index(inplace=True)
        self.df_long.sort_index(inplace=True)
        self.logger.info(f"데이터 로드 완료: short 데이터 {len(self.df_short)}행, long 데이터 {len(self.df_long)}행")
        
        if extra_tf:
            extra_table = short_table_format.format(symbol=symbol_for_table, timeframe=extra_tf)
            self.df_extra = fetch_ohlcv_records(extra_table, start_date, end_date)
            if not self.df_extra.empty:
                self.df_extra.sort_index(inplace=True)
                self.df_extra = compute_bollinger_bands(self.df_extra, price_column='close', 
                                                        period=20, std_multiplier=2.0, fillna=True)
                self.logger.info(f"Extra 데이터 로드 완료: {len(self.df_extra)}행")

    def apply_indicators(self):
        self.df_long = compute_sma(self.df_long, price_column='close', period=200, fillna=True, output_col='sma')
        self.df_long = compute_rsi(self.df_long, price_column='close', period=14, fillna=True, output_col='rsi')
        self.df_long = compute_macd(self.df_long, price_column='close', slow_period=26, fast_period=12, 
                                     signal_period=9, fillna=True, prefix='macd_')
        self.logger.info("인디케이터 적용 완료 (SMA, RSI, MACD)")

    def update_hmm_regime(self, dynamic_params):
        # HMM 재학습 및 예측 (세부 로그 생략)
        hmm_features = ['returns', 'volatility', 'sma', 'rsi', 'macd_macd', 'macd_signal', 'macd_diff']
        current_dt = self.df_long.index.max()
        retrain_interval = pd.Timedelta(minutes=dynamic_params.get('hmm_retrain_interval_minutes', 60))
        max_samples = dynamic_params.get('max_hmm_train_samples', 1000)
        if (self.hmm_model is None) or (self.last_hmm_training_datetime is None) or ((current_dt - self.last_hmm_training_datetime) >= retrain_interval):
            self.hmm_model = MarketRegimeHMM(n_components=3, retrain_interval_minutes=dynamic_params.get('hmm_retrain_interval_minutes', 60))
            training_data = self.df_long if len(self.df_long) <= max_samples else self.df_long.tail(max_samples)
            self.hmm_model.train(training_data, feature_columns=hmm_features)
            self.last_hmm_training_datetime = current_dt
            self.logger.info(f"HMM 모델 재학습 완료: {current_dt}")
        regime_predictions = self.hmm_model.predict(self.df_long, feature_columns=hmm_features)
        confidence_flags = filter_by_confidence(self.hmm_model, self.df_long, feature_columns=hmm_features, 
                                                  threshold=dynamic_params.get('hmm_confidence_threshold', 0.8))
        self.df_long['long_term_sma'] = self.df_long['close'].rolling(window=dynamic_params.get('sma_period', 200), min_periods=1).mean()
        regime_map = {0: "bullish", 1: "bearish", 2: "sideways"}
        adjusted_regimes = []
        for idx, (pred, conf) in enumerate(zip(regime_predictions, confidence_flags)):
            if not conf:
                regime = "bullish" if self.df_long['close'].iloc[idx] > self.df_long['long_term_sma'].iloc[idx] else "bearish"
            else:
                regime = regime_map.get(pred, "unknown")
            adjusted_regimes.append(regime)
        regime_series = pd.Series(adjusted_regimes, index=self.df_long.index)
        self.logger.info("HMM 레짐 업데이트 완료")
        return regime_series

    def update_short_dataframe(self, regime_series, dynamic_params):
        self.df_short = self.df_short.join(self.df_long[['sma', 'rsi', 'volatility']], how='left').ffill()
        self.df_short['market_regime'] = regime_series.reindex(self.df_short.index).ffill()
        # ATR 계산은 TradeManager.compute_atr()에서 요약 로그로 처리됨.
        self.df_short = TradeManager.compute_atr(self.df_short, period=dynamic_params.get("atr_period", 14))
        self.logger.info("Short 데이터 프레임 업데이트 완료 (인디케이터, 레짐, ATR)")

    def handle_walk_forward_window(self, current_time, row):
        # 모든 포지션 강제 청산 – 각 포지션의 실행 결과를 개별 로그 대신 최종 요약으로 처리
        for pos in self.positions:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    final_close = row["close"]
                    adjusted_final_close = final_close * (1 - self.final_exit_slippage) if self.final_exit_slippage else final_close
                    exit_price = adjusted_final_close * (1 - self.slippage_rate)
                    fee = exit_price * exec_record["size"] * self.fee_rate
                    pnl = (exit_price - exec_record["entry_price"]) * exec_record["size"] - fee
                    exec_record["closed"] = True
                    trade_detail = {
                        "entry_time": exec_record["entry_time"],
                        "entry_price": exec_record["entry_price"],
                        "exit_time": current_time,
                        "exit_price": exit_price,
                        "size": exec_record["size"],
                        "pnl": pnl,
                        "reason": "walk_forward_window_close",
                        "trade_type": exec_record.get("trade_type", "unknown"),
                        "position_id": pos.position_id
                    }
                    self.trade_logs.append(trade_detail)
                    self.trades.append(trade_detail)
                    self.account.update_after_trade(trade_detail)
        self.positions = []
        self.logger.debug(f"워크 포워드 종료 처리 완료 at {current_time}")

    def process_bullish_entry(self, current_time, row, risk_params, dynamic_params):
        close_price = row["close"]
        signal_cooldown = pd.Timedelta(minutes=dynamic_params.get("signal_cooldown_minutes", 5))
        if self.last_signal_time is not None and (current_time - self.last_signal_time) < signal_cooldown:
            return
        executed_event = None  # 개별 이벤트 설명 (예: 신규 진입, 스케일인 등)
        for pos in self.positions:
            if pos.side == "LONG":
                additional_size = RiskManager.compute_position_size(
                    available_balance=self.account.get_available_balance(),
                    risk_percentage=risk_params["risk_per_trade"],
                    entry_price=close_price,
                    stop_loss=row.get("stop_loss_price"),
                    fee_rate=self.fee_rate,
                    volatility=row.get("volatility", 0)
                )
                required_amount = close_price * additional_size * (1 + self.fee_rate)
                available_balance = self.account.get_available_balance()
                if available_balance >= required_amount:
                    RiskManager.attempt_scale_in_position(
                        position=pos,
                        current_price=close_price,
                        scale_in_threshold=dynamic_params.get("scale_in_threshold", 0.02),
                        slippage_rate=self.slippage_rate,
                        stop_loss=row.get("stop_loss_price"),
                        take_profit=row.get("take_profit_price"),
                        entry_time=current_time,
                        trade_type="scale_in"
                    )
                    executed_event = "스케일인 실행됨"
                    self.last_signal_time = current_time
                else:
                    executed_event = "스케일인 불가 (가용 잔고 부족)"
        if executed_event is None:
            total_size = RiskManager.compute_position_size(
                available_balance=self.account.get_available_balance(),
                risk_percentage=risk_params["risk_per_trade"],
                entry_price=close_price,
                stop_loss=row.get("stop_loss_price"),
                fee_rate=self.fee_rate,
                volatility=row.get("volatility", 0)
            )
            required_amount = close_price * total_size * (1 + self.fee_rate)
            available_balance = self.account.get_available_balance()
            if available_balance >= required_amount:
                new_position = TradePosition(
                    side="LONG",
                    initial_price=close_price,
                    maximum_size=total_size,
                    total_splits=dynamic_params.get("total_splits", 3),
                    allocation_plan=RiskManager.allocate_position_splits(
                        total_size=1.0,
                        splits_count=dynamic_params.get("total_splits", 3),
                        allocation_mode=dynamic_params.get("allocation_mode", "equal")
                    )
                )
                new_position.highest_price = close_price
                try:
                    atr_value = self.df_short.loc[current_time, "atr"]
                except KeyError:
                    atr_value = 0
                stop_loss_price, take_profit_price = TradeManager.calculate_dynamic_stop_and_take(close_price, atr_value, risk_params)
                new_position.allocation_plan = RiskManager.allocate_position_splits(
                    total_size=1.0,
                    splits_count=dynamic_params.get("total_splits", 3),
                    allocation_mode=dynamic_params.get("allocation_mode", "equal")
                )
                exit_targets = TradeManager.calculate_partial_exit_targets(
                    entry_price=close_price,
                    partial_exit_ratio=dynamic_params.get("partial_exit_ratio", 0.5),
                    partial_profit_ratio=dynamic_params.get("partial_profit_ratio", 0.03),
                    final_profit_ratio=dynamic_params.get("final_profit_ratio", 0.06)
                )
                executed_price = close_price * (1 + self.slippage_rate)
                new_position.add_execution(
                    entry_price=executed_price,
                    size=total_size * new_position.allocation_plan[0],
                    stop_loss=stop_loss_price,
                    take_profit=take_profit_price,
                    entry_time=current_time,
                    exit_targets=exit_targets,
                    trade_type="new_entry"
                )
                new_position.executed_splits = 1
                self.positions.append(new_position)
                self.account.add_position(new_position)
                executed_event = "신규 진입 실행됨"
                self.last_signal_time = current_time
            else:
                executed_event = "신규 진입 불가 (가용 잔고 부족)"
        # 개별 이벤트를 바로 기록하는 대신, 집계 리스트에 추가합니다.
        self.bullish_entry_events.append((current_time, executed_event, close_price))
        if len(self.bullish_entry_events) >= Backtester.BULLISH_ENTRY_AGGREGATION_THRESHOLD:
            count = len(self.bullish_entry_events)
            freq = {}
            price_sum = 0
            for evt in self.bullish_entry_events:
                evt_type = evt[1]
                freq[evt_type] = freq.get(evt_type, 0) + 1
                price_sum += evt[2]
            avg_price = price_sum / count
            self.logger.info(f"{current_time} - Bullish Entry Summary: {count} events; " +
                             ", ".join([f"{k}: {v}" for k, v in freq.items()]) +
                             f"; 평균 진입가: {avg_price:.2f}")
            self.bullish_entry_events.clear()

    def process_bearish_exit(self, current_time, row):
        close_price = row["close"]
        exit_count = 0
        for pos in self.positions[:]:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    exit_price = close_price * (1 - self.slippage_rate)
                    fee = exit_price * exec_record["size"] * self.fee_rate
                    pnl = (exit_price - exec_record["entry_price"]) * exec_record["size"] - fee
                    exec_record["closed"] = True
                    trade_detail = {
                        "entry_time": exec_record["entry_time"],
                        "entry_price": exec_record["entry_price"],
                        "exit_time": current_time,
                        "exit_price": exit_price,
                        "size": exec_record["size"],
                        "pnl": pnl,
                        "reason": "exit_regime_change",
                        "trade_type": exec_record.get("trade_type", "unknown"),
                        "position_id": pos.position_id
                    }
                    self.trade_logs.append(trade_detail)
                    self.trades.append(trade_detail)
                    self.account.update_after_trade(trade_detail)
                    exit_count += 1
        self.last_signal_time = current_time
        self.logger.debug(f"{current_time} - bearish exit 처리 완료: {exit_count} 거래 실행됨")

    def process_sideways_trade(self, current_time, row, risk_params, dynamic_params):
        close_price = row["close"]
        liquidity = dynamic_params.get('liquidity_info', 'high').lower()
        event = None
        if liquidity == "high":
            lower_bound = self.df_short['low'].rolling(window=20, min_periods=1).min().iloc[-1]
            upper_bound = self.df_short['high'].rolling(window=20, min_periods=1).max().iloc[-1]
            if close_price <= lower_bound:
                event = "Range Trade 진입 (하단 터치)"
                self.process_bullish_entry(current_time, row, risk_params, dynamic_params)
            elif close_price >= upper_bound:
                event = "Range Trade 청산 (상단 터치)"
                for pos in self.positions:
                    if pos.side == "LONG":
                        for i, exec_record in enumerate(pos.executions):
                            if not exec_record.get("closed", False) and "exit_targets" in exec_record:
                                for target in exec_record["exit_targets"]:
                                    if not target.get("hit", False) and close_price >= target["price"]:
                                        target["hit"] = True
                                        pos.partial_close_execution(i, target["exit_ratio"])
                                        break
        else:
            mean_price = self.df_short['close'].rolling(window=20, min_periods=1).mean().iloc[-1]
            std_price = self.df_short['close'].rolling(window=20, min_periods=1).std().iloc[-1]
            if close_price < mean_price - std_price:
                event = "Mean Reversion 진입 (저평가)"
                self.process_bullish_entry(current_time, row, risk_params, dynamic_params)
            elif close_price > mean_price + std_price:
                event = "Mean Reversion 청산 (고평가)"
                self.process_bearish_exit(current_time, row)
        if event:
            self.logger.debug(f"{current_time} - {event}: close_price={close_price:.2f}")

    def update_positions(self, current_time, row):
        close_price = row["close"]
        for pos in self.positions:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    pos.highest_price = max(pos.highest_price, close_price)
                    if abs(close_price - exec_record["entry_price"]) / exec_record["entry_price"] > 0.01:
                        new_stop = TradeManager.adjust_trailing_stop(
                            current_stop=row.get("stop_loss_price", 0),
                            current_price=close_price,
                            highest_price=pos.highest_price,
                            trailing_percentage=self.dynamic_param_manager.get_default_params().get("trailing_percent", 0.045)
                        )
                        exec_record["stop_loss"] = new_stop

    def finalize_all_positions(self):
        # Flush any remaining bullish entry events before finalizing positions
        if self.bullish_entry_events:
            count = len(self.bullish_entry_events)
            freq = {}
            price_sum = 0
            for evt in self.bullish_entry_events:
                evt_type = evt[1]
                freq[evt_type] = freq.get(evt_type, 0) + 1
                price_sum += evt[2]
            avg_price = price_sum / count
            self.logger.info(f"{self.df_short.index[-1]} - Bullish Entry Summary (final flush): {count} events; " +
                             ", ".join([f"{k}: {v}" for k, v in freq.items()]) +
                             f"; 평균 진입가: {avg_price:.2f}")
            self.bullish_entry_events.clear()

        final_time = self.df_short.index[-1]
        final_close = self.df_short.iloc[-1]["close"]
        adjusted_final_close = final_close * (1 - self.final_exit_slippage) if self.final_exit_slippage else final_close
        for pos in self.positions:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    exit_price = adjusted_final_close * (1 - self.slippage_rate)
                    fee = exit_price * exec_record["size"] * self.fee_rate
                    pnl = (exit_price - exec_record["entry_price"]) * exec_record["size"] - fee
                    exec_record["closed"] = True
                    trade_detail = {
                        "entry_time": exec_record["entry_time"],
                        "entry_price": exec_record["entry_price"],
                        "exit_time": final_time,
                        "exit_price": exit_price,
                        "size": exec_record["size"],
                        "pnl": pnl,
                        "reason": "final_exit",
                        "trade_type": exec_record.get("trade_type", "unknown"),
                        "position_id": pos.position_id
                    }
                    self.trade_logs.append(trade_detail)
                    self.trades.append(trade_detail)
                    self.account.update_after_trade(trade_detail)
        self.logger.info("모든 포지션 최종 청산 완료")

    def monitor_orders(self, current_time, row):
        for pos in self.positions:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    entry_price = exec_record.get("entry_price", 0)
                    current_price = row.get("close", entry_price)
                    if abs(current_price - entry_price) / entry_price > 0.05:
                        self.logger.debug(f"{current_time} - Significant price move detected for position {pos.position_id}.")

    def run_backtest(self, dynamic_params=None, walk_forward_days: int = None, holdout_period: tuple = None):
        if dynamic_params is None:
            dynamic_params = self.dynamic_param_manager.get_default_params()
        self.df_long['returns'] = self.df_long['close'].pct_change().fillna(0)
        self.df_long['volatility'] = self.df_long['returns'].rolling(window=20).std().fillna(0)
        self.apply_indicators()
        regime_series = self.update_hmm_regime(dynamic_params)
        self.update_short_dataframe(regime_series, dynamic_params)
        
        if holdout_period:
            holdout_start, holdout_end = pd.to_datetime(holdout_period[0]), pd.to_datetime(holdout_period[1])
            df_train = self.df_short[self.df_short.index < holdout_start]
            df_holdout = self.df_short[(self.df_short.index >= holdout_start) & (self.df_short.index <= holdout_end)]
        else:
            df_train = self.df_short
            df_holdout = None
        
        if walk_forward_days is not None:
            window_start = df_train.index[0]
            walk_forward_td = pd.Timedelta(days=walk_forward_days)
        else:
            window_start = None
        
        signal_cooldown = pd.Timedelta(minutes=dynamic_params.get("signal_cooldown_minutes", 5))
        rebalance_interval = pd.Timedelta(minutes=dynamic_params.get("rebalance_interval_minutes", 60))
        
        self.logger.info("백테스트 시작")
        for current_time, row in df_train.iterrows():
            if walk_forward_days is not None and current_time - window_start >= walk_forward_td:
                self.handle_walk_forward_window(current_time, row)
                window_start = current_time
            if self.last_signal_time is None or (current_time - self.last_signal_time) >= signal_cooldown:
                action = self.ensemble_manager.get_final_signal(
                    row['market_regime'], 
                    dynamic_params.get('liquidity_info', 'high'), 
                    self.df_short, 
                    current_time
                )
                base_risk_params = {
                    "risk_per_trade": dynamic_params.get("risk_per_trade", 0.01),
                    "atr_multiplier": dynamic_params.get("atr_multiplier", 2.0),
                    "profit_ratio": dynamic_params.get("profit_ratio", 0.05),
                    "current_volatility": row.get("volatility", 0)
                }
                risk_params = RiskManager.compute_risk_parameters_by_regime(
                    base_risk_params,
                    regime=row['market_regime'],
                    liquidity=dynamic_params.get('liquidity_info', 'high')
                )
                if action == "enter_long":
                    self.process_bullish_entry(current_time, row, risk_params, dynamic_params)
                elif action == "exit_all":
                    self.process_bearish_exit(current_time, row)
                elif row['market_regime'] == "sideways":
                    self.process_sideways_trade(current_time, row, risk_params, dynamic_params)
            self.update_positions(current_time, row)
            if (self.last_rebalance_time is None) or ((current_time - self.last_rebalance_time) >= rebalance_interval):
                try:
                    self.asset_manager.rebalance(row['market_regime'])
                except Exception as e:
                    self.logger.error(f"Asset rebalancing failed: {e}")
                self.last_rebalance_time = current_time
        
        if self.df_extra is not None and not self.df_extra.empty:
            for current_time, row in self.df_extra.iterrows():
                hf_signal = self.strategy_manager.high_frequency_strategy(self.df_extra, current_time)
                regime = self.df_long.loc[self.df_long.index <= current_time].iloc[-1].get('market_regime', 'sideways')
                base_risk_params = {
                    "risk_per_trade": dynamic_params.get("risk_per_trade", 0.01),
                    "atr_multiplier": dynamic_params.get("atr_multiplier", 2.0),
                    "profit_ratio": dynamic_params.get("profit_ratio", 0.05),
                    "current_volatility": row.get("volatility", 0)
                }
                risk_params = RiskManager.compute_risk_parameters_by_regime(
                    base_risk_params,
                    regime=regime,
                    liquidity=dynamic_params.get('liquidity_info', 'high')
                )
                if hf_signal == "enter_long":
                    self.process_bullish_entry(current_time, row, risk_params, dynamic_params)
                elif hf_signal == "exit_all":
                    self.process_bearish_exit(current_time, row)
                self.monitor_orders(current_time, row)
        
        if df_holdout is not None:
            self.logger.info("홀드아웃 구간 백테스트 시작.")
            for current_time, row in df_holdout.iterrows():
                action = self.ensemble_manager.get_final_signal(
                    row['market_regime'], 
                    dynamic_params.get('liquidity_info', 'high'), 
                    self.df_short, 
                    current_time
                )
                base_risk_params = {
                    "risk_per_trade": dynamic_params.get("risk_per_trade", 0.01),
                    "atr_multiplier": dynamic_params.get("atr_multiplier", 2.0),
                    "profit_ratio": dynamic_params.get("profit_ratio", 0.05),
                    "current_volatility": row.get("volatility", 0)
                }
                risk_params = RiskManager.compute_risk_parameters_by_regime(
                    base_risk_params,
                    regime=row['market_regime'],
                    liquidity=dynamic_params.get('liquidity_info', 'high')
                )
                if action == "enter_long":
                    self.process_bullish_entry(current_time, row, risk_params, dynamic_params)
                elif action == "exit_all":
                    self.process_bearish_exit(current_time, row)
                elif row['market_regime'] == "sideways":
                    self.process_sideways_trade(current_time, row, risk_params, dynamic_params)
                self.update_positions(current_time, row)
        
        self.finalize_all_positions()
        total_pnl = sum(trade["pnl"] for trade in self.trades)
        roi = total_pnl / self.account.initial_balance * 100
        self.logger.info(f"백테스트 완료: 총 PnL={total_pnl:.2f}, ROI={roi:.2f}%")
        if roi < 2:
            self.logger.info("ROI 미달: 매월 ROI가 2% 미만입니다. 페이퍼 트레이딩 전환 없이 백테스트만 진행합니다.")
        return self.trades, self.trade_logs

---

# backtesting/optimizer.py
import optuna
import pandas as pd
from logs.logger_config import setup_logger
from backtesting.backtester import Backtester
from dynamic_parameters.dynamic_param_manager import DynamicParamManager

logger = setup_logger(__name__)

class DynamicParameterOptimizer:
    def __init__(self, n_trials=50):
        self.n_trials = n_trials
        self.study = None
        self.dynamic_param_manager = DynamicParamManager()

    def objective(self, trial):
        try:
            base_params = self.dynamic_param_manager.get_default_params()
            suggested_params = {
                "hmm_confidence_threshold": trial.suggest_float("hmm_confidence_threshold", 0.7, 0.95),
                "liquidity_info": trial.suggest_categorical("liquidity_info", ["high", "low"]),
                "atr_multiplier": trial.suggest_float("atr_multiplier", 1.5, 3.0),
                "profit_ratio": trial.suggest_float("profit_ratio", 0.05, 0.15),
                "risk_per_trade": trial.suggest_float("risk_per_trade", 0.005, 0.02),
                "scale_in_threshold": trial.suggest_float("scale_in_threshold", 0.01, 0.03),
                "partial_exit_ratio": trial.suggest_float("partial_exit_ratio", 0.4, 0.6),
                "partial_profit_ratio": trial.suggest_float("partial_profit_ratio", 0.02, 0.04),
                "final_profit_ratio": trial.suggest_float("final_profit_ratio", 0.05, 0.1)
            }
            dynamic_params = {**base_params, **suggested_params}
            logger.info(f"[Optimizer] 병합된 파라미터: {dynamic_params}")

            assets = ["BTC/USDT", "ETH/USDT", "XRP/USDT"]
            splits = [
                {
                    "train_start": "2018-06-01",
                    "train_end": "2020-12-31",
                    "test_start": "2021-01-01",
                    "test_end": "2023-12-31"
                }
            ]
            holdout = {"holdout_start": "2024-01-01", "holdout_end": "2025-02-01"}

            total_score = 0.0
            num_evaluations = 0

            for split in splits:
                for asset in assets:
                    logger.info(f"[Optimizer] {asset} 평가, 스플릿: {split}")
                    backtester_train = Backtester(symbol=asset, account_size=10000)
                    backtester_train.load_data(
                        short_table_format="ohlcv_{symbol}_{timeframe}",
                        long_table_format="ohlcv_{symbol}_{timeframe}",
                        short_tf="4h", long_tf="1d",
                        start_date=split["train_start"], end_date=split["train_end"]
                    )
                    try:
                        trades_train, _ = backtester_train.run_backtest(dynamic_params)
                    except Exception as e:
                        logger.error(f"[Optimizer] Training backtest 실패: {asset}, 스플릿 {split}: {e}", exc_info=True)
                        return 1e6
                    total_pnl_train = sum(trade["pnl"] for trade in trades_train)
                    roi_train = total_pnl_train / 10000 * 100
                    logger.info(f"[Optimizer] {asset} Training ROI: {roi_train:.2f}%")

                    backtester_test = Backtester(symbol=asset, account_size=10000)
                    backtester_test.load_data(
                        short_table_format="ohlcv_{symbol}_{timeframe}",
                        long_table_format="ohlcv_{symbol}_{timeframe}",
                        short_tf="4h", long_tf="1d",
                        start_date=split["test_start"], end_date=split["test_end"]
                    )
                    try:
                        trades_test, _ = backtester_test.run_backtest(dynamic_params)
                    except Exception as e:
                        logger.error(f"[Optimizer] Test backtest 실패: {asset}, 스플릿 {split}: {e}", exc_info=True)
                        return 1e6
                    total_pnl_test = sum(trade["pnl"] for trade in trades_test)
                    roi_test = total_pnl_test / 10000 * 100
                    logger.info(f"[Optimizer] {asset} Test ROI: {roi_test:.2f}%")

                    backtester_holdout = Backtester(symbol=asset, account_size=10000)
                    backtester_holdout.load_data(
                        short_table_format="ohlcv_{symbol}_{timeframe}",
                        long_table_format="ohlcv_{symbol}_{timeframe}",
                        short_tf="4h", long_tf="1d",
                        start_date=holdout["holdout_start"], end_date=holdout["holdout_end"]
                    )
                    try:
                        trades_holdout, _ = backtester_holdout.run_backtest(dynamic_params)
                    except Exception as e:
                        logger.error(f"[Optimizer] Holdout backtest 실패: {asset}: {e}", exc_info=True)
                        return 1e6
                    total_pnl_holdout = sum(trade["pnl"] for trade in trades_holdout)
                    roi_holdout = total_pnl_holdout / 10000 * 100
                    logger.info(f"[Optimizer] {asset} Holdout ROI: {roi_holdout:.2f}%")

                    overfit_penalty = abs(roi_train - roi_test)
                    holdout_penalty = 0 if roi_holdout >= 2.0 else (2.0 - roi_holdout) * 10

                    score = -roi_test + overfit_penalty + holdout_penalty
                    logger.info(f"[Optimizer] {asset} Score: {score:.2f} (Overfit: {overfit_penalty:.2f}, Holdout: {holdout_penalty:.2f})")
                    total_score += score
                    num_evaluations += 1

            avg_score = total_score / num_evaluations if num_evaluations > 0 else total_score

            reg_penalty = 0.0
            regularization_keys = ["atr_multiplier", "profit_ratio", "risk_per_trade", "scale_in_threshold"]
            for key in regularization_keys:
                default_value = base_params.get(key, 1.0)
                diff = dynamic_params.get(key, default_value) - default_value
                reg_penalty += (diff ** 2)
            reg_penalty *= 0.1

            final_score = avg_score + reg_penalty
            logger.info(f"[Optimizer] 최종 트라이얼 점수: {final_score:.2f} (Avg: {avg_score:.2f}, Reg: {reg_penalty:.2f})")
            return final_score

        except Exception as e:
            logger.error(f"[Optimizer] Objective 함수 에러: {e}", exc_info=True)
            return 1e6

    def optimize(self):
        sampler = optuna.samplers.TPESampler(seed=42)
        self.study = optuna.create_study(direction="minimize", sampler=sampler)
        logger.info(f"[Optimizer] {self.n_trials} 트라이얼로 최적화 시작.")
        self.study.optimize(self.objective, n_trials=self.n_trials)
        
        trials_df = self.study.trials_dataframe()
        logger.debug(f"[Optimizer] 트라이얼 결과:\n{trials_df.to_string()}")
        
        best_trial = self.study.best_trial
        logger.info(f"[Optimizer] Best trial: {best_trial.number} (Value: {best_trial.value:.2f})")
        logger.info(f"[Optimizer] Best parameters: {best_trial.params}")
        return best_trial

---

# backtesting/performance.py
import pandas as pd
import numpy as np
from datetime import datetime
import math

def calculate_monthly_performance(trades):
    monthly_data = {}
    for trade in trades:
        exit_time = trade.get("exit_time") or trade.get("entry_time")
        if exit_time is None:
            continue
        if hasattr(exit_time, "strftime"):
            month = exit_time.strftime("%Y-%m")
        else:
            month = exit_time[:7]
        monthly_data.setdefault(month, []).append(trade.get("pnl", 0))
    
    monthly_performance = {}
    for month, pnl_list in monthly_data.items():
        total_pnl = sum(pnl_list)
        roi = (total_pnl / 10000.0) * 100  # 초기 자본 10000 기준
        monthly_performance[month] = {
            "roi": roi,
            "trade_count": len(pnl_list)
        }
    return monthly_performance

def calculate_overall_performance(trades):
    initial_capital = 10000.0
    total_pnl = sum(trade.get("pnl", 0) for trade in trades)
    trade_count = len(trades)
    cumulative_return = (initial_capital + total_pnl) / initial_capital - 1
    roi = cumulative_return * 100

    # 정렬: exit_time (없으면 entry_time)
    sorted_trades = sorted(trades, key=lambda t: t.get("exit_time") or t.get("entry_time"))
    
    # Equity curve 생성
    dates = []
    equity = initial_capital
    equity_list = []
    trade_pnls = []
    for trade in sorted_trades:
        dt = trade.get("exit_time") or trade.get("entry_time")
        if dt is None:
            continue
        pnl = trade.get("pnl", 0)
        equity += pnl
        dates.append(pd.to_datetime(dt))
        equity_list.append(equity)
        trade_pnls.append(pnl)
    
    if not dates:
        # 거래가 하나도 없으면 기본값 반환
        return {
            "roi": roi,
            "cumulative_return": cumulative_return,
            "total_pnl": total_pnl,
            "trade_count": trade_count,
            "annualized_return": 0.0,
            "annualized_volatility": 0.0,
            "sharpe_ratio": 0.0,
            "sortino_ratio": 0.0,
            "calmar_ratio": 0.0,
            "max_drawdown": 0.0,
            "win_rate": 0.0,
            "avg_win": 0.0,
            "avg_loss": 0.0,
            "profit_factor": 0.0,
            "trades_per_year": 0.0,
            "max_consecutive_wins": 0,
            "max_consecutive_losses": 0
        }
    
    # Equity DataFrame를 일별로 재구성
    df_equity = pd.DataFrame({"equity": equity_list}, index=pd.to_datetime(dates))
    df_equity = df_equity.asfreq("D", method="ffill")
    daily_returns = df_equity["equity"].pct_change().dropna()
    
    # 연간화 변동성
    annualized_vol = daily_returns.std() * np.sqrt(252) if not daily_returns.empty else 0.0

    # 연간화 수익률 (기간 보정)
    start_date = df_equity.index.min()
    end_date = df_equity.index.max()
    total_days = (end_date - start_date).days
    if total_days > 0:
        annualized_return = (df_equity["equity"].iloc[-1] / initial_capital) ** (365 / total_days) - 1
    else:
        annualized_return = 0.0

    # 최대 낙폭 계산
    roll_max = df_equity["equity"].cummax()
    drawdown = roll_max - df_equity["equity"]
    max_drawdown = drawdown.max()

    # 샤프 지수 (무위험 수익률 0으로 가정)
    sharpe_ratio = annualized_return / annualized_vol if annualized_vol != 0 else 0.0

    # 소르티노 지수: 음의 수익률만 사용
    downside_returns = daily_returns[daily_returns < 0]
    downside_std = downside_returns.std() * np.sqrt(252) if not downside_returns.empty else 0.0
    sortino_ratio = annualized_return / downside_std if downside_std != 0 else 0.0

    # 칼마 지수: 연간화 수익률 / 최대 낙폭 (낙폭 0이면 0)
    calmar_ratio = annualized_return / max_drawdown if max_drawdown > 0 else 0.0

    # 매매 통계 계산
    wins = [pnl for pnl in trade_pnls if pnl > 0]
    losses = [pnl for pnl in trade_pnls if pnl <= 0]
    win_rate = (len(wins) / trade_count * 100) if trade_count > 0 else 0.0
    avg_win = sum(wins) / len(wins) if wins else 0.0
    avg_loss = sum(losses) / len(losses) if losses else 0.0
    profit_factor = (sum(wins) / abs(sum(losses))) if losses and sum(losses) != 0 else 0.0

    # 연속 승/패 계산
    max_consecutive_wins = 0
    max_consecutive_losses = 0
    current_wins = 0
    current_losses = 0
    for pnl in trade_pnls:
        if pnl > 0:
            current_wins += 1
            current_losses = 0
        else:
            current_losses += 1
            current_wins = 0
        max_consecutive_wins = max(max_consecutive_wins, current_wins)
        max_consecutive_losses = max(max_consecutive_losses, current_losses)

    # 거래 빈도: 연간 거래 건수
    years = total_days / 365 if total_days > 0 else 1
    trades_per_year = trade_count / years

    return {
        "roi": roi,
        "cumulative_return": cumulative_return,
        "total_pnl": total_pnl,
        "trade_count": trade_count,
        "annualized_return": annualized_return * 100,  # %로 환산
        "annualized_volatility": annualized_vol * 100,  # %로 환산
        "sharpe_ratio": sharpe_ratio,
        "sortino_ratio": sortino_ratio,
        "calmar_ratio": calmar_ratio,
        "max_drawdown": max_drawdown,
        "win_rate": win_rate,
        "avg_win": avg_win,
        "avg_loss": avg_loss,
        "profit_factor": profit_factor,
        "trades_per_year": trades_per_year,
        "max_consecutive_wins": max_consecutive_wins,
        "max_consecutive_losses": max_consecutive_losses
    }

def compute_performance(trades):
    overall = calculate_overall_performance(trades)
    monthly = calculate_monthly_performance(trades)
    overall["monthly_performance"] = monthly
    return overall
