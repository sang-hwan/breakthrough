[trading_2]
# trading/risk_manager.py
from logs.logger_config import setup_logger

logger = setup_logger(__name__)

class RiskManager:
    @staticmethod
    def compute_position_size(
        available_balance: float,
        risk_percentage: float,
        entry_price: float,
        stop_loss: float,
        fee_rate: float = 0.001,
        min_order_size: float = 1e-8,
        volatility: float = 0.0,
        weekly_volatility: float = None,
        weekly_risk_coefficient: float = 1.0
    ) -> float:
        """
        포지션 사이즈 산정 시 단기 변동성 외에도 주간 변동성(예: 주간 ATR, 주간 표준편차 등)을
        반영하여 전체 자산의 1~2% 손실 기준에 맞도록 조정합니다.
        주간_volatility가 제공되면, weekly_risk_coefficient에 따라 포지션 사이즈를 축소합니다.
        """
        if stop_loss is None:
            stop_loss = entry_price * 0.98
        price_diff = abs(entry_price - stop_loss)
        max_risk = available_balance * risk_percentage
        fee_amount = entry_price * fee_rate
        loss_per_unit = price_diff + fee_amount
        computed_size = max_risk / loss_per_unit if loss_per_unit > 0 else 0.0

        if volatility > 0:
            computed_size /= (1 + volatility)
        if weekly_volatility is not None:
            computed_size /= (1 + weekly_risk_coefficient * weekly_volatility)
        computed_size = computed_size if computed_size >= min_order_size else 0.0

        # 핵심 계산 결과를 INFO 레벨로 기록
        logger.debug(
            f"포지션 사이즈 계산: available_balance={available_balance}, risk_percentage={risk_percentage}, "
            f"entry_price={entry_price}, stop_loss={stop_loss}, fee_rate={fee_rate}, volatility={volatility}, "
            f"weekly_volatility={weekly_volatility}, weekly_risk_coefficient={weekly_risk_coefficient}, "
            f"computed_size={computed_size}"
        )
        return computed_size

    @staticmethod
    def allocate_position_splits(total_size: float, splits_count: int = 3, allocation_mode: str = 'equal', min_order_size: float = 1e-8) -> list:
        if splits_count < 1:
            raise ValueError("splits_count는 1 이상이어야 합니다.")
        if allocation_mode not in ['equal', 'pyramid_up', 'pyramid_down']:
            raise ValueError("allocation_mode는 'equal', 'pyramid_up', 'pyramid_down' 중 하나여야 합니다.")
        if total_size < min_order_size:
            return [1.0]
        if allocation_mode == 'equal':
            allocation = [1.0 / splits_count] * splits_count
        elif allocation_mode == 'pyramid_up':
            ratio_sum = splits_count * (splits_count + 1) / 2
            allocation = [i / ratio_sum for i in range(1, splits_count + 1)]
        elif allocation_mode == 'pyramid_down':
            ratio_sum = splits_count * (splits_count + 1) / 2
            allocation = [i / ratio_sum for i in range(splits_count, 0, -1)]
        logger.debug(f"포지션 분할 할당: total_size={total_size}, splits_count={splits_count}, allocation_mode={allocation_mode}, allocation={allocation}")
        return allocation

    @staticmethod
    def attempt_scale_in_position(position, current_price: float, scale_in_threshold: float = 0.02, slippage_rate: float = 0.0,
                                  stop_loss: float = None, take_profit: float = None, entry_time=None, trade_type: str = "scale_in",
                                  base_multiplier: float = 1.0, dynamic_volatility: float = 1.0):
        if position is None or position.is_empty():
            # 운영상 중요한 이벤트로 기록
            logger.debug("스케일인 시도: 포지션이 없거나 비어있음")
            return
        while position.executed_splits < position.total_splits:
            next_split = position.executed_splits
            target_price = position.initial_price * (1.0 + scale_in_threshold * (next_split + 1)) * dynamic_volatility
            logger.debug(f"스케일인 타겟 가격 계산: next_split={next_split}, target_price={target_price:.2f}, current_price={current_price:.2f}")
            if current_price < target_price:
                break
            if next_split < len(position.allocation_plan):
                portion = position.allocation_plan[next_split]
            else:
                break
            chunk_size = position.maximum_size * portion
            executed_price = current_price * (1.0 + slippage_rate)
            position.add_execution(entry_price=executed_price, size=chunk_size, stop_loss=stop_loss, take_profit=take_profit, entry_time=entry_time, trade_type=trade_type)
            position.executed_splits += 1
            logger.debug(f"스케일인 실행: 실행 가격={executed_price:.2f}, 크기={chunk_size:.4f}, 새로운 실행 횟수={position.executed_splits}")
        logger.debug(f"포지션 {position.position_id} 스케일인 시도 완료: 총 실행 횟수={position.executed_splits}")

    @staticmethod
    def is_significant_change(new_params: dict, old_params: dict, threshold: float = 0.10) -> bool:
        for k in new_params:
            if k in old_params:
                old_val = old_params[k]
                new_val = new_params[k]
                if old_val == 0:
                    if new_val != 0:
                        logger.debug(f"파라미터 {k} 변화: old=0, new={new_val} (변화 있음)")
                        return True
                else:
                    rel_diff = abs(new_val - old_val) / abs(old_val)
                    if rel_diff > threshold:
                        logger.debug(f"파라미터 {k} 변화: old={old_val}, new={new_val}, rel_diff={rel_diff:.2f} (임계치 초과)")
                        return True
            else:
                logger.debug(f"새로운 파라미터 {k} 발견됨: {new_params[k]}")
                return True
        return False

    @staticmethod
    def compute_risk_parameters_by_regime(base_params: dict, regime: str, liquidity: str = None,
                                          bullish_risk_multiplier: float = 1.1, bullish_atr_multiplier_factor: float = 0.9, bullish_profit_ratio_multiplier: float = 1.1,
                                          bearish_risk_multiplier: float = 0.8, bearish_atr_multiplier_factor: float = 1.1, bearish_profit_ratio_multiplier: float = 0.9,
                                          high_liquidity_risk_multiplier: float = 1.0, low_liquidity_risk_multiplier: float = 0.8, high_atr_multiplier_factor: float = 1.0, low_atr_multiplier_factor: float = 1.1,
                                          high_profit_ratio_multiplier: float = 1.0, low_profit_ratio_multiplier: float = 0.9) -> dict:
        regime = regime.lower()
        risk_params = {}
        if regime == "bullish":
            risk_params['risk_per_trade'] = base_params['risk_per_trade'] * bullish_risk_multiplier
            risk_params['atr_multiplier'] = base_params['atr_multiplier'] * bullish_atr_multiplier_factor
            risk_params['profit_ratio'] = base_params['profit_ratio'] * bullish_profit_ratio_multiplier
        elif regime == "bearish":
            risk_params['risk_per_trade'] = base_params['risk_per_trade'] * bearish_risk_multiplier
            risk_params['atr_multiplier'] = base_params['atr_multiplier'] * bearish_atr_multiplier_factor
            risk_params['profit_ratio'] = base_params['profit_ratio'] * bearish_profit_ratio_multiplier
        elif regime == "sideways":
            if liquidity is None:
                raise ValueError("횡보장에서는 'liquidity' 정보를 반드시 제공해야 합니다.")
            liquidity = liquidity.lower()
            if liquidity == "high":
                risk_params['risk_per_trade'] = base_params['risk_per_trade'] * high_liquidity_risk_multiplier
                risk_params['atr_multiplier'] = base_params['atr_multiplier'] * high_atr_multiplier_factor
                risk_params['profit_ratio'] = base_params['profit_ratio'] * high_profit_ratio_multiplier
            else:
                risk_params['risk_per_trade'] = base_params['risk_per_trade'] * low_liquidity_risk_multiplier
                risk_params['atr_multiplier'] = base_params['atr_multiplier'] * low_atr_multiplier_factor
                risk_params['profit_ratio'] = base_params['profit_ratio'] * low_profit_ratio_multiplier
        else:
            raise ValueError("유효하지 않은 시장 레짐입니다. ('bullish', 'bearish', 'sideways' 중 하나여야 합니다.)")

        current_volatility = base_params.get("current_volatility", None)
        if current_volatility is not None:
            if current_volatility > 0.05:
                risk_params['risk_per_trade'] *= 0.8
                logger.debug(f"현재 변동성이 높음({current_volatility}), risk_per_trade 조정됨")
            else:
                risk_params['risk_per_trade'] *= 1.1
                logger.debug(f"현재 변동성이 낮음({current_volatility}), risk_per_trade 조정됨")

        logger.debug(f"최종 리스크 파라미터: {risk_params}")
        return risk_params

    @staticmethod
    def adjust_trailing_stop(
        current_stop: float,
        current_price: float,
        highest_price: float,
        trailing_percentage: float,
        volatility: float = 0.0,
        weekly_high: float = None,
        weekly_volatility: float = None
    ) -> float:
        """
        단기(intraday) 및 주간 데이터를 모두 반영하여 동적 손절 라인을 조정합니다.
        주간_high가 제공되면 주간 변동성을 반영한 스탑로스 값도 계산한 후, 두 값 중 보수적인(더 높은) 값을 선택합니다.
        """
        if current_stop is None:
            current_stop = highest_price * (1 - trailing_percentage * (1 + volatility))
        new_stop_intraday = highest_price * (1.0 - trailing_percentage * (1 + volatility))
        if weekly_high is not None:
            w_vol = weekly_volatility if weekly_volatility is not None else 0.0
            new_stop_weekly = weekly_high * (1 - trailing_percentage * (1 + w_vol))
            candidate_stop = max(new_stop_intraday, new_stop_weekly)
        else:
            candidate_stop = new_stop_intraday
        adjusted_stop = candidate_stop if candidate_stop > current_stop and candidate_stop < current_price else current_stop
        logger.debug(
            f"트레일링 스탑 조정: current_price={current_price:.2f}, highest_price={highest_price:.2f}, "
            f"volatility={volatility:.4f}, trailing_percentage={trailing_percentage}, "
            f"weekly_high={weekly_high}, weekly_volatility={weekly_volatility}, "
            f"adjusted_stop={adjusted_stop:.2f}"
        )
        return adjusted_stop

    @staticmethod
    def calculate_partial_exit_targets(
        entry_price: float,
        partial_exit_ratio: float = 0.5,
        partial_profit_ratio: float = 0.03,
        final_profit_ratio: float = 0.06,
        final_exit_ratio: float = 1.0,
        use_weekly_target: bool = False,
        weekly_momentum: float = None,
        weekly_adjustment_factor: float = 0.5
    ):
        """
        부분 청산 목표를 산출합니다.
        use_weekly_target이 True이고 weekly_momentum이 제공되면, 주간 모멘텀에 따라 목표 수익률을 조정합니다.
        """
        if use_weekly_target and weekly_momentum is not None:
            adjusted_partial = partial_profit_ratio + weekly_adjustment_factor * weekly_momentum
            adjusted_final = final_profit_ratio + weekly_adjustment_factor * weekly_momentum
        else:
            adjusted_partial = partial_profit_ratio
            adjusted_final = final_profit_ratio
        partial_target = entry_price * (1.0 + adjusted_partial)
        final_target = entry_price * (1.0 + adjusted_final)
        logger.debug(
            f"부분 청산 목표 계산: entry_price={entry_price}, 기본 partial_profit_ratio={partial_profit_ratio}, "
            f"final_profit_ratio={final_profit_ratio}, "
            f"{'주간 목표 반영: weekly_momentum=' + str(weekly_momentum) if use_weekly_target else '기본 계산'}, "
            f"계산된 partial_target={partial_target:.2f}, final_target={final_target:.2f}"
        )
        return [(partial_target, partial_exit_ratio), (final_target, final_exit_ratio)]

---

# trading/strategies.py
from logs.logger_config import setup_logger

class TradingStrategies:
    def __init__(self):
        self.logger = setup_logger(__name__)
        
        # 각 전략별 마지막 최종 신호를 저장 (신호 변경 감지용)
        self.previous_signals = {
            "select_strategy": None,
            "trend_following_strategy": None,
            "breakout_strategy": None,
            "counter_trend_strategy": None,
            "high_frequency_strategy": None,
            "weekly_breakout_strategy": None,
            "weekly_momentum_strategy": None
        }

    def _get_candle_pattern_signal(self, row):
        try:
            open_price = row.get('open')
            close_price = row.get('close')
            if open_price is None or close_price is None:
                return None
            if close_price > open_price * 1.005:
                return "bullish"
            elif close_price < open_price * 0.99:
                return "bearish"
        except Exception as e:
            self.logger.error(f"_get_candle_pattern_signal error: {e}", exc_info=True)
        return None

    def _get_sma_rsi_signal(self, row, previous_sma):
        try:
            sma = row.get('sma')
            rsi = row.get('rsi')
            if sma is not None and previous_sma is not None and sma > previous_sma and rsi is not None and rsi < 35:
                return "enter_long"
        except Exception as e:
            self.logger.error(f"_get_sma_rsi_signal error: {e}", exc_info=True)
        return "hold"

    def _get_bb_signal(self, row):
        try:
            bb_lband = row.get('bb_lband')
            close_price = row.get('close', 0)
            if bb_lband is not None and close_price <= bb_lband * 1.002:
                return "enter_long"
        except Exception as e:
            self.logger.error(f"_get_bb_signal error: {e}", exc_info=True)
        return "hold"

    def select_strategy(self, market_regime: str, liquidity_info: str, data, current_time, market_type: str = "crypto") -> str:
        """
        여러 보조 신호를 집계하여 최종 거래 신호를 결정합니다.
        """
        regime = market_regime.lower()
        signals = []

        try:
            current_row = data.loc[current_time]
        except Exception as e:
            self.logger.error(f"select_strategy: 데이터 조회 실패 for time {current_time}: {e}", exc_info=True)
            return "hold"

        if regime == "bullish":
            candle_signal = self._get_candle_pattern_signal(current_row)
            signals.append("enter_long" if candle_signal == "bullish" else "hold")
            
            try:
                previous_rows = data.loc[:current_time]
                if len(previous_rows) > 1:
                    previous_sma = previous_rows.iloc[-2].get('sma', current_row.get('sma'))
                else:
                    previous_sma = current_row.get('sma')
            except Exception as e:
                self.logger.error(f"select_strategy: 이전 데이터 조회 실패: {e}", exc_info=True)
                previous_sma = current_row.get('sma')
            sma_rsi_signal = self._get_sma_rsi_signal(current_row, previous_sma)
            signals.append(sma_rsi_signal)
            
            bb_signal = self._get_bb_signal(current_row)
            signals.append(bb_signal)
            
            final_signal = "enter_long" if "enter_long" in signals else "hold"
        elif regime == "bearish":
            final_signal = "exit_all"
        elif regime == "sideways":
            final_signal = "range_trade" if liquidity_info.lower() == "high" else "mean_reversion"
        else:
            final_signal = "hold"

        # 신호 변경 감지: 신호가 변경되었으면 INFO 레벨로 기록합니다.
        # (신호 유지의 경우 DEBUG로 남기지만, 프로젝트에서는 INFO 이상만 출력됨)
        key = "select_strategy"
        if self.previous_signals.get(key) != final_signal:
            self.logger.debug(f"select_strategy: 신호 변경, 최종 신호: {final_signal} at {current_time}")
            self.previous_signals[key] = final_signal
        else:
            self.logger.debug(f"select_strategy: 신호 유지: '{final_signal}' at {current_time}")

        return final_signal

    def trend_following_strategy(self, data, current_time):
        key = "trend_following_strategy"
        try:
            row = data.loc[current_time]
        except Exception as e:
            self.logger.error(f"trend_following_strategy: 데이터 조회 실패 for time {current_time}: {e}", exc_info=True)
            return "hold"
        sma = row.get('sma')
        price = row.get('close')
        final_signal = "enter_long" if sma is not None and price is not None and price > sma else "hold"
        
        if self.previous_signals.get(key) != final_signal:
            self.logger.debug(f"trend_following_strategy: 신호 변경, 최종 신호: {final_signal} at {current_time}")
            self.previous_signals[key] = final_signal
        else:
            self.logger.debug(f"trend_following_strategy: 신호 유지: '{final_signal}' at {current_time}")
            
        return final_signal

    def breakout_strategy(self, data, current_time, window=20):
        key = "breakout_strategy"
        try:
            data_sub = data.loc[:current_time]
            if len(data_sub) < window:
                final_signal = "hold"
            else:
                recent_high = data_sub['high'].iloc[-window:].max()
                price = data.loc[current_time, 'close']
                final_signal = "enter_long" if price > recent_high else "hold"
        except Exception as e:
            self.logger.error(f"breakout_strategy: 데이터 조회 실패 for time {current_time}: {e}", exc_info=True)
            final_signal = "hold"
        
        if self.previous_signals.get(key) != final_signal:
            self.logger.debug(f"breakout_strategy: 신호 변경, 최종 신호: {final_signal} at {current_time}")
            self.previous_signals[key] = final_signal
        else:
            self.logger.debug(f"breakout_strategy: 신호 유지: '{final_signal}' at {current_time}")
        
        return final_signal

    def counter_trend_strategy(self, data, current_time):
        key = "counter_trend_strategy"
        try:
            row = data.loc[current_time]
        except Exception as e:
            self.logger.error(f"counter_trend_strategy: 데이터 조회 실패 for time {current_time}: {e}", exc_info=True)
            return "hold"
        rsi = row.get('rsi')
        if rsi is not None:
            if rsi < 30:
                final_signal = "enter_long"
            elif rsi > 70:
                final_signal = "exit_all"
            else:
                final_signal = "hold"
        else:
            final_signal = "hold"
        
        if self.previous_signals.get(key) != final_signal:
            self.logger.debug(f"counter_trend_strategy: 신호 변경, 최종 신호: {final_signal} at {current_time} (rsi: {rsi})")
            self.previous_signals[key] = final_signal
        else:
            self.logger.debug(f"counter_trend_strategy: 신호 유지: '{final_signal}' at {current_time} (rsi: {rsi})")
        
        return final_signal

    def high_frequency_strategy(self, data, current_time):
        key = "high_frequency_strategy"
        try:
            current_index = data.index.get_loc(current_time)
            if current_index == 0:
                final_signal = "hold"
            else:
                prev_time = data.index[current_index - 1]
                current_row = data.loc[current_time]
                prev_row = data.loc[prev_time]
                current_price = current_row.get('close')
                prev_price = prev_row.get('close')
                if current_price is None or prev_price is None:
                    final_signal = "hold"
                else:
                    threshold = 0.002  # 0.2% 임계치
                    price_change = (current_price - prev_price) / prev_price
                    if price_change > threshold:
                        final_signal = "enter_long"
                    elif price_change < -threshold:
                        final_signal = "exit_all"
                    else:
                        final_signal = "hold"
        except Exception as e:
            self.logger.error(f"high_frequency_strategy: 데이터 조회 실패 for time {current_time}: {e}", exc_info=True)
            final_signal = "hold"
        
        if self.previous_signals.get(key) != final_signal:
            self.logger.debug(f"high_frequency_strategy: 신호 변경, 최종 신호: {final_signal} at {current_time}")
            self.previous_signals[key] = final_signal
        else:
            self.logger.debug(f"high_frequency_strategy: 신호 유지: '{final_signal}' at {current_time}")
        
        return final_signal

    def weekly_breakout_strategy(self, data_weekly, current_time, breakout_threshold=0.01):
        """
        주간 돌파 전략:
          - 전 주의 고점 및 저점을 기준으로 돌파 여부를 확인합니다.
          - 전 주 고점 돌파 시 "enter_long", 전 주 저점 하락 시 "exit_all" 신호를 생성합니다.
          - breakout_threshold 옵션으로 돌파 임계치를 조절할 수 있습니다.
        """
        try:
            weekly_data = data_weekly.loc[data_weekly.index <= current_time]
            if len(weekly_data) < 2:
                self.logger.debug("주간 데이터 부족: 최소 2주 이상의 데이터 필요")
                return "hold"
            prev_week = weekly_data.iloc[-2]
            current_week = weekly_data.iloc[-1]
            prev_high = prev_week.get('high')
            prev_low = prev_week.get('low')
            current_close = current_week.get('close')
            if current_close is None or prev_high is None or prev_low is None:
                self.logger.error("주간 데이터에 필요한 컬럼 누락")
                return "hold"
            if current_close >= prev_high * (1 + breakout_threshold):
                signal = "enter_long"
            elif current_close <= prev_low * (1 - breakout_threshold):
                signal = "exit_all"
            else:
                signal = "hold"
            self.logger.debug(f"weekly_breakout_strategy: prev_high={prev_high}, prev_low={prev_low}, current_close={current_close}, breakout_threshold={breakout_threshold}, signal={signal}")
            return signal
        except Exception as e:
            self.logger.error(f"weekly_breakout_strategy 에러: {e}", exc_info=True)
            return "hold"

    def weekly_momentum_strategy(self, data_weekly, current_time, momentum_threshold=0.5):
        """
        주간 모멘텀 전략:
          - 주간 인디케이터(예: 'weekly_momentum' 컬럼)를 활용하여 모멘텀 상태를 평가합니다.
          - 상승 모멘텀이면 "enter_long", 하락 모멘텀이면 "exit_all" (그 외는 "hold") 신호를 생성합니다.
          - momentum_threshold 옵션으로 임계치를 조절할 수 있습니다.
        """
        try:
            weekly_data = data_weekly.loc[data_weekly.index <= current_time]
            if weekly_data.empty:
                self.logger.debug("주간 데이터가 없습니다.")
                return "hold"
            current_week = weekly_data.iloc[-1]
            momentum = current_week.get('weekly_momentum')
            if momentum is None:
                self.logger.debug("weekly_momentum 컬럼이 누락되어 기본 'hold' 적용")
                return "hold"
            if momentum >= momentum_threshold:
                signal = "enter_long"
            elif momentum <= -momentum_threshold:
                signal = "exit_all"
            else:
                signal = "hold"
            self.logger.debug(f"weekly_momentum_strategy: momentum={momentum}, momentum_threshold={momentum_threshold}, signal={signal}")
            return signal
        except Exception as e:
            self.logger.error(f"weekly_momentum_strategy 에러: {e}", exc_info=True)
            return "hold"

---

# trading/trade_manager.py
import pandas as pd
import numpy as np
import ta
from logs.logger_config import setup_logger

logger = setup_logger(__name__)

class TradeManager:
    @staticmethod
    def calculate_atr_stop_loss(
        data: pd.DataFrame,
        atr_period: int = 14,
        atr_multiplier: float = 2.0,
        dynamic_sl_adjustment: float = 1.0,
        stop_loss_col: str = 'stop_loss_price',
        entry_price_col: str = 'entry_price',
        atr_col: str = 'atr',
        high_col: str = 'high',
        low_col: str = 'low',
        close_col: str = 'close',
        entry_signal_col: str = 'long_entry'
    ) -> pd.DataFrame:
        # ATR 계산
        if len(data) < atr_period:
            data[atr_col] = data[high_col] - data[low_col]
            logger.debug("ATR 계산: 데이터 길이가 짧아 high-low 차이 사용.")
        else:
            try:
                atr_indicator = ta.volatility.AverageTrueRange(
                    high=data[high_col],
                    low=data[low_col],
                    close=data[close_col],
                    window=atr_period,
                    fillna=True
                )
                data[atr_col] = atr_indicator.average_true_range()
                logger.debug(f"ATR 계산 성공: 첫 5행 {data[atr_col].head().tolist()}")
            except Exception as e:
                logger.error(f"ATR 계산 에러: {e}", exc_info=True)
                data[atr_col] = data[high_col] - data[low_col]

        # 중간 계산: rolling 평균, 표준편차, 비율 및 동적 승수 계산
        data['close_ma'] = data[close_col].rolling(window=atr_period, min_periods=1).mean()
        data['close_std'] = data[close_col].rolling(window=atr_period, min_periods=1).std()
        data['std_ratio'] = data['close_std'] / data['close_ma']
        data['dynamic_multiplier'] = atr_multiplier * (1 + data['std_ratio'])
        logger.debug(
            f"중간 계산 결과: close_ma 첫 5행={data['close_ma'].head().tolist()}, "
            f"close_std 첫 5행={data['close_std'].head().tolist()}, "
            f"std_ratio 첫 5행={data['std_ratio'].head().tolist()}, "
            f"dynamic_multiplier 첫 5행={data['dynamic_multiplier'].head().tolist()}"
        )
        
        # entry_price 컬럼 채우기 (입력 신호 발생 시 close 값을 기록하고, ffill)
        data[entry_price_col] = np.where(data.get(entry_signal_col, False), data[close_col], np.nan)
        data[entry_price_col] = data[entry_price_col].ffill()
        
        # 스탑로스 가격 계산
        data[stop_loss_col] = data[entry_price_col] - (data[atr_col] * data['dynamic_multiplier'] * dynamic_sl_adjustment)
        logger.debug(f"스탑로스 계산: 첫 5행 {data[stop_loss_col].head().tolist()}")
        
        # 중간 계산에 사용한 임시 컬럼 제거
        data.drop(columns=['close_ma', 'close_std', 'std_ratio', 'dynamic_multiplier'], inplace=True)

        logger.debug(f"ATR 기반 스탑로스 계산 완료: 총 {len(data)} 행 처리")
        return data

    @staticmethod
    def adjust_trailing_stop(
        current_stop: float,
        current_price: float,
        highest_price: float,
        trailing_percentage: float,
        volatility: float = 0.0,
        weekly_high: float = None,
        weekly_volatility: float = None
    ) -> float:
        """
        단기(intraday) 및 주간 데이터를 모두 반영하여 동적 손절 라인을 조정합니다.
        주간_high와 weekly_volatility가 제공되면, 주간 데이터 기반 스탑로스 값도 계산하여
        두 값 중 보수적인(더 높은) 값을 선택합니다.
        """
        if current_stop is None:
            current_stop = highest_price * (1 - trailing_percentage * (1 + volatility))
        new_stop_intraday = highest_price * (1.0 - trailing_percentage * (1 + volatility))
        if weekly_high is not None:
            w_vol = weekly_volatility if weekly_volatility is not None else 0.0
            new_stop_weekly = weekly_high * (1 - trailing_percentage * (1 + w_vol))
            candidate_stop = max(new_stop_intraday, new_stop_weekly)
        else:
            candidate_stop = new_stop_intraday
        adjusted_stop = candidate_stop if candidate_stop > current_stop and candidate_stop < current_price else current_stop
        logger.debug(
            f"트레일링 스탑 조정: current_price={current_price:.2f}, highest_price={highest_price:.2f}, "
            f"volatility={volatility:.4f}, trailing_percentage={trailing_percentage}, "
            f"weekly_high={weekly_high}, weekly_volatility={weekly_volatility}, "
            f"조정 후 스탑={adjusted_stop:.2f}"
        )
        return adjusted_stop

    @staticmethod
    def set_fixed_take_profit(
        data: pd.DataFrame,
        profit_ratio: float = 0.05,
        take_profit_col: str = 'take_profit_price',
        entry_price_col: str = 'entry_price'
    ) -> pd.DataFrame:
        data[take_profit_col] = data[entry_price_col] * (1 + profit_ratio)
        logger.debug(f"고정 테이크 프로핏 설정 완료: 총 {len(data)} 행 처리")
        return data

    @staticmethod
    def should_exit_trend(
        data: pd.DataFrame,
        current_time,
        window_length: int = 20,
        price_column: str = 'close'
    ) -> bool:
        if current_time not in data.index:
            data_sub = data.loc[:current_time]
            if len(data_sub) < window_length:
                return False
            window_data = data_sub.iloc[-window_length:]
        else:
            idx = data.index.get_loc(current_time)
            if idx < window_length:
                return False
            window_data = data.iloc[idx - window_length + 1: idx + 1]
        recent_min = window_data[price_column].min()
        current_price = (
            data.loc[current_time, price_column]
            if current_time in data.index
            else data.iloc[-1][price_column]
        )
        decision = current_price < recent_min
        logger.debug(
            f"should_exit_trend 결정: current_price={current_price}, recent_min={recent_min}, exit_decision={decision}"
        )
        return decision

    @staticmethod
    def calculate_partial_exit_targets(
        entry_price: float,
        partial_exit_ratio: float = 0.5,
        partial_profit_ratio: float = 0.03,
        final_profit_ratio: float = 0.06,
        final_exit_ratio: float = 1.0,
        use_weekly_target: bool = False,
        weekly_momentum: float = None,
        weekly_adjustment_factor: float = 0.5
    ):
        """
        부분 청산 목표를 산출합니다.
        use_weekly_target이 True이고 weekly_momentum이 제공되면, 주간 모멘텀에 따라 목표 수익률을 조정합니다.
        """
        if use_weekly_target and weekly_momentum is not None:
            adjusted_partial = partial_profit_ratio + weekly_adjustment_factor * weekly_momentum
            adjusted_final = final_profit_ratio + weekly_adjustment_factor * weekly_momentum
        else:
            adjusted_partial = partial_profit_ratio
            adjusted_final = final_profit_ratio
        partial_target = entry_price * (1.0 + adjusted_partial)
        final_target = entry_price * (1.0 + adjusted_final)
        logger.debug(
            f"부분 청산 목표 계산: entry_price={entry_price}, 기본 partial_profit_ratio={partial_profit_ratio}, "
            f"final_profit_ratio={final_profit_ratio}, "
            f"{'주간 목표 반영: weekly_momentum=' + str(weekly_momentum) if use_weekly_target else '기본 계산'}, "
            f"계산된 partial_target={partial_target:.2f}, final_target={final_target:.2f}"
        )
        return [(partial_target, partial_exit_ratio), (final_target, final_exit_ratio)]

    @staticmethod
    def compute_atr(data: pd.DataFrame, period: int = 14) -> pd.DataFrame:
        try:
            atr_indicator = ta.volatility.AverageTrueRange(
                high=data['high'],
                low=data['low'],
                close=data['close'],
                window=period,
                fillna=True
            )
            data['atr'] = atr_indicator.average_true_range()
            logger.debug(f"compute_atr: 첫 5행 ATR 값: {data['atr'].head().tolist()}")
        except Exception as e:
            logger.error(f"compute_atr 에러: {e}", exc_info=True)
            data['atr'] = data['high'] - data['low']
        logger.debug(f"ATR 계산 완료: 총 {len(data)} 행 처리")
        return data

    @staticmethod
    def calculate_dynamic_stop_and_take(
        entry_price: float,
        atr: float,
        risk_params: dict
    ):
        atr_multiplier = risk_params.get("atr_multiplier", 2.0)
        profit_ratio = risk_params.get("profit_ratio", 0.05)
        volatility_multiplier = risk_params.get("volatility_multiplier", 1.0)
        stop_loss_price = entry_price - (atr * atr_multiplier * volatility_multiplier)
        take_profit_price = entry_price * (1 + profit_ratio)
        logger.debug(
            f"동적 스탑로스/테이크 프로핏 계산: entry_price={entry_price:.2f}, ATR={atr:.2f}, "
            f"atr_multiplier={atr_multiplier}, volatility_multiplier={volatility_multiplier}, profit_ratio={profit_ratio}, "
            f"계산된 stop_loss={stop_loss_price:.2f}, take_profit={take_profit_price:.2f}"
        )
        return stop_loss_price, take_profit_price
