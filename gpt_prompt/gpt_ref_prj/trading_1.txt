[trading_1]
# trading/account.py
from logs.logger_config import setup_logger

logger = setup_logger(__name__)

class Account:
    def __init__(self, initial_balance, fee_rate=0.001):
        """
        초기 잔고는 모두 현물(spot) 자산으로 간주하며,
        fee_rate는 거래 시 적용되는 수수료율입니다.
        """
        self.initial_balance = initial_balance
        self.spot_balance = initial_balance
        self.stablecoin_balance = 0.0
        self.fee_rate = fee_rate
        self.positions = []  # 보유 중인 포지션 리스트
        logger.debug(f"Account 초기화 완료: 초기 잔고 {initial_balance:.2f}")

    def add_position(self, position):
        """
        포지션을 추가합니다.
        """
        self.positions.append(position)
        logger.debug(f"포지션 추가됨: ID={position.position_id}")

    def remove_position(self, position):
        """
        포지션을 제거합니다.
        """
        if position in self.positions:
            self.positions.remove(position)
            logger.debug(f"포지션 제거됨: ID={position.position_id}")
        else:
            logger.warning(f"포지션 제거 실패: ID={position.position_id} not found")

    def get_used_balance(self):
        """
        현재 포지션들로 인해 사용된 금액 계산 (수수료 포함)
        """
        used = 0.0
        for pos in self.positions:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    calc = exec_record["entry_price"] * exec_record["size"] * (1 + self.fee_rate)
                    used += calc
                    # INFO 레벨 로그로 남기면 AggregatingHandler가 동일 기준으로 누적하여 요약합니다.
                    logger.debug(
                        f"계산 중: 포지션 ID={pos.position_id}, "
                        f"entry_price={exec_record['entry_price']}, size={exec_record['size']}, "
                        f"fee_rate={self.fee_rate}, 계산값={calc:.2f}"
                    )
        logger.debug(f"총 사용 금액 계산: {used:.2f}")
        return used

    def get_available_balance(self):
        """
        현물 잔고에서 사용 중 금액을 제외한 가용 현금 반환
        """
        used = self.get_used_balance()
        available = self.spot_balance - used
        logger.debug(
            f"가용 잔고 계산: spot_balance={self.spot_balance:.2f} - used={used:.2f} = available={available:.2f}"
        )
        return available

    def update_after_trade(self, trade):
        """
        체결된 거래의 pnl을 반영하여 잔고를 업데이트합니다.
        """
        pnl = trade.get("pnl", 0.0)
        previous_balance = self.spot_balance
        self.spot_balance += pnl
        logger.debug(
            f"거래 체결 업데이트: pnl={pnl:.2f}, 현물 잔고={self.spot_balance:.2f}"
        )
        logger.debug(
            f"업데이트 상세: 이전 현물 잔고={previous_balance:.2f}, pnl {pnl:.2f} 반영하여 {self.spot_balance:.2f}가 되었습니다."
        )

    def convert_to_stablecoin(self, amount, conversion_fee=0.001):
        """
        현물 자산 일부를 스테이블코인으로 전환합니다.
        """
        available = self.get_available_balance()
        logger.debug(
            f"전환 요청: amount={amount:.2f}, 가용 잔고={available:.2f}"
        )
        if amount > available:
            logger.debug(
                f"요청 금액 {amount:.2f}이 가용 잔고 {available:.2f}보다 큽니다. 가용 잔고로 조정합니다."
            )
            amount = available
        fee = amount * conversion_fee
        net_amount = amount - fee
        logger.debug(
            f"전환 계산: amount={amount:.2f}, conversion_fee={conversion_fee}, fee={fee:.2f}, net_amount={net_amount:.2f}"
        )
        self.spot_balance -= amount
        self.stablecoin_balance += net_amount
        logger.debug(
            f"현물 -> 스테이블코인 전환: 전환액={amount:.2f}, 수수료={fee:.2f}, 전환 후 현물 잔고={self.spot_balance:.2f}"
        )
        return net_amount

    def convert_to_spot(self, amount, conversion_fee=0.001):
        """
        스테이블코인 일부를 현물 자산으로 전환합니다.
        """
        logger.debug(
            f"현물 전환 요청: amount={amount:.2f}, 현재 스테이블코인 잔고={self.stablecoin_balance:.2f}"
        )
        if amount > self.stablecoin_balance:
            logger.debug(
                f"요청 금액 {amount:.2f}이 스테이블코인 잔고 {self.stablecoin_balance:.2f}보다 큽니다. 잔고로 조정합니다."
            )
            amount = self.stablecoin_balance
        fee = amount * conversion_fee
        net_amount = amount - fee
        logger.debug(
            f"전환 계산: amount={amount:.2f}, conversion_fee={conversion_fee}, fee={fee:.2f}, net_amount={net_amount:.2f}"
        )
        self.stablecoin_balance -= amount
        self.spot_balance += net_amount
        logger.debug(
            f"스테이블코인 -> 현물 전환: 전환액={amount:.2f}, 수수료={fee:.2f}, 전환 후 현물 잔고={self.spot_balance:.2f}"
        )
        return net_amount

    def __str__(self):
        return (
            f"Account(spot_balance={self.spot_balance:.2f}, "
            f"stablecoin_balance={self.stablecoin_balance:.2f}, "
            f"available_balance={self.get_available_balance():.2f})"
        )

---

# trading/asset_manager.py
from logs.logger_config import setup_logger
from datetime import datetime, timedelta

class AssetManager:
    def __init__(self, account, min_rebalance_threshold=0.05, min_rebalance_interval_minutes=60):
        """
        자산 배분 및 리밸런싱을 관리합니다.
        - min_rebalance_threshold: 리밸런싱 실행을 위한 최소 배분 차이 (전체 자산 대비)
        - min_rebalance_interval_minutes: 리밸런싱 최소 간격 (분)
        """
        self.account = account
        self.logger = setup_logger(__name__)
        self.min_rebalance_threshold = min_rebalance_threshold
        self.min_rebalance_interval = timedelta(minutes=min_rebalance_interval_minutes)
        self.last_rebalance_time = None
        self.last_account_state = None  # (spot_balance, stablecoin_balance)
        # INFO 레벨 로그로 남겨 AggregatingHandler가 집계하도록 함.
        self.logger.debug(f"AssetManager 초기화: 최소 임계치={min_rebalance_threshold}, 최소 간격={min_rebalance_interval_minutes}분")

    def _get_account_state(self):
        state = (round(self.account.spot_balance, 4), round(self.account.stablecoin_balance, 4))
        self.logger.debug(f"현재 계좌 상태: spot_balance={state[0]}, stablecoin_balance={state[1]}")
        return state

    def rebalance(self, market_regime):
        """
        시장 레짐에 따라 자산 배분을 재조정합니다.
        """
        current_time = datetime.now()
        self.logger.debug(f"리밸런싱 시작 시각: {current_time}")
        
        # 리밸런싱 전 계좌 상태 로깅 추가
        pre_state = self._get_account_state()
        self.logger.debug(f"리밸런싱 전 계좌 상태: spot_balance={pre_state[0]}, stablecoin_balance={pre_state[1]}")

        if self.last_rebalance_time is not None:
            elapsed = current_time - self.last_rebalance_time
            if elapsed < self.min_rebalance_interval:
                self.logger.debug(f"리밸런싱 최소 간격 미충족: 경과 시간 {elapsed} (최소 간격: {self.min_rebalance_interval}).")
                return

        total_assets = self.account.spot_balance + self.account.stablecoin_balance
        self.logger.debug(
            f"총 자산 계산: spot_balance={self.account.spot_balance:.2f}, "
            f"stablecoin_balance={self.account.stablecoin_balance:.2f}, total_assets={total_assets:.2f}"
        )
        if total_assets <= 0:
            self.logger.warning("총 자산이 0 이하입니다. 리밸런싱을 건너뜁니다.")
            return

        regime = market_regime.lower()
        self.logger.debug(f"시장 레짐: {regime}")
        if regime == "bullish":
            desired_spot = total_assets * 0.90
        elif regime == "bearish":
            desired_spot = total_assets * 0.10
        elif regime == "sideways":
            desired_spot = total_assets * 0.60
        else:
            self.logger.warning(f"알 수 없는 시장 레짐: {market_regime}. 리밸런싱을 건너뜁니다.")
            return

        self.logger.debug(f"목표 현물 자산(desired_spot): {desired_spot:.2f}")
        current_spot = self.account.spot_balance
        self.logger.debug(f"현재 현물 자산(current_spot): {current_spot:.2f}")
        diff_ratio = abs(current_spot - desired_spot) / total_assets
        self.logger.debug(f"배분 차이 비율: {diff_ratio:.4f} (임계치: {self.min_rebalance_threshold})")

        if diff_ratio < self.min_rebalance_threshold:
            self.logger.debug("자산 배분 차이가 임계치 미만입니다. 리밸런싱을 실행하지 않습니다.")
            return

        # 리밸런싱 실행
        if current_spot < desired_spot:
            amount_to_convert = desired_spot - current_spot
            self.logger.debug(f"스테이블코인 -> 현물 전환 필요량: {amount_to_convert:.2f}")
            converted = self.account.convert_to_spot(amount_to_convert)
            self.logger.debug(f"[{market_regime.capitalize()}] 리밸런싱 실행: 스테이블코인 -> 현물 전환 {converted:.2f}")
        else:
            amount_to_convert = current_spot - desired_spot
            self.logger.debug(f"현물 -> 스테이블코인 전환 필요량: {amount_to_convert:.2f}")
            converted = self.account.convert_to_stablecoin(amount_to_convert)
            self.logger.debug(f"[{market_regime.capitalize()}] 리밸런싱 실행: 현물 -> 스테이블코인 전환 {converted:.2f}")

        self.last_rebalance_time = current_time

        # 리밸런싱 완료 후 계좌 상태 로깅
        current_state = self._get_account_state()
        if current_state != self.last_account_state:
            self.last_account_state = current_state
            self.logger.debug(f"리밸런싱 완료 후 계좌 상태: {self.account}")
        else:
            self.logger.debug("리밸런싱 완료: 계좌 상태 변화 없음.")

---

# trading/ensemble_manager.py
from logs.logger_config import setup_logger
from trading.strategies import TradingStrategies

class EnsembleManager:
    def __init__(self):
        self.logger = setup_logger(__name__)
        
        # 각 전략별 가중치 (필요 시 동적 조정)
        self.strategy_weights = {
            "base": 1.0,
            "trend_following": 1.0,
            "breakout": 1.0,
            "counter_trend": 1.0,
            "high_frequency": 1.0,
            "weekly_breakout": 1.0,
            "weekly_momentum": 1.0
        }
        self.strategy_manager = TradingStrategies()
        # 최종 신호의 마지막 값을 저장 (신호 변경 감지용)
        self.last_final_signal = None

    def get_final_signal(self, market_regime, liquidity_info, data, current_time, data_weekly=None):
        """
        단기 전략 신호와 주간 전략 신호를 가중치 기반으로 종합하여 최종 거래 신호를 산출합니다.
        
        - data: 단기 데이터 (예: 4h 캔들)
        - data_weekly: 주간 데이터 (예: 주간 캔들; 없으면 단기 전략만 반영)
        """
        # 단기 전략 신호 산출
        signals = {
            "base": self.strategy_manager.select_strategy(market_regime, liquidity_info, data, current_time),
            "trend_following": self.strategy_manager.trend_following_strategy(data, current_time),
            "breakout": self.strategy_manager.breakout_strategy(data, current_time),
            "counter_trend": self.strategy_manager.counter_trend_strategy(data, current_time),
            "high_frequency": self.strategy_manager.high_frequency_strategy(data, current_time)
        }
        # 주간 데이터가 제공되면 주간 전략 신호 추가
        if data_weekly is not None:
            signals["weekly_breakout"] = self.strategy_manager.weekly_breakout_strategy(data_weekly, current_time)
            signals["weekly_momentum"] = self.strategy_manager.weekly_momentum_strategy(data_weekly, current_time)
        
        self.logger.debug(f"각 전략 원시 신호: {signals}")
        
        # 단기와 주간 신호의 가중치 (예: 단기 0.7, 주간 0.3)
        short_term_weight = 0.7
        weekly_weight = 0.3 if data_weekly is not None else 0.0
        
        vote_enter = 0.0
        vote_exit  = 0.0
        
        # 단기 전략 투표
        for key in ["base", "trend_following", "breakout", "counter_trend", "high_frequency"]:
            sig = signals.get(key)
            if sig == "enter_long":
                vote_enter += short_term_weight * self.strategy_weights.get(key, 1.0)
            elif sig == "exit_all":
                vote_exit += short_term_weight * self.strategy_weights.get(key, 1.0)
        
        # 주간 전략 투표
        for key in ["weekly_breakout", "weekly_momentum"]:
            sig = signals.get(key)
            if sig == "enter_long":
                vote_enter += weekly_weight * self.strategy_weights.get(key, 1.0)
            elif sig == "exit_all":
                vote_exit += weekly_weight * self.strategy_weights.get(key, 1.0)
        
        if vote_exit > vote_enter:
            final_signal = "exit_all"
        elif vote_enter > vote_exit:
            final_signal = "enter_long"
        else:
            final_signal = "hold"
        
        if self.last_final_signal != final_signal:
            self.logger.debug(f"신호 변경: 이전 신호={self.last_final_signal}, 새로운 신호={final_signal} at {current_time}")
            self.last_final_signal = final_signal
        else:
            # 신호 유지 로그의 레벨을 INFO로 승격하여 기록
            self.logger.debug(f"신호 유지: '{final_signal}' at {current_time}")
        
        return final_signal

    def update_strategy_weights(self, performance_metrics):
        """
        실시간 성과 지표에 따라 각 전략의 가중치를 조정합니다.
        """
        for strat, perf in performance_metrics.items():
            if perf < 0:
                self.strategy_weights[strat] *= 0.95
            else:
                self.strategy_weights[strat] *= 1.05
        self.logger.debug(f"전략 가중치 업데이트: {self.strategy_weights}")

---

# trading/indicators.py
import pandas as pd
from ta.trend import SMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volatility import BollingerBands
from logs.logger_config import setup_logger

logger = setup_logger(__name__)

def compute_sma(data: pd.DataFrame, price_column: str = 'close', period: int = 20, fillna: bool = False, output_col: str = 'sma') -> pd.DataFrame:
    try:
        sma = SMAIndicator(close=data[price_column], window=period, fillna=fillna)
        data[output_col] = sma.sma_indicator()
        # DEBUG 레벨로 변경하여 과도한 로그를 줄임
        logger.debug(f"SMA computed: period={period}, output_col={output_col}")
    except Exception as e:
        logger.error(f"compute_sma 에러: {e}", exc_info=True)
    return data

def compute_macd(data: pd.DataFrame, price_column: str = 'close', slow_period: int = 26, fast_period: int = 12, signal_period: int = 9, fillna: bool = False, prefix: str = 'macd_') -> pd.DataFrame:
    try:
        macd = MACD(close=data[price_column],
                    window_slow=slow_period,
                    window_fast=fast_period,
                    window_sign=signal_period,
                    fillna=fillna)
        data[f'{prefix}macd'] = macd.macd()
        data[f'{prefix}signal'] = macd.macd_signal()
        data[f'{prefix}diff'] = macd.macd_diff()
        # DEBUG 레벨로 변경하여 로그 호출 빈도 감소
        logger.debug(f"MACD computed: slow={slow_period}, fast={fast_period}, signal={signal_period}, prefix={prefix}")
    except Exception as e:
        logger.error(f"compute_macd 에러: {e}", exc_info=True)
    return data

def compute_rsi(data: pd.DataFrame, price_column: str = 'close', period: int = 14, fillna: bool = False, output_col: str = 'rsi') -> pd.DataFrame:
    try:
        rsi = RSIIndicator(close=data[price_column], window=period, fillna=fillna)
        data[output_col] = rsi.rsi()
        # DEBUG 레벨로 변경하여 빈번한 로그를 줄임
        logger.debug(f"RSI computed: period={period}, output_col={output_col}")
    except Exception as e:
        logger.error(f"compute_rsi 에러: {e}", exc_info=True)
    return data

def compute_bollinger_bands(data: pd.DataFrame, price_column: str = 'close', period: int = 20, std_multiplier: float = 2.0, fillna: bool = False, prefix: str = 'bb_') -> pd.DataFrame:
    try:
        bb = BollingerBands(close=data[price_column], window=period, window_dev=std_multiplier, fillna=fillna)
        data[f'{prefix}mavg'] = bb.bollinger_mavg()
        data[f'{prefix}hband'] = bb.bollinger_hband()
        data[f'{prefix}lband'] = bb.bollinger_lband()
        data[f'{prefix}pband'] = bb.bollinger_pband()
        data[f'{prefix}wband'] = bb.bollinger_wband()
        data[f'{prefix}hband_ind'] = bb.bollinger_hband_indicator()
        data[f'{prefix}lband_ind'] = bb.bollinger_lband_indicator()
        # DEBUG 레벨로 변경하여 불필요한 INFO 로그 감소
        logger.debug(f"Bollinger Bands computed: period={period}, std_multiplier={std_multiplier}, prefix={prefix}")
    except Exception as e:
        logger.error(f"compute_bollinger_bands 에러: {e}", exc_info=True)
    return data

---

# trading/positions.py
import uuid
from logs.logger_config import setup_logger

logger = setup_logger(__name__)

class TradePosition:
    def __init__(self, side="LONG", initial_price: float = None, maximum_size: float = 0.0, total_splits: int = 1, allocation_plan: list = None):
        """
        포지션 생성:
          - side: 거래 방향 ("LONG" 또는 "SHORT")
          - initial_price: 진입가
          - maximum_size: 최대 포지션 사이즈
          - total_splits: 분할 진입 횟수
          - allocation_plan: 각 분할 진입 비율 (지정하지 않을 경우 빈 리스트)
        """
        self.position_id = str(uuid.uuid4())
        self.side = side
        self.executions = []
        self.initial_price = initial_price
        self.maximum_size = maximum_size
        self.total_splits = total_splits
        self.executed_splits = 0
        self.allocation_plan = allocation_plan if allocation_plan is not None else []
        self.highest_price = initial_price if initial_price is not None else 0.0
        logger.debug(f"새 포지션 생성: ID={self.position_id}, side={self.side}, 초기가격={self.initial_price}")

    def add_execution(self, entry_price: float, size: float, stop_loss: float = None, take_profit: float = None, entry_time=None, exit_targets: list = None, trade_type: str = "unknown", min_order_size: float = 1e-8):
        """
        포지션 실행 추가:
          - exit_targets: [(target_price, exit_ratio), ...]
          - min_order_size: 최소 체결 수량
        """
        if size < min_order_size:
            logger.debug("체결 수량이 최소 주문 수량보다 작아 실행 건너뜀.")
            return
        exit_targets_flagged = []
        if exit_targets is not None:
            for target_price, exit_ratio in exit_targets:
                exit_targets_flagged.append({
                    'price': target_price,
                    'exit_ratio': exit_ratio,
                    'hit': False
                })
        self.executions.append({
            'entry_price': entry_price,
            'size': size,
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'entry_time': entry_time,
            'exit_targets': exit_targets_flagged,
            'trade_type': trade_type,
            'highest_price_since_entry': entry_price,
            'closed': False
        })
        # INFO 레벨로 남기면 AggregatingHandler 가 동일 위치의 로그들을 누적하여 임계치 도달 시 요약합니다.
        logger.debug(f"실행 추가됨: entry_price={entry_price}, size={size}, trade_type={trade_type}")

    def get_total_size(self) -> float:
        return sum(exec_record['size'] for exec_record in self.executions if not exec_record.get('closed', False))

    def get_average_entry_price(self) -> float:
        total_cost = sum(exec_record['entry_price'] * exec_record['size'] for exec_record in self.executions if not exec_record.get('closed', False))
        total_qty = self.get_total_size()
        return (total_cost / total_qty) if total_qty > 0 else 0.0

    def remove_execution(self, index: int):
        if 0 <= index < len(self.executions):
            self.executions.pop(index)
            logger.debug(f"실행 제거됨: index={index}")

    def is_empty(self) -> bool:
        return all(exec_record.get("closed", False) for exec_record in self.executions)

    def partial_close_execution(self, index: int, close_ratio: float, min_order_size: float = 1e-8) -> float:
        """
        부분 청산:
          - 지정된 비율만큼 포지션 청산하고, 남은 수량이 최소 주문 수량보다 작으면 해당 실행을 종료 처리합니다.
        """
        if 0 <= index < len(self.executions):
            exec_record = self.executions[index]
            qty_to_close = exec_record['size'] * close_ratio
            exec_record['size'] -= qty_to_close
            if 'exit_targets' in exec_record and exec_record['exit_targets']:
                exec_record['exit_targets'] = [t for t in exec_record['exit_targets'] if not t.get('hit', False)]
            if exec_record['size'] < min_order_size:
                exec_record['closed'] = True
            logger.debug(f"부분 청산 실행: index={index}, close_ratio={close_ratio}, 청산 수량={qty_to_close}")
            return qty_to_close
        return 0.0
