[trading]
# trading/indicators.py
import pandas as pd
from ta.trend import SMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volatility import BollingerBands

def compute_sma(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 20,
    fillna: bool = False,
    output_col: str = 'sma'
) -> pd.DataFrame:
    sma = SMAIndicator(close=data[price_column], window=period, fillna=fillna)
    data[output_col] = sma.sma_indicator()
    return data

def compute_macd(
    data: pd.DataFrame,
    price_column: str = 'close',
    slow_period: int = 26,
    fast_period: int = 12,
    signal_period: int = 9,
    fillna: bool = False,
    prefix: str = 'macd_'
) -> pd.DataFrame:
    macd = MACD(close=data[price_column],
                window_slow=slow_period,
                window_fast=fast_period,
                window_sign=signal_period,
                fillna=fillna)
    data[f'{prefix}macd'] = macd.macd()
    data[f'{prefix}signal'] = macd.macd_signal()
    data[f'{prefix}diff'] = macd.macd_diff()
    return data

def compute_rsi(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 14,
    fillna: bool = False,
    output_col: str = 'rsi'
) -> pd.DataFrame:
    rsi = RSIIndicator(close=data[price_column], window=period, fillna=fillna)
    data[output_col] = rsi.rsi()
    return data

def compute_bollinger_bands(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 20,
    std_multiplier: float = 2.0,
    fillna: bool = False,
    prefix: str = 'bb_'
) -> pd.DataFrame:
    bb = BollingerBands(close=data[price_column], window=period, window_dev=std_multiplier, fillna=fillna)
    data[f'{prefix}mavg'] = bb.bollinger_mavg()
    data[f'{prefix}hband'] = bb.bollinger_hband()
    data[f'{prefix}lband'] = bb.bollinger_lband()
    data[f'{prefix}pband'] = bb.bollinger_pband()
    data[f'{prefix}wband'] = bb.bollinger_wband()
    data[f'{prefix}hband_ind'] = bb.bollinger_hband_indicator()
    data[f'{prefix}lband_ind'] = bb.bollinger_lband_indicator()
    return data

---

# trading/positions.py
import uuid
import logging

class TradePosition:
    def __init__(self, side="LONG", initial_price: float = None, maximum_size: float = 0.0, total_splits: int = 1, allocation_plan: list = None):
        self.position_id = str(uuid.uuid4())
        self.side = side
        self.executions = []
        self.initial_price = initial_price
        self.maximum_size = maximum_size
        self.total_splits = total_splits
        self.executed_splits = 0
        self.allocation_plan = allocation_plan if allocation_plan is not None else []
        self.highest_price = initial_price if initial_price is not None else 0.0

    def add_execution(self, entry_price: float, size: float, stop_loss: float = None, take_profit: float = None, entry_time = None, exit_targets: list = None, trade_type: str = "unknown", min_order_size: float = 1e-8):
        if size < min_order_size:
            logging.info("Execution size below min_order_size; skipping execution.")
            return
        exit_targets_flagged = []
        if exit_targets is not None:
            for target_price, exit_ratio in exit_targets:
                exit_targets_flagged.append({
                    'price': target_price,
                    'exit_ratio': exit_ratio,
                    'hit': False
                })
        self.executions.append({
            'entry_price': entry_price,
            'size': size,
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'entry_time': entry_time,
            'exit_targets': exit_targets_flagged,
            'trade_type': trade_type,
            'highest_price_since_entry': entry_price
        })
        
    def get_total_size(self) -> float:
        return sum(exec_record['size'] for exec_record in self.executions)

    def get_average_entry_price(self) -> float:
        total_cost = sum(exec_record['entry_price'] * exec_record['size'] for exec_record in self.executions)
        total_qty = self.get_total_size()
        return (total_cost / total_qty) if total_qty > 0 else 0.0

    def remove_execution(self, index: int):
        if 0 <= index < len(self.executions):
            self.executions.pop(index)

    def is_empty(self) -> bool:
        return len(self.executions) == 0

    def partial_close_execution(self, index: int, close_ratio: float, min_order_size: float = 1e-8) -> float:
        if 0 <= index < len(self.executions):
            exec_record = self.executions[index]
            qty_to_close = exec_record['size'] * close_ratio
            exec_record['size'] -= qty_to_close
            if 'exit_targets' in exec_record and exec_record['exit_targets']:
                exec_record['exit_targets'] = [t for t in exec_record['exit_targets'] if not t.get('hit', False)]
            if exec_record['size'] < min_order_size:
                exec_record['closed'] = True
            return qty_to_close
        return 0.0

---

# trading/risk.py
def compute_position_size(
    account_balance: float,
    risk_percentage: float,
    entry_price: float,
    stop_loss: float,
    fee_rate: float = 0.001,
    min_order_size: float = 1e-8
) -> float:
    """
    포지션 사이즈를 계산합니다.
    stop_loss가 None인 경우, 기본적으로 entry_price의 2% 하락값을 사용합니다.
    """
    if stop_loss is None:
        stop_loss = entry_price * 0.98  # 기본값: entry_price의 2% 하락
    price_diff = abs(entry_price - stop_loss)
    max_risk = account_balance * risk_percentage
    fee_amount = entry_price * fee_rate
    loss_per_unit = price_diff + fee_amount
    computed_size = max_risk / loss_per_unit if loss_per_unit > 0 else 0.0
    return computed_size if computed_size >= min_order_size else 0.0

def allocate_position_splits(
    total_size: float,
    splits_count: int = 3,
    allocation_mode: str = 'equal',
    min_order_size: float = 1e-8
) -> list:
    """
    포지션 분할 시 각 분할의 비율을 결정합니다.
    """
    if splits_count < 1:
        raise ValueError("splits_count는 1 이상이어야 합니다.")
    if allocation_mode not in ['equal', 'pyramid_up', 'pyramid_down']:
        raise ValueError("allocation_mode는 'equal', 'pyramid_up', 'pyramid_down' 중 하나여야 합니다.")
    if total_size < min_order_size:
        return [1.0]
    if allocation_mode == 'equal':
        split_amount = 1.0 / splits_count
        return [split_amount] * splits_count
    elif allocation_mode == 'pyramid_up':
        ratio_sum = splits_count * (splits_count + 1) / 2
        return [(i / ratio_sum) for i in range(1, splits_count + 1)]
    elif allocation_mode == 'pyramid_down':
        ratio_sum = splits_count * (splits_count + 1) / 2
        return [(i / ratio_sum) for i in range(splits_count, 0, -1)]

def attempt_scale_in_position(
    position,
    current_price: float,
    scale_in_threshold: float = 0.02,
    slippage_rate: float = 0.0,
    stop_loss: float = None,
    take_profit: float = None,
    entry_time = None,
    trade_type: str = "scale_in",
    base_multiplier: float = 1.0,
    dynamic_volatility: float = 1.0
):
    """
    레짐 기반 전략에 따른 스케일‑인 포지션 진입 시도.
    """
    if position is None or position.is_empty():
        return
    while position.executed_splits < position.total_splits:
        next_split = position.executed_splits
        target_price = position.initial_price * (1.0 + scale_in_threshold * (next_split + 1)) * dynamic_volatility
        if current_price < target_price:
            break
        if next_split < len(position.allocation_plan):
            portion = position.allocation_plan[next_split]
        else:
            break
        chunk_size = position.maximum_size * portion
        executed_price = current_price * (1.0 + slippage_rate)
        position.add_execution(
            entry_price=executed_price,
            size=chunk_size,
            stop_loss=stop_loss,
            take_profit=take_profit,
            entry_time=entry_time,
            trade_type=trade_type
        )
        position.executed_splits += 1

def compute_risk_parameters_by_regime(
    base_params: dict,
    regime: str,
    liquidity: str = None,
    bullish_risk_multiplier: float = 1.1,
    bullish_atr_multiplier_factor: float = 0.9,
    bullish_profit_ratio_multiplier: float = 1.1,
    bearish_risk_multiplier: float = 0.8,
    bearish_atr_multiplier_factor: float = 1.1,
    bearish_profit_ratio_multiplier: float = 0.9,
    high_liquidity_risk_multiplier: float = 1.0,
    low_liquidity_risk_multiplier: float = 0.8,
    high_atr_multiplier_factor: float = 1.0,
    low_atr_multiplier_factor: float = 1.1,
    high_profit_ratio_multiplier: float = 1.0,
    low_profit_ratio_multiplier: float = 0.9
) -> dict:
    """
    시장 레짐에 따라 리스크 관리 파라미터를 조정합니다.
    레짐 기반 전략에 맞게 각 파라미터를 동적으로 변경합니다.
    """
    regime = regime.lower()
    risk_params = {}

    if regime == "bullish":
        risk_params['risk_per_trade'] = base_params['risk_per_trade'] * bullish_risk_multiplier
        risk_params['atr_multiplier'] = base_params['atr_multiplier'] * bullish_atr_multiplier_factor
        risk_params['profit_ratio'] = base_params['profit_ratio'] * bullish_profit_ratio_multiplier

    elif regime == "bearish":
        risk_params['risk_per_trade'] = base_params['risk_per_trade'] * bearish_risk_multiplier
        risk_params['atr_multiplier'] = base_params['atr_multiplier'] * bearish_atr_multiplier_factor
        risk_params['profit_ratio'] = base_params['profit_ratio'] * bearish_profit_ratio_multiplier

    elif regime == "sideways":
        if liquidity is None:
            raise ValueError("횡보장(regime='sideways')에서는 'liquidity' 정보를 반드시 제공해야 합니다.")
        liquidity = liquidity.lower()
        if liquidity == "high":
            risk_params['risk_per_trade'] = base_params['risk_per_trade'] * high_liquidity_risk_multiplier
            risk_params['atr_multiplier'] = base_params['atr_multiplier'] * high_atr_multiplier_factor
            risk_params['profit_ratio'] = base_params['profit_ratio'] * high_profit_ratio_multiplier
        else:
            risk_params['risk_per_trade'] = base_params['risk_per_trade'] * low_liquidity_risk_multiplier
            risk_params['atr_multiplier'] = base_params['atr_multiplier'] * low_atr_multiplier_factor
            risk_params['profit_ratio'] = base_params['profit_ratio'] * low_profit_ratio_multiplier
    else:
        raise ValueError("유효하지 않은 시장 레짐입니다. ('bullish', 'bearish', 'sideways' 중 하나여야 합니다.)")

    return risk_params

---

# trading/strategies.py
def select_strategy(market_regime: str, liquidity_info: str, data, current_time, market_type: str = "crypto") -> str:
    """
    시장 레짐 및 유동성 상태에 따라 실행할 전략을 결정합니다.
    
    - bullish: 신규 매수 진입 ("enter_long")
    - bearish: 모든 포지션 청산 ("exit_all")
    - sideways: 유동성이 높으면 범위 트레이딩, 낮으면 평균 회귀 전략 선택
    - 그 외: "hold"
    
    이 전략 선택 로직은 기존 추세 추종이 아닌 레짐 기반으로 결정됩니다.
    """
    regime = market_regime.lower()
    if regime == "bullish":
        return "enter_long"
    elif regime == "bearish":
        return "exit_all"
    elif regime == "sideways":
        if liquidity_info.lower() == "high":
            return "range_trade"
        else:
            return "mean_reversion"
    else:
        return "hold"

---

# trading/trade_management.py
import pandas as pd
import numpy as np
import ta

def calculate_atr_stop_loss(
    data: pd.DataFrame,
    atr_period: int = 14,
    atr_multiplier: float = 2.0,
    dynamic_sl_adjustment: float = 1.0,
    stop_loss_col: str = 'stop_loss_price',
    entry_price_col: str = 'entry_price',
    atr_col: str = 'atr',
    high_col: str = 'high',
    low_col: str = 'low',
    close_col: str = 'close',
    entry_signal_col: str = 'long_entry'
) -> pd.DataFrame:
    if len(data) < atr_period:
        data[atr_col] = data[high_col] - data[low_col]
    else:
        try:
            atr_indicator = ta.volatility.AverageTrueRange(
                high=data[high_col],
                low=data[low_col],
                close=data[close_col],
                window=atr_period,
                fillna=True
            )
            data[atr_col] = atr_indicator.average_true_range()
        except Exception as e:
            data[atr_col] = data[high_col] - data[low_col]
    data['close_ma'] = data[close_col].rolling(window=atr_period, min_periods=1).mean()
    data['close_std'] = data[close_col].rolling(window=atr_period, min_periods=1).std()
    data['std_ratio'] = data['close_std'] / data['close_ma']
    data['dynamic_multiplier'] = atr_multiplier * (1 + data['std_ratio'])
    data[entry_price_col] = np.where(data.get(entry_signal_col, False), data[close_col], np.nan)
    data[entry_price_col] = data[entry_price_col].ffill()
    data[stop_loss_col] = data[entry_price_col] - (data[atr_col] * data['dynamic_multiplier'] * dynamic_sl_adjustment)
    data.drop(columns=['close_ma', 'close_std', 'std_ratio', 'dynamic_multiplier'], inplace=True)
    return data

def adjust_trailing_stop(
    current_stop: float,
    current_price: float,
    highest_price: float,
    trailing_percentage: float
) -> float:
    # 만약 current_stop이 None이면, 기본값을 highest_price * (1 - trailing_percentage)로 설정
    if current_stop is None:
        current_stop = highest_price * (1 - trailing_percentage)
    new_stop = highest_price * (1.0 - trailing_percentage)
    return new_stop if new_stop > current_stop and new_stop < current_price else current_stop

def set_fixed_take_profit(
    data: pd.DataFrame,
    profit_ratio: float = 0.05,
    take_profit_col: str = 'take_profit_price',
    entry_price_col: str = 'entry_price'
) -> pd.DataFrame:
    data[take_profit_col] = data[entry_price_col] * (1 + profit_ratio)
    return data

def should_exit_trend(
    data: pd.DataFrame,
    current_time,
    window_length: int = 20,
    price_column: str = 'close'
) -> bool:
    if current_time not in data.index:
        data_sub = data.loc[:current_time]
        if len(data_sub) < window_length:
            return False
        window_data = data_sub.iloc[-window_length:]
    else:
        idx = data.index.get_loc(current_time)
        if idx < window_length:
            return False
        window_data = data.iloc[idx - window_length + 1: idx + 1]
    recent_min = window_data[price_column].min()
    current_price = data.loc[current_time, price_column] if current_time in data.index else data.iloc[-1][price_column]
    return current_price < recent_min

def calculate_partial_exit_targets(
    entry_price: float,
    partial_exit_ratio: float = 0.5,
    partial_profit_ratio: float = 0.03,
    final_profit_ratio: float = 0.06,
    final_exit_ratio: float = 1.0
):
    partial_target = entry_price * (1.0 + partial_profit_ratio)
    final_target = entry_price * (1.0 + final_profit_ratio)
    return [
        (partial_target, partial_exit_ratio),
        (final_target, final_exit_ratio)
    ]
    
def compute_atr(data: pd.DataFrame, period: int = 14) -> pd.DataFrame:
    """
    주어진 데이터프레임에 ATR 컬럼을 추가합니다.
    """
    try:
        atr_indicator = ta.volatility.AverageTrueRange(
            high=data['high'],
            low=data['low'],
            close=data['close'],
            window=period,
            fillna=True
        )
        data['atr'] = atr_indicator.average_true_range()
    except Exception as e:
        data['atr'] = data['high'] - data['low']
    return data

def calculate_dynamic_stop_and_take(entry_price: float, atr: float, risk_params: dict):
    """
    동적 리스크 관리: 시장 레짐에 따라 stop_loss와 take_profit 가격을 계산합니다.
    risk_params에는 'atr_multiplier'와 'profit_ratio'가 포함되어 있다고 가정합니다.
    """
    atr_multiplier = risk_params.get("atr_multiplier", 2.0)
    profit_ratio = risk_params.get("profit_ratio", 0.05)
    stop_loss_price = entry_price - (atr * atr_multiplier)
    take_profit_price = entry_price * (1 + profit_ratio)
    return stop_loss_price, take_profit_price
