[trading]
# trading/account.py
class Account:
    def __init__(self, initial_balance, fee_rate=0.001):
        # 초기 잔고는 모두 현물(spot) 자산으로 간주합니다.
        self.initial_balance = initial_balance
        self.spot_balance = initial_balance
        self.stablecoin_balance = 0.0
        self.fee_rate = fee_rate
        self.positions = []  # 보유 중인 포지션 리스트

    def add_position(self, position):
        self.positions.append(position)

    def remove_position(self, position):
        if position in self.positions:
            self.positions.remove(position)

    def get_used_balance(self):
        """현재 포지션들로 인해 사용된 금액 계산 (현물 잔고 기준)"""
        used = 0
        for pos in self.positions:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    used += exec_record["entry_price"] * exec_record["size"] * (1 + self.fee_rate)
        return used

    def get_available_balance(self):
        """현물 잔고에서 사용 중 금액을 제외한 가용 현금 반환"""
        return self.spot_balance - self.get_used_balance()

    def update_after_trade(self, trade):
        """체결된 거래의 pnl을 반영하여 현물 잔고 업데이트 (수익은 현물에 추가)"""
        self.spot_balance += trade.get("pnl", 0)

    def convert_to_stablecoin(self, amount, conversion_fee=0.001):
        """
        현물 자산 일부를 스테이블코인으로 전환합니다.
        (전환 수수료를 고려하여, 전환 후 현물 잔고에서 차감)
        """
        if amount > self.get_available_balance():
            amount = self.get_available_balance()
        fee = amount * conversion_fee
        net_amount = amount - fee
        self.spot_balance -= amount
        self.stablecoin_balance += net_amount
        # 로그 기록은 별도 로거를 통해 처리 가능
        return net_amount

    def convert_to_spot(self, amount, conversion_fee=0.001):
        """
        스테이블코인 일부를 현물 자산으로 전환합니다.
        """
        if amount > self.stablecoin_balance:
            amount = self.stablecoin_balance
        fee = amount * conversion_fee
        net_amount = amount - fee
        self.stablecoin_balance -= amount
        self.spot_balance += net_amount
        return net_amount

    def __str__(self):
        return (f"Account(spot_balance={self.spot_balance:.2f}, stablecoin_balance={self.stablecoin_balance:.2f}, "
                f"available_balance={self.get_available_balance():.2f})")

---

# trading/asset_manager.py
from logs.logger_config import setup_logger

class AssetManager:
    def __init__(self, account, target_allocation=None):
        """
        target_allocation: dict, 예) {"spot": 0.7, "stablecoin": 0.3}
        """
        self.account = account
        self.logger = setup_logger(__name__)
        # 기본 목표 배분: 상승장 시 현물 비중 100%, 불안정 시 스테이블코인 비중 증가
        self.target_allocation = target_allocation or {"spot": 1.0, "stablecoin": 0.0}

    def rebalance(self, market_regime):
        """
        시장 레짐에 따라 자산 배분 목표를 조정하고, 실제 계좌 자산을 재분배합니다.
        - bullish: 현물 비중 100%
        - bearish: 스테이블코인 비중 100%
        - sideways: 50:50 혹은 동적 조정 (예시로 60% 현물, 40% 스테이블)
        """
        if market_regime.lower() == "bullish":
            target = {"spot": 1.0, "stablecoin": 0.0}
        elif market_regime.lower() == "bearish":
            target = {"spot": 0.0, "stablecoin": 1.0}
        elif market_regime.lower() == "sideways":
            target = {"spot": 0.6, "stablecoin": 0.4}
        else:
            target = self.target_allocation

        self.target_allocation = target
        total_assets = self.account.spot_balance + self.account.stablecoin_balance
        desired_spot = total_assets * target["spot"]
        desired_stable = total_assets * target["stablecoin"]

        # 만약 현물 잔고가 과도하면 스테이블코인으로 전환
        if self.account.spot_balance > desired_spot:
            amount_to_convert = self.account.spot_balance - desired_spot
            converted = self.account.convert_to_stablecoin(amount_to_convert)
            self.logger.info(f"Rebalancing: Converted {converted:.2f} from spot to stablecoin.")
        # 반대로 스테이블코인이 과도하면 현물로 전환
        elif self.account.spot_balance < desired_spot:
            amount_to_convert = desired_spot - self.account.spot_balance
            converted = self.account.convert_to_spot(amount_to_convert)
            self.logger.info(f"Rebalancing: Converted {converted:.2f} from stablecoin to spot.")
        else:
            self.logger.info("Rebalancing: No conversion needed.")

        self.logger.info(f"Post-rebalance Account: {self.account}")

---

# trading/ensemble_manager.py
from logs.logger_config import setup_logger
from trading.strategies import TradingStrategies

class EnsembleManager:
    def __init__(self):
        self.logger = setup_logger(__name__)
        # 초기 가중치는 동일하게 설정 (추후 실제 성과 기반 업데이트 가능)
        self.strategy_weights = {
            "base": 1.0,
            "trend_following": 1.0,
            "breakout": 1.0,
            "counter_trend": 1.0,
            "high_frequency": 1.0
        }
        self.strategy_manager = TradingStrategies()
    
    def get_final_signal(self, market_regime, liquidity_info, data, current_time):
        """
        여러 전략의 신호를 개별 호출한 후, 가중치 기반 투표로 최종 거래 신호를 결정하여 반환합니다.
        """
        signals = {}
        signals["base"] = self.strategy_manager.select_strategy(market_regime, liquidity_info, data, current_time)
        signals["trend_following"] = self.strategy_manager.trend_following_strategy(data, current_time)
        signals["breakout"] = self.strategy_manager.breakout_strategy(data, current_time)
        signals["counter_trend"] = self.strategy_manager.counter_trend_strategy(data, current_time)
        signals["high_frequency"] = self.strategy_manager.high_frequency_strategy(data, current_time)
        
        vote_enter = 0.0
        vote_exit = 0.0
        for key, signal in signals.items():
            weight = self.strategy_weights.get(key, 1.0)
            if signal == "enter_long":
                vote_enter += weight
            elif signal == "exit_all":
                vote_exit += weight
        
        if vote_exit > vote_enter:
            final_signal = "exit_all"
        elif vote_enter > vote_exit:
            final_signal = "enter_long"
        else:
            final_signal = "hold"
        
        self.logger.info(f"EnsembleManager final signal at {current_time}: {final_signal}, details: {signals}")
        return final_signal

    def update_strategy_weights(self, performance_metrics):
        """
        실시간 성과 지표(performance_metrics)에 따라 각 전략의 가중치를 조정합니다.
        (구현 예시 – 상세 로직은 실제 피드백 루프에 맞게 확장)
        """
        for strat, perf in performance_metrics.items():
            if perf < 0:
                self.strategy_weights[strat] *= 0.95
            else:
                self.strategy_weights[strat] *= 1.05
        self.logger.info(f"Updated strategy weights: {self.strategy_weights}")

---

# trading/indicators.py
import pandas as pd
from ta.trend import SMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volatility import BollingerBands

def compute_sma(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 20,
    fillna: bool = False,
    output_col: str = 'sma'
) -> pd.DataFrame:
    sma = SMAIndicator(close=data[price_column], window=period, fillna=fillna)
    data[output_col] = sma.sma_indicator()
    return data

def compute_macd(
    data: pd.DataFrame,
    price_column: str = 'close',
    slow_period: int = 26,
    fast_period: int = 12,
    signal_period: int = 9,
    fillna: bool = False,
    prefix: str = 'macd_'
) -> pd.DataFrame:
    macd = MACD(close=data[price_column],
                window_slow=slow_period,
                window_fast=fast_period,
                window_sign=signal_period,
                fillna=fillna)
    data[f'{prefix}macd'] = macd.macd()
    data[f'{prefix}signal'] = macd.macd_signal()
    data[f'{prefix}diff'] = macd.macd_diff()
    return data

def compute_rsi(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 14,
    fillna: bool = False,
    output_col: str = 'rsi'
) -> pd.DataFrame:
    rsi = RSIIndicator(close=data[price_column], window=period, fillna=fillna)
    data[output_col] = rsi.rsi()
    return data

def compute_bollinger_bands(
    data: pd.DataFrame,
    price_column: str = 'close',
    period: int = 20,
    std_multiplier: float = 2.0,
    fillna: bool = False,
    prefix: str = 'bb_'
) -> pd.DataFrame:
    bb = BollingerBands(close=data[price_column], window=period, window_dev=std_multiplier, fillna=fillna)
    data[f'{prefix}mavg'] = bb.bollinger_mavg()
    data[f'{prefix}hband'] = bb.bollinger_hband()
    data[f'{prefix}lband'] = bb.bollinger_lband()
    data[f'{prefix}pband'] = bb.bollinger_pband()
    data[f'{prefix}wband'] = bb.bollinger_wband()
    data[f'{prefix}hband_ind'] = bb.bollinger_hband_indicator()
    data[f'{prefix}lband_ind'] = bb.bollinger_lband_indicator()
    return data

---

# trading/positions.py
import uuid
import logging

class TradePosition:
    def __init__(self, side="LONG", initial_price: float = None, maximum_size: float = 0.0, total_splits: int = 1, allocation_plan: list = None):
        self.position_id = str(uuid.uuid4())
        self.side = side
        self.executions = []
        self.initial_price = initial_price
        self.maximum_size = maximum_size
        self.total_splits = total_splits
        self.executed_splits = 0
        self.allocation_plan = allocation_plan if allocation_plan is not None else []
        self.highest_price = initial_price if initial_price is not None else 0.0

    def add_execution(self, entry_price: float, size: float, stop_loss: float = None, take_profit: float = None, entry_time = None, exit_targets: list = None, trade_type: str = "unknown", min_order_size: float = 1e-8):
        if size < min_order_size:
            logging.info("Execution size below min_order_size; skipping execution.")
            return
        exit_targets_flagged = []
        if exit_targets is not None:
            for target_price, exit_ratio in exit_targets:
                exit_targets_flagged.append({
                    'price': target_price,
                    'exit_ratio': exit_ratio,
                    'hit': False
                })
        self.executions.append({
            'entry_price': entry_price,
            'size': size,
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'entry_time': entry_time,
            'exit_targets': exit_targets_flagged,
            'trade_type': trade_type,
            'highest_price_since_entry': entry_price
        })
        
    def get_total_size(self) -> float:
        return sum(exec_record['size'] for exec_record in self.executions)

    def get_average_entry_price(self) -> float:
        total_cost = sum(exec_record['entry_price'] * exec_record['size'] for exec_record in self.executions)
        total_qty = self.get_total_size()
        return (total_cost / total_qty) if total_qty > 0 else 0.0

    def remove_execution(self, index: int):
        if 0 <= index < len(self.executions):
            self.executions.pop(index)

    def is_empty(self) -> bool:
        return len(self.executions) == 0

    def partial_close_execution(self, index: int, close_ratio: float, min_order_size: float = 1e-8) -> float:
        if 0 <= index < len(self.executions):
            exec_record = self.executions[index]
            qty_to_close = exec_record['size'] * close_ratio
            exec_record['size'] -= qty_to_close
            if 'exit_targets' in exec_record and exec_record['exit_targets']:
                exec_record['exit_targets'] = [t for t in exec_record['exit_targets'] if not t.get('hit', False)]
            if exec_record['size'] < min_order_size:
                exec_record['closed'] = True
            return qty_to_close
        return 0.0

---

# trading/risk_manager.py
class RiskManager:
    @staticmethod
    def compute_position_size(
        available_balance: float,
        risk_percentage: float,
        entry_price: float,
        stop_loss: float,
        fee_rate: float = 0.001,
        min_order_size: float = 1e-8,
        volatility: float = 0.0
    ) -> float:
        """
        포지션 사이즈를 계산합니다.
        - stop_loss가 None인 경우 entry_price의 2% 하락값을 사용합니다.
        - volatility가 클수록 포지션 사이즈를 축소합니다.
        """
        if stop_loss is None:
            stop_loss = entry_price * 0.98  # 기본: entry_price의 2% 하락
        price_diff = abs(entry_price - stop_loss)
        max_risk = available_balance * risk_percentage
        fee_amount = entry_price * fee_rate
        loss_per_unit = price_diff + fee_amount
        computed_size = max_risk / loss_per_unit if loss_per_unit > 0 else 0.0

        # 변동성이 높을 경우 포지션 사이징 축소
        if volatility > 0:
            computed_size /= (1 + volatility)
        
        return computed_size if computed_size >= min_order_size else 0.0

    @staticmethod
    def allocate_position_splits(
        total_size: float,
        splits_count: int = 3,
        allocation_mode: str = 'equal',
        min_order_size: float = 1e-8
    ) -> list:
        """
        포지션 분할 시 각 분할의 비율을 결정합니다.
        """
        if splits_count < 1:
            raise ValueError("splits_count는 1 이상이어야 합니다.")
        if allocation_mode not in ['equal', 'pyramid_up', 'pyramid_down']:
            raise ValueError("allocation_mode는 'equal', 'pyramid_up', 'pyramid_down' 중 하나여야 합니다.")
        if total_size < min_order_size:
            return [1.0]
        if allocation_mode == 'equal':
            split_amount = 1.0 / splits_count
            return [split_amount] * splits_count
        elif allocation_mode == 'pyramid_up':
            ratio_sum = splits_count * (splits_count + 1) / 2
            return [i / ratio_sum for i in range(1, splits_count + 1)]
        elif allocation_mode == 'pyramid_down':
            ratio_sum = splits_count * (splits_count + 1) / 2
            return [i / ratio_sum for i in range(splits_count, 0, -1)]

    @staticmethod
    def attempt_scale_in_position(
        position,
        current_price: float,
        scale_in_threshold: float = 0.02,
        slippage_rate: float = 0.0,
        stop_loss: float = None,
        take_profit: float = None,
        entry_time = None,
        trade_type: str = "scale_in",
        base_multiplier: float = 1.0,
        dynamic_volatility: float = 1.0
    ):
        """
        레짐 기반 전략에 따른 스케일‑인 포지션 진입 시도.
        """
        if position is None or position.is_empty():
            return
        while position.executed_splits < position.total_splits:
            next_split = position.executed_splits
            target_price = position.initial_price * (1.0 + scale_in_threshold * (next_split + 1)) * dynamic_volatility
            if current_price < target_price:
                break
            if next_split < len(position.allocation_plan):
                portion = position.allocation_plan[next_split]
            else:
                break
            chunk_size = position.maximum_size * portion
            executed_price = current_price * (1.0 + slippage_rate)
            position.add_execution(
                entry_price=executed_price,
                size=chunk_size,
                stop_loss=stop_loss,
                take_profit=take_profit,
                entry_time=entry_time,
                trade_type=trade_type
            )
            position.executed_splits += 1

    @staticmethod
    def compute_risk_parameters_by_regime(
        base_params: dict,
        regime: str,
        liquidity: str = None,
        bullish_risk_multiplier: float = 1.1,
        bullish_atr_multiplier_factor: float = 0.9,
        bullish_profit_ratio_multiplier: float = 1.1,
        bearish_risk_multiplier: float = 0.8,
        bearish_atr_multiplier_factor: float = 1.1,
        bearish_profit_ratio_multiplier: float = 0.9,
        high_liquidity_risk_multiplier: float = 1.0,
        low_liquidity_risk_multiplier: float = 0.8,
        high_atr_multiplier_factor: float = 1.0,
        low_atr_multiplier_factor: float = 1.1,
        high_profit_ratio_multiplier: float = 1.0,
        low_profit_ratio_multiplier: float = 0.9
    ) -> dict:
        """
        시장 레짐에 따라 리스크 관리 파라미터를 동적으로 조정합니다.
        """
        regime = regime.lower()
        risk_params = {}

        if regime == "bullish":
            risk_params['risk_per_trade'] = base_params['risk_per_trade'] * bullish_risk_multiplier
            risk_params['atr_multiplier'] = base_params['atr_multiplier'] * bullish_atr_multiplier_factor
            risk_params['profit_ratio'] = base_params['profit_ratio'] * bullish_profit_ratio_multiplier

        elif regime == "bearish":
            risk_params['risk_per_trade'] = base_params['risk_per_trade'] * bearish_risk_multiplier
            risk_params['atr_multiplier'] = base_params['atr_multiplier'] * bearish_atr_multiplier_factor
            risk_params['profit_ratio'] = base_params['profit_ratio'] * bearish_profit_ratio_multiplier

        elif regime == "sideways":
            if liquidity is None:
                raise ValueError("횡보장(regime='sideways')에서는 'liquidity' 정보를 반드시 제공해야 합니다.")
            liquidity = liquidity.lower()
            if liquidity == "high":
                risk_params['risk_per_trade'] = base_params['risk_per_trade'] * high_liquidity_risk_multiplier
                risk_params['atr_multiplier'] = base_params['atr_multiplier'] * high_atr_multiplier_factor
                risk_params['profit_ratio'] = base_params['profit_ratio'] * high_profit_ratio_multiplier
            else:
                risk_params['risk_per_trade'] = base_params['risk_per_trade'] * low_liquidity_risk_multiplier
                risk_params['atr_multiplier'] = base_params['atr_multiplier'] * low_atr_multiplier_factor
                risk_params['profit_ratio'] = base_params['profit_ratio'] * low_profit_ratio_multiplier
        else:
            raise ValueError("유효하지 않은 시장 레짐입니다. ('bullish', 'bearish', 'sideways' 중 하나여야 합니다.)")

        # 추가: 현재 변동성에 따른 risk_per_trade 동적 조정
        current_volatility = base_params.get("current_volatility", None)
        if current_volatility is not None:
            if current_volatility > 0.05:
                risk_params['risk_per_trade'] *= 0.8
            else:
                risk_params['risk_per_trade'] *= 1.1

        return risk_params

---

# trading/strategies.py
from logs.logger_config import setup_logger

class TradingStrategies:
    def __init__(self):
        self.logger = setup_logger(__name__)
    
    def select_strategy(self, market_regime: str, liquidity_info: str, data, current_time, market_type: str = "crypto") -> str:
        """
        기본 전략 선택:
        - 기술적 지표(SMA, RSI, Bollinger Bands 등)와 캔들 패턴을 기반으로 신호를 생성합니다.
        """
        regime = market_regime.lower()
        try:
            current_row = data.loc[current_time]
        except Exception:
            current_row = {}
        
        sma = current_row.get('sma', None)
        rsi = current_row.get('rsi', None)
        bb_lband = current_row.get('bb_lband', None)
        
        candle_pattern_signal = None
        if current_row.get('open') and current_row.get('close'):
            if current_row['close'] > current_row['open'] * 1.01:
                candle_pattern_signal = "bullish"
            elif current_row['close'] < current_row['open'] * 0.99:
                candle_pattern_signal = "bearish"
        
        previous_sma = sma
        previous_rows = data.loc[:current_time]
        if len(previous_rows) > 1:
            previous_sma = previous_rows.iloc[-2].get('sma', sma)
        
        if regime == "bullish":
            if (sma is not None and previous_sma is not None and sma > previous_sma and rsi is not None and rsi < 30) \
                or (candle_pattern_signal == "bullish") \
                or (bb_lband is not None and current_row.get('close', 0) <= bb_lband):
                return "enter_long"
            else:
                return "hold"
        elif regime == "bearish":
            return "exit_all"
        elif regime == "sideways":
            if liquidity_info.lower() == "high":
                return "range_trade"
            else:
                return "mean_reversion"
        else:
            return "hold"
    
    def trend_following_strategy(self, data, current_time):
        """
        추세 추종 전략:
        - 현재 가격이 단순 이동평균(SMA) 위에 있으면 매수 신호를 반환합니다.
        """
        try:
            row = data.loc[current_time]
        except Exception:
            return None
        sma = row.get('sma')
        price = row.get('close')
        if sma is not None and price is not None and price > sma:
            return "enter_long"
        return "hold"
    
    def breakout_strategy(self, data, current_time, window=20):
        """
        돌파 전략:
        - 최근 window 기간 내 최고가를 돌파하면 매수 신호를 반환합니다.
        """
        data_sub = data.loc[:current_time]
        if len(data_sub) < window:
            return None
        recent_high = data_sub['high'].iloc[-window:].max()
        price = data.loc[current_time, 'close']
        if price > recent_high:
            return "enter_long"
        return "hold"
    
    def counter_trend_strategy(self, data, current_time):
        """
        역추세 전략:
        - RSI가 과매도(예: 30 이하)인 경우 매수, 과매수(70 이상)일 경우 청산 신호를 반환합니다.
        """
        try:
            row = data.loc[current_time]
        except Exception:
            return None
        rsi = row.get('rsi')
        if rsi is not None:
            if rsi < 30:
                return "enter_long"
            elif rsi > 70:
                return "exit_all"
        return "hold"
    
    def high_frequency_strategy(self, data, current_time):
        """
        고빈도 전략:
        - 단기 차트(예: 15분 혹은 1시간봉) 데이터를 사용하여 미세한 가격 변동(예: 0.2% 이상 상승 또는 하락)을 포착합니다.
        - 상승 변동 시 매수("enter_long"), 하락 변동 시 청산("exit_all") 신호를 반환하며, 그 외엔 "hold"를 반환합니다.
        """
        try:
            current_index = data.index.get_loc(current_time)
            if current_index == 0:
                return "hold"
            prev_time = data.index[current_index - 1]
            current_row = data.loc[current_time]
            prev_row = data.loc[prev_time]
        except Exception as e:
            self.logger.error(f"High frequency strategy error: {e}")
            return "hold"
        
        current_price = current_row.get('close')
        prev_price = prev_row.get('close')
        if current_price is None or prev_price is None:
            return "hold"
        
        threshold = 0.002  # 0.2% 임계치
        price_change = (current_price - prev_price) / prev_price
        if price_change > threshold:
            return "enter_long"
        elif price_change < -threshold:
            return "exit_all"
        return "hold"

---

# trading/trade_manager.py
import pandas as pd
import numpy as np
import ta

class TradeManager:
    @staticmethod
    def calculate_atr_stop_loss(
        data: pd.DataFrame,
        atr_period: int = 14,
        atr_multiplier: float = 2.0,
        dynamic_sl_adjustment: float = 1.0,
        stop_loss_col: str = 'stop_loss_price',
        entry_price_col: str = 'entry_price',
        atr_col: str = 'atr',
        high_col: str = 'high',
        low_col: str = 'low',
        close_col: str = 'close',
        entry_signal_col: str = 'long_entry'
    ) -> pd.DataFrame:
        """
        ATR 기반 동적 스탑로스 계산.
        """
        if len(data) < atr_period:
            data[atr_col] = data[high_col] - data[low_col]
        else:
            try:
                atr_indicator = ta.volatility.AverageTrueRange(
                    high=data[high_col],
                    low=data[low_col],
                    close=data[close_col],
                    window=atr_period,
                    fillna=True
                )
                data[atr_col] = atr_indicator.average_true_range()
            except Exception as e:
                data[atr_col] = data[high_col] - data[low_col]
        data['close_ma'] = data[close_col].rolling(window=atr_period, min_periods=1).mean()
        data['close_std'] = data[close_col].rolling(window=atr_period, min_periods=1).std()
        data['std_ratio'] = data['close_std'] / data['close_ma']
        data['dynamic_multiplier'] = atr_multiplier * (1 + data['std_ratio'])
        data[entry_price_col] = np.where(data.get(entry_signal_col, False), data[close_col], np.nan)
        data[entry_price_col] = data[entry_price_col].ffill()
        data[stop_loss_col] = data[entry_price_col] - (data[atr_col] * data['dynamic_multiplier'] * dynamic_sl_adjustment)
        data.drop(columns=['close_ma', 'close_std', 'std_ratio', 'dynamic_multiplier'], inplace=True)
        return data

    @staticmethod
    def adjust_trailing_stop(
        current_stop: float,
        current_price: float,
        highest_price: float,
        trailing_percentage: float,
        volatility: float = 0.0
    ) -> float:
        """
        트레일링 스탑 조정.
        """
        if current_stop is None:
            current_stop = highest_price * (1 - trailing_percentage * (1 + volatility))
        new_stop = highest_price * (1.0 - trailing_percentage * (1 + volatility))
        return new_stop if new_stop > current_stop and new_stop < current_price else current_stop

    @staticmethod
    def set_fixed_take_profit(
        data: pd.DataFrame,
        profit_ratio: float = 0.05,
        take_profit_col: str = 'take_profit_price',
        entry_price_col: str = 'entry_price'
    ) -> pd.DataFrame:
        """
        고정 이익 실현 목표치 설정.
        """
        data[take_profit_col] = data[entry_price_col] * (1 + profit_ratio)
        return data

    @staticmethod
    def should_exit_trend(
        data: pd.DataFrame,
        current_time,
        window_length: int = 20,
        price_column: str = 'close'
    ) -> bool:
        """
        최근 가격 움직임에 따라 추세 청산 여부 결정.
        """
        if current_time not in data.index:
            data_sub = data.loc[:current_time]
            if len(data_sub) < window_length:
                return False
            window_data = data_sub.iloc[-window_length:]
        else:
            idx = data.index.get_loc(current_time)
            if idx < window_length:
                return False
            window_data = data.iloc[idx - window_length + 1: idx + 1]
        recent_min = window_data[price_column].min()
        current_price = data.loc[current_time, price_column] if current_time in data.index else data.iloc[-1][price_column]
        return current_price < recent_min

    @staticmethod
    def calculate_partial_exit_targets(
        entry_price: float,
        partial_exit_ratio: float = 0.5,
        partial_profit_ratio: float = 0.03,
        final_profit_ratio: float = 0.06,
        final_exit_ratio: float = 1.0
    ):
        """
        부분 청산 목표 가격 계산.
        """
        partial_target = entry_price * (1.0 + partial_profit_ratio)
        final_target = entry_price * (1.0 + final_profit_ratio)
        return [
            (partial_target, partial_exit_ratio),
            (final_target, final_exit_ratio)
        ]

    @staticmethod
    def compute_atr(data: pd.DataFrame, period: int = 14) -> pd.DataFrame:
        """
        주어진 데이터에 대해 ATR 지표 계산.
        """
        try:
            atr_indicator = ta.volatility.AverageTrueRange(
                high=data['high'],
                low=data['low'],
                close=data['close'],
                window=period,
                fillna=True
            )
            data['atr'] = atr_indicator.average_true_range()
        except Exception as e:
            data['atr'] = data['high'] - data['low']
        return data

    @staticmethod
    def calculate_dynamic_stop_and_take(
        entry_price: float,
        atr: float,
        risk_params: dict
    ):
        """
        ATR 및 리스크 파라미터에 따른 동적 스탑로스와 테이크 프로핏 가격 계산.
        """
        atr_multiplier = risk_params.get("atr_multiplier", 2.0)
        profit_ratio = risk_params.get("profit_ratio", 0.05)
        volatility_multiplier = risk_params.get("volatility_multiplier", 1.0)
        stop_loss_price = entry_price - (atr * atr_multiplier * volatility_multiplier)
        take_profit_price = entry_price * (1 + profit_ratio)
        return stop_loss_price, take_profit_price
