[backtesting]
# backtesting/backtester.py
import pandas as pd
import numpy as np
import logging

from trading.positions import TradePosition
from trading.signals import generate_breakout_signals, generate_retest_signals, filter_long_trend_relaxed
from trading.trade_management import (
    calculate_atr_stop_loss, adjust_trailing_stop, set_fixed_take_profit,
    should_exit_trend, calculate_partial_exit_targets
)
from trading.risk import compute_position_size, allocate_position_splits, attempt_scale_in_position
from backtesting.performance import print_performance_report
from dynamic_parameters.dynamic_param_manager import DynamicParamManager
from data_collection.db_manager import fetch_ohlcv_records

class Backtester:
    def __init__(self, symbol="BTC/USDT", account_size=10000.0, fee_rate=0.001, slippage_rate=0.0005, final_exit_slippage=0.0):
        self.symbol = symbol
        self.account_size = account_size
        self.fee_rate = fee_rate
        self.slippage_rate = slippage_rate
        self.final_exit_slippage = final_exit_slippage
        self.positions = []
        self.trades = []
        self.trade_logs = []
        self.logger = logging.getLogger(self.__class__.__name__)
        # 동적 파라미터 관리 매니저
        self.dynamic_param_manager = DynamicParamManager()

    def load_data(self, short_table_format, long_table_format, short_tf, long_tf, start_date=None, end_date=None):
        symbol_for_table = self.symbol.replace('/', '').lower()
        short_table = short_table_format.format(symbol=symbol_for_table, timeframe=short_tf)
        long_table = long_table_format.format(symbol=symbol_for_table, timeframe=long_tf)
        self.df_short = fetch_ohlcv_records(short_table, start_date, end_date)
        self.df_long = fetch_ohlcv_records(long_table, start_date, end_date)
        if self.df_short.empty or self.df_long.empty:
            self.logger.error("데이터 로드 실패: 데이터가 비어있습니다.")
            raise ValueError("No data loaded")
        self.df_short.sort_index(inplace=True)
        self.df_long.sort_index(inplace=True)
    
    def run_backtest(self, dynamic_params=None):
        if dynamic_params is None:
            dynamic_params = self.dynamic_param_manager.get_default_params()
        
        # 1. 매매 신호 생성 (돌파 및 리테스트) 및 신호 충돌 방지
        self.df_short = generate_breakout_signals(
            data=self.df_short,
            lookback_window=dynamic_params['lookback_window'],
            volume_factor=dynamic_params['volume_factor'],
            confirmation_bars=dynamic_params['confirmation_bars'],
            breakout_buffer=dynamic_params['breakout_buffer'],
            breakout_flag_col="breakout_signal",
            confirmed_breakout_flag_col="confirmed_breakout"
        )
        self.df_short = generate_retest_signals(
            data=self.df_short,
            retest_threshold=dynamic_params['retest_threshold'],
            confirmation_bars=dynamic_params['retest_confirmation_bars'],
            breakout_reference_col=f"highest_{dynamic_params['lookback_window']}",
            breakout_signal_col="breakout_signal",
            retest_signal_col="retest_signal"
        )
        # 신호 충돌 해결: 리테스트 신호가 있으면 돌파 신호는 무시
        self.df_short["final_entry_signal"] = self.df_short["confirmed_breakout"] & (~self.df_short["retest_signal"])
        
        self.df_long = filter_long_trend_relaxed(
            data=self.df_long,
            sma_period=dynamic_params['sma_period'],
            macd_slow_period=dynamic_params['macd_slow_period'],
            macd_fast_period=dynamic_params['macd_fast_period'],
            macd_signal_period=dynamic_params['macd_signal_period'],
            rsi_period=dynamic_params['rsi_period'],
            rsi_threshold=dynamic_params['rsi_threshold'],
            bb_period=dynamic_params['bb_period'],
            bb_std_multiplier=dynamic_params['bb_std_multiplier'],
            macd_diff_threshold=dynamic_params['macd_diff_threshold']
        )
        self.df_long = self.df_long.reindex(self.df_short.index, method='ffill')
        
        # 2. 신호 결합 – entry_signal_mode ("AND" 또는 "OR")에 따라 결합
        entry_signal_mode = dynamic_params.get("entry_signal_mode", "AND")
        if entry_signal_mode == "AND":
            self.df_short['combined_entry'] = self.df_short["final_entry_signal"] & self.df_long['long_filter_pass']
        elif entry_signal_mode == "OR":
            self.df_short['combined_entry'] = self.df_short["final_entry_signal"] | self.df_long['long_filter_pass']
        else:
            self.df_short['combined_entry'] = self.df_short["final_entry_signal"]
        
        # 3. 리스크 관리 – ATR 기반 손절과 고정 익절 (동적 조정 포함)
        self.df_short = calculate_atr_stop_loss(
            data=self.df_short,
            atr_period=dynamic_params['atr_period'],
            atr_multiplier=dynamic_params['atr_multiplier'],
            dynamic_sl_adjustment=dynamic_params['dynamic_sl_adjustment'],
            stop_loss_col="stop_loss_price",
            entry_price_col="entry_price",
            entry_signal_col="combined_entry"
        )
        self.df_short = set_fixed_take_profit(
            data=self.df_short,
            profit_ratio=dynamic_params['profit_ratio'],
            take_profit_col="take_profit_price",
            entry_price_col="entry_price"
        )
        
        # 4. 백테스트 메인 루프 – 시간별 체결/청산 처리 (우선순위: 손절 > 익절 > 추세청산 > 부분청산)
        for current_time, row in self.df_short.iterrows():
            self.process_time_step(current_time, row, dynamic_params)
        
        # 5. 최종 미청산 포지션 강제 청산 (최종 슬리피지와 수수료 적용)
        final_time = self.df_short.index[-1]
        final_close = self.df_short.iloc[-1]["close"]
        adjusted_final_close = final_close * (1 - self.final_exit_slippage) if self.final_exit_slippage else final_close
        for pos in self.positions:
            for exec_record in pos.executions:
                if not exec_record.get("closed", False):
                    exit_price = adjusted_final_close * (1 - self.slippage_rate)
                    fee = exit_price * exec_record["size"] * self.fee_rate
                    pnl = (exit_price - exec_record["entry_price"]) * exec_record["size"] - fee
                    exec_record["closed"] = True
                    trade_detail = {
                        "entry_time": exec_record["entry_time"],
                        "entry_price": exec_record["entry_price"],
                        "exit_time": final_time,
                        "exit_price": exit_price,
                        "size": exec_record["size"],
                        "pnl": pnl,
                        "reason": "final_exit",
                        "trade_type": exec_record.get("trade_type", "unknown"),
                        "position_id": pos.position_id
                    }
                    self.trade_logs.append(trade_detail)
                    self.trades.append(trade_detail)
        
        return self.trades, self.trade_logs

    def process_time_step(self, current_time, row, params):
        close_price = row["close"]
        high_price = row["high"]
        low_price = row["low"]
        computed_stop_loss = row["stop_loss_price"]
        computed_take_profit = row["take_profit_price"]

        # 우선순위: 1) 손절, 2) 익절, 3) 추세 청산, 4) 부분 청산
        positions_to_remove = []
        for pos in self.positions:
            executions_to_close = []
            for i, exec_record in enumerate(pos.executions):
                if exec_record.get("closed", False):
                    continue
                ep = exec_record["entry_price"]
                size = exec_record["size"]
                exit_triggered = False
                exit_price = None
                exit_reason = None

                # (1) 손절 조건 – 슬리피지 적용
                if low_price <= computed_stop_loss:
                    exit_triggered = True
                    exit_price = computed_stop_loss * (1 - self.slippage_rate)
                    exit_reason = "stop_loss"
                # (2) 익절 조건 – 유리한 슬리피지 모형
                elif computed_take_profit and high_price >= computed_take_profit:
                    exit_triggered = True
                    exit_price = computed_take_profit * (1 + self.slippage_rate)
                    exit_reason = "take_profit"
                # (3) 추세 청산 조건
                elif params.get("use_trend_exit", False) and should_exit_trend(self.df_long, current_time):
                    exit_triggered = True
                    exit_price = close_price * (1 - self.slippage_rate)
                    exit_reason = "trend_exit"
                # (4) 부분 청산 조건 (우선순위 최하)
                elif params.get("use_partial_take_profit", False) and "exit_targets" in exec_record:
                    for target in exec_record["exit_targets"]:
                        if not target.get("hit", False) and high_price >= target["price"]:
                            target["hit"] = True
                            partial_ratio = target["exit_ratio"]
                            closed_qty = size * partial_ratio
                            exec_record["size"] -= closed_qty
                            fee = target["price"] * closed_qty * self.fee_rate
                            pnl = (target["price"] - ep) * closed_qty - fee
                            trade_detail = {
                                "entry_time": exec_record["entry_time"],
                                "entry_price": ep,
                                "exit_time": current_time,
                                "exit_price": target["price"],
                                "size": closed_qty,
                                "pnl": pnl,
                                "reason": "partial_exit",
                                "trade_type": exec_record.get("trade_type", "unknown"),
                                "position_id": pos.position_id
                            }
                            self.trade_logs.append(trade_detail)
                            self.trades.append(trade_detail)
                            if exec_record["size"] < 1e-8:
                                exec_record["closed"] = True
                            break

                if exit_triggered:
                    exec_record["closed"] = True
                    fee = exit_price * size * self.fee_rate
                    pnl = (exit_price - ep) * size - fee
                    trade_detail = {
                        "entry_time": exec_record["entry_time"],
                        "entry_price": ep,
                        "exit_time": current_time,
                        "exit_price": exit_price,
                        "size": size,
                        "pnl": pnl,
                        "reason": exit_reason,
                        "trade_type": exec_record.get("trade_type", "unknown"),
                        "position_id": pos.position_id
                    }
                    self.trade_logs.append(trade_detail)
                    self.trades.append(trade_detail)
                    executions_to_close.append(i)
            for i in sorted(executions_to_close, reverse=True):
                pos.executions.pop(i)
            if pos.is_empty():
                positions_to_remove.append(pos)
        for pos in positions_to_remove:
            self.positions.remove(pos)
        
        # 신규 진입 또는 스케일인 – 만약 기존 포지션이 없으면 신규 포지션 생성, 있다면 scale‑in 시도
        if row.get("combined_entry", False):
            scaled_in = False
            for pos in self.positions:
                if pos.side == "LONG":
                    attempt_scale_in_position(
                        position=pos,
                        current_price=close_price,
                        scale_in_threshold=params.get("scale_in_threshold", 0.02),
                        slippage_rate=self.slippage_rate,
                        stop_loss=computed_stop_loss,
                        take_profit=computed_take_profit,
                        entry_time=current_time,
                        trade_type="scale_in"
                    )
                    scaled_in = True
            if not scaled_in:
                from trading.risk import compute_position_size, allocate_position_splits
                new_position = TradePosition(
                    side="LONG",
                    initial_price=close_price,
                    maximum_size=0.0,
                    total_splits=params.get("total_splits", 3),
                    allocation_plan=[]
                )
                new_position.highest_price = close_price
                total_size = compute_position_size(
                    account_balance=self.account_size,
                    risk_percentage=params.get("risk_per_trade", 0.01),
                    entry_price=close_price,
                    stop_loss=computed_stop_loss,
                    fee_rate=self.fee_rate
                )
                new_position.maximum_size = total_size
                plan = allocate_position_splits(
                    total_size=1.0,
                    splits_count=params.get("total_splits", 3),
                    allocation_mode=params.get("allocation_mode", "equal")
                )
                new_position.allocation_plan = plan
                buy_size = total_size * plan[0]
                exit_targets = calculate_partial_exit_targets(
                    entry_price=close_price,
                    partial_exit_ratio=params.get("partial_tp_factor", 0.03),
                    final_profit_ratio=params.get("final_tp_factor", 0.06)
                )
                # 진입 시 슬리피지 적용
                executed_price = close_price * (1 + self.slippage_rate)
                new_position.add_execution(
                    entry_price=executed_price,
                    size=buy_size,
                    stop_loss=computed_stop_loss,
                    take_profit=computed_take_profit,
                    entry_time=current_time,
                    exit_targets=exit_targets,
                    trade_type="new_entry"
                )
                new_position.executed_splits = 1
                self.positions.append(new_position)

---

# backtesting/optimizer.py
import optuna
from backtesting.backtester import Backtester
from dynamic_parameters.dynamic_param_manager import DynamicParamManager
import pandas as pd

class DynamicParameterOptimizer:
    def __init__(self, n_trials=50):
        self.n_trials = n_trials
        self.study = None
        self.dynamic_param_manager = DynamicParamManager()
    
    def objective(self, trial):
        # 기본 파라미터에 trial 제안 값 적용
        params = self.dynamic_param_manager.get_default_params()
        params["lookback_window"] = trial.suggest_int("lookback_window", 10, 30)
        params["volume_factor"] = trial.suggest_float("volume_factor", 1.2, 2.0)
        params["confirmation_bars"] = trial.suggest_int("confirmation_bars", 1, 3)
        params["breakout_buffer"] = trial.suggest_float("breakout_buffer", 0.0, 0.005)
        params["atr_multiplier"] = trial.suggest_float("atr_multiplier", 1.5, 3.0)
        params["profit_ratio"] = trial.suggest_float("profit_ratio", 0.05, 0.15)
        params["risk_per_trade"] = trial.suggest_float("risk_per_trade", 0.005, 0.02)
        params["scale_in_threshold"] = trial.suggest_float("scale_in_threshold", 0.01, 0.03)
        params["use_trend_exit"] = trial.suggest_categorical("use_trend_exit", [True, False])
        params["use_partial_take_profit"] = trial.suggest_categorical("use_partial_take_profit", [True, False])
        params["entry_signal_mode"] = trial.suggest_categorical("entry_signal_mode", ["AND", "OR"])
        
        # 워크-포워드 테스트: 데이터의 70%는 학습(백테스트)용, 30%는 검증용으로 분리
        backtester = Backtester(symbol="BTC/USDT", account_size=10000)
        # 예시 기간 (2018-01-01 ~ 2020-01-01)
        backtester.load_data("ohlcv_{symbol}_{timeframe}", "ohlcv_{symbol}_{timeframe}", "4h", "1d", "2018-01-01", "2020-01-01")
        
        total_index = backtester.df_short.index
        split_point = int(len(total_index) * 0.7)
        train_index = total_index[:split_point]
        # 학습 데이터에 대해 백테스트 수행
        backtester.df_short = backtester.df_short.loc[train_index]
        backtester.df_long = backtester.df_long.reindex(train_index, method='ffill')
        market_data_train = {"volatility": 0.06, "trend_strength": 0.4}
        dynamic_params_train = self.dynamic_param_manager.update_dynamic_params(market_data_train)
        dynamic_params_train.update(params)
        
        try:
            trades_train, _ = backtester.run_backtest(dynamic_params_train)
        except Exception:
            return 1e6
        
        if not trades_train:
            return 1e6
        
        total_pnl_train = sum(trade["pnl"] for trade in trades_train)
        final_balance_train = 10000 + total_pnl_train
        roi_train = (final_balance_train - 10000) / 10000 * 100
        
        # 검증 데이터에 대해 백테스트 수행
        # 검증용 데이터의 시작일은 원본 인덱스의 split_point번째 값을 사용합니다.
        val_start = total_index[split_point].strftime("%Y-%m-%d")
        backtester.load_data("ohlcv_{symbol}_{timeframe}", "ohlcv_{symbol}_{timeframe}", "4h", "1d", val_start, "2020-01-01")
        market_data_val = {"volatility": 0.07, "trend_strength": 0.5}
        dynamic_params_val = self.dynamic_param_manager.update_dynamic_params(market_data_val)
        dynamic_params_val.update(params)
        try:
            trades_val, _ = backtester.run_backtest(dynamic_params_val)
        except Exception:
            return 1e6

        if not trades_val:
            return 1e6
        total_pnl_val = sum(trade["pnl"] for trade in trades_val)
        final_balance_val = 10000 + total_pnl_val
        roi_val = (final_balance_val - 10000) / 10000 * 100
        
        # 목표: 검증 ROI를 최대화하되, 학습/검증 간 차이가 클 경우 패널티 부여
        overfit_penalty = abs(roi_train - roi_val)
        score = -roi_val + 0.5 * overfit_penalty
        return score

    def optimize(self):
        self.study = optuna.create_study(direction="minimize")
        self.study.optimize(self.objective, n_trials=self.n_trials)
        return self.study.best_trial

---

# backtesting/performance.py
import pandas as pd
import numpy as np

def calculate_monthly_performance(
    trades_df: pd.DataFrame,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl",
    period_freq: str = 'M',
    period_col: str = "year_month"
) -> pd.DataFrame:
    if exit_time_col not in trades_df.columns:
        return pd.DataFrame()
    trades_df[period_col] = trades_df[exit_time_col].dt.to_period(period_freq)
    grouped = trades_df.groupby(period_col)
    results = []
    for period_val, grp in grouped:
        total_pnl = grp[pnl_col].sum()
        num_trades = len(grp)
        win_trades = (grp[pnl_col] > 0).sum()
        win_rate = (win_trades / num_trades * 100.0) if num_trades > 0 else 0.0
        results.append({
            period_col: str(period_val),
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })
    return pd.DataFrame(results)

def calculate_yearly_performance(
    trades_df: pd.DataFrame,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl",
    year_col: str = "year"
) -> pd.DataFrame:
    if exit_time_col not in trades_df.columns:
        return pd.DataFrame()
    trades_df[year_col] = trades_df[exit_time_col].dt.year
    grouped = trades_df.groupby(year_col)
    results = []
    for yr, grp in grouped:
        total_pnl = grp[pnl_col].sum()
        num_trades = len(grp)
        win_trades = (grp[pnl_col] > 0).sum()
        win_rate = (win_trades / num_trades * 100.0) if num_trades > 0 else 0.0
        results.append({
            year_col: yr,
            'total_pnl': total_pnl,
            'num_trades': num_trades,
            'win_rate(%)': win_rate
        })
    return pd.DataFrame(results)

def calculate_mdd(
    trades_df: pd.DataFrame,
    initial_balance: float,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl",
    mdd_factor: float = 100.0
) -> float:
    if exit_time_col not in trades_df.columns:
        return 0.0
    trades_df = trades_df.sort_values(by=exit_time_col)
    equity_list = []
    current_balance = initial_balance
    for _, row in trades_df.iterrows():
        current_balance += row[pnl_col]
        equity_list.append(current_balance)
    equity_arr = np.array(equity_list)
    peak_arr = np.maximum.accumulate(equity_arr)
    drawdown_arr = (equity_arr - peak_arr) / peak_arr
    mdd = drawdown_arr.min() * mdd_factor
    return mdd

def calculate_sharpe_ratio(
    trades_df: pd.DataFrame,
    initial_balance: float,
    risk_free_rate: float = 0.0,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl"
) -> float:
    if trades_df.empty or len(trades_df) < 2:
        return 0.0
    trades_df = trades_df.sort_values(by=exit_time_col)
    current_balance = initial_balance
    returns_list = []
    for _, row in trades_df.iterrows():
        pnl = row[pnl_col]
        ret = pnl / current_balance
        returns_list.append(ret)
        current_balance += pnl
    returns_arr = np.array(returns_list)
    if len(returns_arr) < 2:
        return 0.0
    mean_return = returns_arr.mean()
    std_return = returns_arr.std(ddof=1)
    if std_return == 0:
        return 0.0
    sharpe = (mean_return - risk_free_rate) / std_return
    return sharpe

def print_performance_report(
    trades_df: pd.DataFrame,
    initial_balance: float,
    exit_time_col: str = "exit_time",
    pnl_col: str = "pnl",
    monthly_header: str = "=== (A) 월별 성과 ===",
    yearly_header: str = "=== (B) 연도별 성과 ===",
    overall_header: str = "=== (C) 전체 성과 ===",
    no_trades_message: str = "No trades to report."
) -> None:
    if trades_df.empty:
        print(no_trades_message)
        return
    monthly_df = calculate_monthly_performance(trades_df, exit_time_col, pnl_col)
    yearly_df = calculate_yearly_performance(trades_df, exit_time_col, pnl_col)
    total_pnl = trades_df[pnl_col].sum()
    final_balance = initial_balance + total_pnl
    mdd = calculate_mdd(trades_df, initial_balance=initial_balance, exit_time_col=exit_time_col, pnl_col=pnl_col)
    sharpe = calculate_sharpe_ratio(trades_df, initial_balance=initial_balance, exit_time_col=exit_time_col, pnl_col=pnl_col)
    print(monthly_header)
    print(monthly_df)
    print("\n" + yearly_header)
    print(yearly_df)
    print("\n" + overall_header)
    print(f"  - 초기 잔고       : {initial_balance:.2f}")
    print(f"  - 최종 잔고       : {final_balance:.2f}")
    print(f"  - 총 손익         : {total_pnl:.2f}")
    print(f"  - ROI(%)          : {(final_balance - initial_balance) / initial_balance * 100:.2f}%")
    print(f"  - 최대낙폭(MDD)   : {mdd:.2f}%")
    print(f"  - 샤프 지수(단순) : {sharpe:.3f}")
    num_trades = len(trades_df)
    wins = (trades_df[pnl_col] > 0).sum()
    win_rate = (wins / num_trades * 100.0) if num_trades > 0 else 0.0
    print(f"  - 총 매매 횟수    : {num_trades}")
    print(f"  - 승률(%)         : {win_rate:.2f}%")
