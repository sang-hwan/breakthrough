[data]
# config/db_config.py
DATABASE = {
    'user': 'postgres',
    'password': '1234',
    'host': 'localhost',
    'port': 5432,
    'dbname': 'my_trading_db'
}

---

# data_collection/db_manager.py
from sqlalchemy import create_engine, text
import psycopg2
from psycopg2.extras import execute_values
import pandas as pd
from config.db_config import DATABASE

def insert_on_conflict(table, conn, keys, data_iter):
    raw_conn = conn.connection
    cur = raw_conn.cursor()
    values = list(data_iter)
    columns = ", ".join(keys)
    sql = f"INSERT INTO {table.name} ({columns}) VALUES %s ON CONFLICT (timestamp) DO NOTHING"
    execute_values(cur, sql, values)
    cur.close()

def insert_ohlcv_records(df: pd.DataFrame, table_name: str = 'ohlcv_data', conflict_action: str = "DO NOTHING", db_config: dict = None) -> None:
    if db_config is None:
        db_config = DATABASE
    engine = create_engine(
        f"postgresql://{db_config['user']}:{db_config['password']}@"
        f"{db_config['host']}:{db_config['port']}/{db_config['dbname']}"
    )
    create_table_sql = text(f"""
            CREATE TABLE IF NOT EXISTS {table_name} (
                timestamp TIMESTAMP NOT NULL,
                open DOUBLE PRECISION,
                high DOUBLE PRECISION,
                low DOUBLE PRECISION,
                close DOUBLE PRECISION,
                volume DOUBLE PRECISION,
                PRIMARY KEY (timestamp)
            );
            """)
    with engine.begin() as conn:
        conn.execute(create_table_sql)
    df = df.copy()
    df.reset_index(inplace=True)
    df.to_sql(
        table_name,
        engine,
        if_exists='append',
        index=False,
        method=insert_on_conflict
    )

def fetch_ohlcv_records(table_name: str = 'ohlcv_data', start_date: str = None, end_date: str = None, db_config: dict = None) -> pd.DataFrame:
    if db_config is None:
        db_config = DATABASE
    engine = create_engine(
        f"postgresql://{db_config['user']}:{db_config['password']}@"
        f"{db_config['host']}:{db_config['port']}/{db_config['dbname']}"
    )
    query = f"SELECT * FROM {table_name} WHERE 1=1"
    params = {}
    if start_date:
        query += " AND timestamp >= :start_date"
        params['start_date'] = start_date
    if end_date:
        query += " AND timestamp <= :end_date"
        params['end_date'] = end_date
    query += " ORDER BY timestamp"
    query = text(query)
    df = pd.read_sql(query, engine, params=params, parse_dates=['timestamp'])
    df.set_index('timestamp', inplace=True)
    return df

---

# data_collection/ohlcv_fetcher.py
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

def fetch_historical_ohlcv_data(symbol: str, timeframe: str, start_date: str, limit_per_request: int = 1000, pause_sec: float = 1.0, exchange_id: str = 'binance', time_offset_ms: int = 1) -> pd.DataFrame:
    start = pd.to_datetime(start_date)
    end = datetime.now()
    date_range = pd.date_range(start, end, freq=timeframe)
    data = {
        "open": np.random.random(len(date_range)) * 100,
        "high": np.random.random(len(date_range)) * 100,
        "low": np.random.random(len(date_range)) * 100,
        "close": np.random.random(len(date_range)) * 100,
        "volume": np.random.random(len(date_range)) * 10
    }
    df = pd.DataFrame(data, index=date_range)
    df.index.name = "timestamp"
    return df

def fetch_latest_ohlcv_data(symbol: str, timeframe: str, limit: int = 500, exchange_id: str = 'binance') -> pd.DataFrame:
    end = datetime.now()
    freq = timeframe
    date_range = pd.date_range(end - pd.Timedelta(hours=limit), end, freq=freq)
    data = {
        "open": np.random.random(len(date_range)) * 100,
        "high": np.random.random(len(date_range)) * 100,
        "low": np.random.random(len(date_range)) * 100,
        "close": np.random.random(len(date_range)) * 100,
        "volume": np.random.random(len(date_range)) * 10
    }
    df = pd.DataFrame(data, index=date_range)
    df.index.name = "timestamp"
    return df

---

# data_collection/ohlcv_pipeline.py
import time
from typing import List, Optional
from data_collection.ohlcv_fetcher import fetch_historical_ohlcv_data, fetch_latest_ohlcv_data
from data_collection.db_manager import insert_ohlcv_records

def collect_and_store_ohlcv_data(
    symbols: List[str],
    timeframes: List[str],
    use_historical: bool = True,
    start_date: Optional[str] = '2018-01-01 00:00:00',
    limit_per_request: int = 1000,
    latest_limit: int = 500,
    pause_sec: float = 1.0,
    table_name_format: str = "ohlcv_{symbol}_{timeframe}",
    exchange_id: str = 'binance',
    time_offset_ms: int = 1
) -> None:
    for symbol in symbols:
        for tf in timeframes:
            print(f"\n[*] Fetching {symbol} - {tf} data...")
            if use_historical:
                if not start_date:
                    raise ValueError("start_date는 과거 데이터 수집 시 반드시 필요합니다.")
                df = fetch_historical_ohlcv_data(
                    symbol=symbol,
                    timeframe=tf,
                    start_date=start_date,
                    limit_per_request=limit_per_request,
                    pause_sec=pause_sec,
                    exchange_id=exchange_id,
                    time_offset_ms=time_offset_ms
                )
            else:
                df = fetch_latest_ohlcv_data(
                    symbol=symbol,
                    timeframe=tf,
                    limit=latest_limit,
                    exchange_id=exchange_id
                )
            table_name = table_name_format.format(symbol=symbol.replace('/', '').lower(), timeframe=tf)
            print(f"    -> Total Rows Fetched: {len(df)}")
            insert_ohlcv_records(df, table_name=table_name)
            print(f"    -> Saved to table: {table_name}")
            time.sleep(pause_sec)

---

# update_ohlcv_data.py
import time
import pandas as pd
from datetime import datetime, timedelta

# DB 관련 모듈 및 데이터 수집 모듈 import
from data_collection.db_manager import fetch_ohlcv_records, insert_ohlcv_records
from data_collection.ohlcv_fetcher import fetch_historical_ohlcv_data

# 업데이트할 심볼 및 시간 프레임 (이전에 시총 상위 3종, 예: BTC/USDT, ETH/USDT, BNB/USDT)
symbols = ["BTC/USDT", "ETH/USDT", "BNB/USDT"]
# 시간 프레임: 1일, 4시간, 1시간, 15분
timeframes = ["1d", "4h", "1h", "15min"]

def update_data_for_symbol_timeframe(symbol: str, timeframe: str) -> None:
    # 테이블명은 시간 프레임에서 'min'을 'm'으로 변경하여 사용
    table_name = f"ohlcv_{symbol.replace('/', '').lower()}_{timeframe.replace('min', 'm')}"
    print(f"\n[*] {symbol} - {timeframe} 데이터 업데이트를 시작합니다...")
    
    # 기존 데이터 조회: DB에 저장된 마지막 timestamp를 가져옴
    try:
        df_existing = fetch_ohlcv_records(table_name=table_name)
    except Exception as e:
        print(f"  [!] {table_name} 데이터 조회 중 오류 발생: {e}")
        df_existing = pd.DataFrame()
    
    if not df_existing.empty:
        last_timestamp = df_existing.index.max()
        if timeframe.endswith('d'):
            delta = timedelta(days=int(timeframe[:-1]))
        elif timeframe.endswith('h'):
            delta = timedelta(hours=int(timeframe[:-1]))
        elif timeframe.endswith('min'):
            delta = timedelta(minutes=int(timeframe[:-3]))
        else:
            delta = timedelta(0)
            
        new_start = last_timestamp + delta
        if new_start > datetime.now():
            print(f"  [*] {table_name}는 이미 최신 데이터입니다. (마지막 시간: {last_timestamp})")
            return
        start_date_str = new_start.strftime("%Y-%m-%d %H:%M:%S")
    else:
        start_date_str = "2018-01-01 00:00:00"
    
    print(f"  [*] {table_name}의 최신 데이터를 {start_date_str}부터 현재({datetime.now().strftime('%Y-%m-%d %H:%M:%S')})까지 가져옵니다.")
    df_new = fetch_historical_ohlcv_data(symbol=symbol, timeframe=timeframe, start_date=start_date_str)
    
    if df_new.empty:
        print(f"  [*] {table_name}에 추가할 새로운 데이터가 없습니다.")
        return
    
    print(f"  [*] {table_name}에 {len(df_new)}건의 신규 데이터가 조회되었습니다. DB에 삽입합니다...")
    try:
        insert_ohlcv_records(df_new, table_name=table_name)
        print(f"  [*] {table_name} 업데이트 완료.")
    except Exception as e:
        print(f"  [!] {table_name} 데이터 삽입 중 오류 발생: {e}")
    
    time.sleep(1)

def main():
    for symbol in symbols:
        for tf in timeframes:
            update_data_for_symbol_timeframe(symbol, tf)

if __name__ == "__main__":
    main()
